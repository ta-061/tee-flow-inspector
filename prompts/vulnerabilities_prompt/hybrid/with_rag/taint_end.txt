Based on the taint analysis above, decide if there is an ACTUAL vulnerability in the analyzed path.

Decision Criteria:
1) Does tainted data reach a dangerous sink?
2) Do validations/sanitizers block exploitation?
3) Under what concrete conditions is exploitation plausible?

OUTPUT CONTRACT (STRICT)

Line 1 (REQUIRED):
{"vulnerability_found":"yes"|"no"}

Line 2 (REQUIRED):
If "yes":
  EXACT JSON with:
  {
    "vulnerability_type": "CWE-XXX",
    "severity": "low|medium|high|critical",
    "taint_flow_summary": {
      "source": "<brief>",
      "propagation_path": ["A -> B @ <file>:<line>", "..."],
      "sink": "<brief>"
    },
    "exploitation_analysis": {
      "preconditions": ["..."],
      "attack_scenario": "<short>",
      "impact": "<short>"
    },
    "missing_mitigations": [
      {"type":"bounds_check|type_validation|access_control|encryption","location":"function:line|unknown","recommendation":"<specific>"}
    ],
    "confidence_factors": {
      "positive_indicators": ["..."],
      "negative_indicators": ["..."],
      "confidence_level": "high|medium|low"
    },
    "decision_rationale": "<why this IS a vulnerability>"
  }

If "no":
  EXACT JSON with:
  {
    "why_no_vulnerability": "<one-sentence summary>",
    "effective_sanitizers": [
      {"type":"bounds_check|type_validation|access_control|range_check|mem_access_check",
       "location":"function:line|unknown",
       "evidence":"<short excerpt or reason>"}
    ],
    "argument_safety": [
      {"arg":"<name or param ref>", "why_safe":"<e.g., length capped by min(size, dst_cap)>", "evidence":"file:line|unknown"}
    ],
    "residual_risks": ["<edge case if any, or empty>"],
    "confidence_factors": {
      "positive_indicators": ["<what increased confidence>"],
      "negative_indicators": ["<what might reduce confidence>"],
      "confidence_level": "high|medium|low"
    },
    "decision_rationale": "<why this ISN'T a vulnerability>"
  }

Line 3 (OPTIONAL):
For "yes": END_FINDINGS={"items":[...]}       # required if a concrete end sink remains
For "no":  END_FINDINGS={"items":[]}          # or omit

Rules:
- If DITING rule ID matches, include it in rule_matches.rule_id.
- If using {rag_context} for semantics, include rag_refs labels.
- Respect guardrails: alloc/free are non-sinks; random bytes are non-sensitive.
- Keep outputs concise, deterministic, and in the exact schema.
