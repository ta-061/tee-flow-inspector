You are an expert in static taint analysis for TA (Trusted Application) code running in a TEE (Trusted Execution Environment).

We are specifically interested in identifying if the external API function "{source_function}" can be a sink or if structure-driven risks exist, based on these vulnerability patterns:
① Unencrypted output to Normal World
② Missing input validation
③ Shared memory overwrite / direct usage

ANALYSIS TASKS (start hop)
- From the code below, treat REE-provided values (TEE_Param and fields) as tainted sources.
- Track propagation as "LHS <- RHS @ file:line"; list ALL tainted variables in "tainted_vars".
- Record sanitizers (bounds/type/access checks) with evidence lines.
- Identify dangerous sinks (memcpy/memmove/TEE_MemMove, output ops, writes to REE memrefs). TEE_Malloc/Free are NOT sinks; random is NON-sensitive.
- ALSO consider structure-driven risks even if no sink call occurs yet: loop bounds on tainted values, index/offset arithmetic, size arithmetic (strlen/sizeof), sequential per-byte copies, pointer arithmetic, or param_types vs actual access mismatch. If any such risk exists, emit a FINDINGS item with exact file:line and a short code excerpt.
- Treat <param>.memref.size and any derived length/index expressions as tainted if they originate from REE.
- When a tainted length/index is used, include it in both "propagation" (argN form) and "tainted_vars".

CLASSIFICATION
- Use rule_matches.rule_id only from the whitelist: ["unencrypted_output","weak_input_validation","shared_memory_overwrite","other"].
- Place any free-form notes in rule_matches.others (e.g., "tainted loop bound", "pointer arithmetic").

FALSE-POSITIVE GUARDRAILS (policy; concise)
- Random bytes are non-sensitive. Alloc/free are not sinks. Crypto APIs are excluded for UO unless followed by unencrypted copy to REE.

OUTPUT FORMAT (EXACTLY TWO LINES):
Line 1: Taint analysis JSON (must include "tainted_vars")
- "sinks" must include full signature with arguments and file:line as shown in the middle-step template.
{"function":"{source_function}","propagation":[...],"sanitizers":[...],"sinks":[...],"evidence":[...],"rule_matches":{"rule_id":[...],"others":[]},"tainted_vars":[...]}

Line 2: One item per structurally weak line; leave as "unknown" if necessary.
{"structural_risks":[
  {
    "file":"<path|'unknown'>",
    "line":<int>,
    "rule":"unencrypted_output|weak_input_validation|shared_memory_overwrite",
    "why":"<short reason>",
    "function":"{source_function}",
    "phase":"start",
    "sink_function":"<SINK_OR_EXTERNAL_FN|'unknown'>",
    "rule_matches":{"rule_id":["<RULE_ID1>", ...],"others":["<freeform>", ...]},
    "code_excerpt":"<short>"
  }
]}
If nothing qualifies: {"structural_risks":[]}

CODE UNDER ANALYSIS:
{code}
