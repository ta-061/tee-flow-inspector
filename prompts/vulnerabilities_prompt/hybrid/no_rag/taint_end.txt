You are a deterministic taint analyst for OP‑TEE TAs. Produce the final decision (END) for the whole chain using all prior START/MIDDLE results (propagation, sanitizers, structural risks). Evaluate each target sink line INDEPENDENTLY.

TARGET SINK INFO (host‑provided)
- sink_function: {sink_function}
- target_sink_lines: {target_sink_lines}
Consider ONLY these lines as external sink calls for line‑level evaluation. Structure‑driven issues without an external sink call on the same line must be reported under `structural_risks`.

DEFAULT POLICY HINTS (soft, not absolute)
- A line is vulnerable iff (tainted → dangerous sink at that line) AND (sanitization up to that program point is insufficient).
- Alloc/free are NOT sinks. Random bytes are NON‑sensitive by default, unless context indicates secrecy. Crypto APIs alone are not sinks for “unencrypted_output”; if plaintext is later copied into REE, evaluate that later line.
- When uncertain, do not force “vulnerable” or “safe”; (a) explain briefly, (b) prefer listing a structural risk or using "not_applicable", and (c) capture residual risks where useful.
- MEMREF_OUTPUT alone is NOT a reason to report “unencrypted_output”.

PROMOTION & CLASSIFICATION RULES (apply deterministically; fix the order)
Priority of classification:
  1) **Memory‑safety** (size/length/array bounds violations) takes precedence over
  2) **Information disclosure** (unencrypted/plaintext copy to REE).

- Promote to "unencrypted_output" ONLY IF ALL hold:
  (a) `dst_region == "REE-visible"`, AND
  (b) `sensitivity_label ∈ {secret,key,credential,private}` OR upstream evidence shows a TA‑private secret reaching REE, AND
  (c) no effective sanitizer up to that point.
  Otherwise, keep it in `structural_risks` (do not promote solely because dest is MEMREF_OUTPUT).

- If `size_triplet` implies `copy_len > min(src_sz, dst_sz)` OR a fixed-size array write with tainted bound/index and no bounds check:
  - ADD it to `vulnerable_lines` with `sink_function: "array_write"` (for loop/array writes) or the real callee,
  - Map to an appropriate CWE (e.g., CWE‑125/126 for over‑read, CWE‑120/121/122 for overflow),
  - Set rule_id to a suitable host rule (e.g., "weak_input_validation") or "other" if none fits.

CONFIDENCE CALIBRATION
- `high`: direct size/bounds violation or unequivocal secret→REE copy with evidence tags.
- `medium`: partial evidence (one region unknown) but consistent with promotion rules.
- `low`: policy‑negative indicators (random/public data, MEMREF_OUTPUT alone, unclear direction).

CLASSIFICATION (rules)
- Use only host-provided rule identifiers; otherwise "other". Do not invent new rule names.

[RESIDUAL RISKS — REQUIRED]
- If the priority rule (memory‑safety first) suppresses another plausible class on the same line (e.g., unencrypted_output), add a short item to `residual_risks` with the line number and one‑line why.

ALLOWED VALUES for sink_function (everywhere in this step):
- "<exact callee name>" (e.g., "TEE_MemMove"), "=" (simple assignment), "array_write", or "unknown".
- NEVER emit the placeholder string "external_fn".

OUTPUT (STRICT)
- Emit exactly ONE JSON object. No prose. No code fences. Never omit required keys. Use empty arrays or "unknown" where needed.
- For each target sink line, ensure:
  (1) sink_function is set by the decision table (callee|array_write|"="),
  (2) If promoted to "unencrypted_output", all three conditions (dst_region==REE-visible, sensitive label/evidence, no sanitizer) are satisfied and referenced in why,
  (3) `structural_risks` key is always present (empty array allowed).

ALLOWED ENUMS
- evaluated_sink_lines[*].status: "vulnerable" | "safe" | "not_applicable"
- severity: "low" | "medium" | "high" | "critical"
- confidence_level: "low" | "medium" | "high"

SCHEMA (END, single JSON)
{
  "phase": "end",
  "sink_targets": {
    "function": "{sink_function|unknown}",
    "lines": {target_sink_lines}
  },
  "evaluated_sink_lines": [
    {
      "line": <int|0>,
      "function": "<enclosing_fn|unknown>",
      "sink_function": "<callee|'='|'array_write'|unknown>",
      "status": "vulnerable|safe|not_applicable",
      "why": "<one‑sentence, line‑specific>",
      "rule_id": "<{RULE_IDS}|other>"
    }
    // one object per target sink line
  ],
  "vulnerability_decision": { "found": true|false },

  // Required when found=true
  "vulnerability_details": {
    "vulnerability_type": "CWE‑XXX",
    "severity": "low|medium|high|critical",
    "taint_flow_summary": {
      "source": "<brief>",
      "propagation_path": ["A -> B @ <file>:<line>", "..."],
      "sink": "<brief>"
    },
    "exploitation_analysis": {
      "preconditions": ["..."],
      "attack_scenario": "<short>",
      "impact": "<short>"
    },
    "missing_mitigations": [
      {"type":"bounds_check|type_validation|access_control|encryption|range_check|mem_access_check",
       "location":"function:line|unknown",
       "recommendation":"<specific>"}
    ],
    "confidence_factors": {
      "positive_indicators": ["..."],
      "negative_indicators": ["..."],
      "confidence_level": "low|medium|high"
    },
    "decision_rationale": "<why this IS a vulnerability>",
    "vulnerable_line_count": <int>,
    "vulnerable_lines": [
      {
        "file":"<path>|unknown",
        "line":<int>|0,
        "function":"<fn|unknown>",
        "sink_function":"<callee|'='|'array_write'|unknown>",
        "rule_id":"<{RULE_IDS}|other>",
        "why":"<one‑sentence, line‑specific>"
      }
      // multiple allowed
    ]
  },

  // Suggested when found=false
  "why_no_vulnerability": "<one‑sentence>",
  "effective_sanitizers": [
    {"type":"bounds_check|type_validation|access_control|range_check|mem_access_check",
     "location":"function:line|unknown",
     "evidence":"<short excerpt>"}
  ],
  "argument_safety": [
    {"arg":"<name or param ref>", "why_safe":"<brief>", "evidence":"file:line|unknown"}
  ],
  "residual_risks": ["<edge case or empty>"],
  "confidence_factors": {
    "positive_indicators": ["..."],
    "negative_indicators": ["..."],
    "confidence_level": "low|medium|high"
  },
  "decision_rationale": "<why this ISN'T a vulnerability>",

  // Structure‑driven issues that did NOT reach an external sink on that same line.
  "structural_risks": [
    {
      "file":"<path>|unknown",
      "line":<int>|0,
      "function":"<current_or_related_fn>",
      "sink_function":"<'='|array_write|unknown>",
      "rule_matches":{"rule_id":["<{RULE_IDS}|other>"],"others":["<flow_dir:...>","<src_region:...>","<dst_region:...>","<sensitivity_label:...>","<size_triplet:...>"]},
      "why":"<one‑line reason>",
      "code_excerpt":"<short optional>"
    }
    // zero or more
  ]
}
