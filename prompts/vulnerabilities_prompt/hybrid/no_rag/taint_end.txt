Based on the complete taint analysis above, we output a final determination of whether the final function in this chain is vulnerable..

DECISION RULES (short; unchanged)
- Vulnerable ONLY if untrusted REE data actually reaches a dangerous sink AND sanitization/bounds checks are insufficient.
- Non-sinks: memory alloc/free (e.g., TEE_Malloc/TEE_Free) are NOT sinks. Random bytes from TEE_GenerateRandom are NOT sensitive.
- Crypto APIs (TEE_AsymmetricEncrypt/Decrypt, TEE_AE*, TEE_Cipher*) are POLICY-EXCLUDED as sinks for "unencrypted_output". If they are the last call, return "no" unless there is a subsequent unencrypted copy to REE (e.g., snprintf/TEE_MemMove into a REE memref).
- Prefer concrete code evidence (file:line). Use "unknown" when unavailable.

LINE-LEVEL DETERMINATION
- Evaluate **each sink-call line independently** (e.g., 110/215/235/241). Do NOT treat the whole function as uniformly vulnerable.
- A sanitizer/check **applies only from its program point forward**; a post-check does not retroactively sanitize earlier lines.
- A line is *vulnerable* iff its *own* preconditions (taint → sink, insufficient checks at/above the line) hold. Otherwise, it is *safe* and MUST NOT be listed.

STRICT OUTPUT CONTRACT — EXACT LINES (no prose, no code fences)
Line 1 (REQUIRED):
{"vulnerability_found":"yes"|"no"}

Line 2 (REQUIRED): details JSON
If "yes", use:
{
  "vulnerability_type": "CWE-XXX",
  "severity": "low|medium|high|critical",
  "taint_flow_summary": {
    "source": "<brief>",
    "propagation_path": ["A -> B @ <file>:<line>"],   // NO '.' entries; if none, use "unknown"
    "sink": "<brief>"
  },
  "exploitation_analysis": {
    "preconditions": ["..."],
    "attack_scenario": "<short>",
    "impact": "<short>"
  },
  "missing_mitigations": [
    {"type":"bounds_check|type_validation|access_control|encryption|range_check|mem_access_check",
     "location":"function:line|unknown",
     "recommendation":"<specific>"}
  ],
  "confidence_factors": {
    "positive_indicators": ["..."],
    "negative_indicators": ["..."],
    "confidence_level": "high|medium|low"
  },
  "decision_rationale": "<why this IS a vulnerability>",
  "vulnerable_line_count": <int>,                //count of vulnerable lines
  "vulnerable_lines": [                          //list ONLY vulnerable lines (safe lines excluded)
    {
      "file":"<path>|unknown",
      "line":<int>|0,
      "function":"<enclosing_fn>|unknown",
      "sink_function":"<callee or '=' for direct write>|unknown",
      "rule_id":"unencrypted_output|weak_input_validation|shared_memory_overwrite|other",
      "why":"<one-sentence, line-specific reason>"
    }
    // ... one object per vulnerable line
  ]
}

If "no", use:
{
  "why_no_vulnerability": "<one-sentence summary>",
  "effective_sanitizers": [
    {"type":"bounds_check|type_validation|access_control|range_check|mem_access_check",
     "location":"function:line|unknown",
     "evidence":"<short excerpt or reason>"}
  ],
  "argument_safety": [
    {"arg":"<name or param ref>", "why_safe":"<e.g., length capped by min(size, dst_cap)>", "evidence":"file:line|unknown"}
  ],
  "residual_risks": ["<edge case if any, or empty>"],
  "confidence_factors": {
    "positive_indicators": ["<what increased confidence>"],
    "negative_indicators": ["<what might reduce confidence>"],
    "confidence_level": "high|medium|low"
  },
  "decision_rationale": "<why this ISN'T a vulnerability (include crypto-API exclusion when applicable)>"
}

Line 3 (REQUIRED): EXACT "structural_risks" block.
- List ONLY non-external-call (structure/semantics-driven) issues that **did not** reach a final dangerous sink, e.g.:
  - tainted loop bounds indexing a local/TEE buffer,
  - pointer/offset arithmetic leading to potential OOB,
  - direct assignment writes (e.g., buf[i] = x) governed by tainted values,
  - param_types vs access mismatch (no external sink call on the line).
- DO NOT include external sink calls like memcpy/TEE_MemMove/snprintf here (those belong only in details JSON if vulnerable).
{"structural_risks":[
  {
    "file":"<path>|unknown",
    "line":<int>|0,
    "function":"<current_or_related_fn>",
    "sink_function":"<'='|array_write|unknown>",         // use '=' for direct writes; never an external function here
    "rule_matches":{"rule_id":["<known_rule_id or 'other'>"],"others":[]},
    "why":"<one-line reason>",
    "code_excerpt":"<short optional snippet>"
  }
]}
