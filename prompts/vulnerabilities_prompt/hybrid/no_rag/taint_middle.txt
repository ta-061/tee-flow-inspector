Continue the taint analysis for the next step in the call chain.

You will receive:
- Code to analyze: 
{code}
- (Optional) Upstream context: {upstream_context}   # tainted symbol(s), call hop, param mapping

FALSE-POSITIVE GUARDRAILS:
- TEE_GenerateRandom output is NON-sensitive by default (do NOT flag as unencrypted_output when copied out).
- Alloc/Free (TEE_Malloc/TEE_Free) are NOT sinks.
- Emit a finding ONLY if BOTH hold: (1) concrete dangerous sink reached, (2) attacker influence is plausible from {code}.

WHAT TO INFER:
- Infer the current function name from the signature; else "unknown".
- Initialize TAINTED from {upstream_context}; otherwise infer taint only when {code} clearly ingests untrusted input.
- Track explicit dataflow only (assignments, param passing, reads/writes). For control dependence, annotate as "implicit:<var>".

OUTPUT CONTRACT (EXACTLY TWO LINES):
Line 1:
{"function":"<auto-inferred or 'unknown'>","propagation":[],"sanitizers":[],"sinks":[],"evidence":[],"rule_matches":{"rule_id":[],"others":[]}}

Line 2:
FINDINGS={"items":[
  {
    "rule":"unencrypted_output|weak_input_validation|shared_memory_overwrite",
    "file":"<path|'unknown'>",
    "line":<int>,
    "why":"<one sentence>",
    "function":"<CURRENT_FUNCTION>",
    "phase":"middle",
    "sink_function":"<SINK_OR_EXTERNAL_FN|'unknown'>",
    "rule_matches":{"rule_id":["<RULE_ID1>", ...],"others":["<freeform>", ...]},
    "code_excerpt":"<short>"
  }
]}
If nothing qualifies: FINDINGS={"items":[]}

Analysis steps:
1) Record "LHS <- RHS @ <file>:<line>" for each explicit flow in "propagation".
2) Record validators in "sanitizers" (bounds/type/access checks) with evidence lines.
3) Record dangerous sinks in "sinks" with evidence lines (exclude alloc/free).
4) If param_types declaration conflicts with actual access, put it in "evidence"; map to a rule_id ONLY if it meaningfully enables attacker influence to reach a sink.
