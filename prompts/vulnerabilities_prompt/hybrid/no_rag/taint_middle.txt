Continue the taint analysis for the next step in the call chain.

=== TARGET INFORMATION ===
- Current function: {source_function}
- Target sink (if final): {sink_function}
- Vulnerable parameters: {target_params}
- The line of interest is marked with >>>

=== ANALYSIS CONTEXT (if any) ===
{upstream_context}

=== CODE TO ANALYZE ===
{code}

GUIDANCE
- Propagate taint precisely: record "LHS <- RHS @ file:line" and list ALL tainted variables in "tainted_vars".
- Record sanitizers (bounds/type/access checks) with their lines.
- Identify dangerous sinks (e.g., TEE_MemMove/memcpy/output ops to REE). Exclude alloc/free and random; exclude crypto APIs as "unencrypted_output" unless followed by unencrypted copy to REE.
- ALSO surface structure-driven risks even without an immediate sink: tainted loop bounds, index/offset or pointer arithmetic, size arithmetic, sequential per-byte copies, or param_types vs actual access mismatch. Emit a FINDINGS item per affected line with exact file:line and short excerpt.

CLASSIFICATION
- Use whitelist rule_ids: ["unencrypted_output","weak_input_validation","shared_memory_overwrite","other"].
- Deterministic ordering; put additional notes in rule_matches.others.

OUTPUT CONTRACT (EXACTLY TWO LINES):
Line 1: Analysis JSON for the Current Function
{"function":"{source_function}","propagation":[<flows>],"sanitizers":[<checks>],"sinks":[<dangerous_calls>],"evidence":[<issues>],"rule_matches":{"rule_id":[<matches>],"others":[]},"tainted_vars":[<all_tainted>]}

Line 2:One item per structurally weak line; leave as "unknown" if necessary.
FINDINGS={"items":[
  {
    "rule":"unencrypted_output|weak_input_validation|shared_memory_overwrite",
    "file":"<path|'unknown'>",
    "line":<int>,
    "why":"<one sentence>",
    "function":"{source_function}",
    "phase":"middle",
    "sink_function":"<SINK_OR_EXTERNAL_FN|'unknown'>",
    "rule_matches":{"rule_id":["<RULE_ID1>", ...],"others":["<freeform>", ...]},
    "code_excerpt":"<short>"
  }
]}
If nothing qualifies: FINDINGS={"items":[]}
