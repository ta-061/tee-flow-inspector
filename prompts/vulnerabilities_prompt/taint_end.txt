Based on the taint analysis above, decide if there is an ACTUAL vulnerability in the analyzed code path.

## Decision Criteria
1. Does tainted data actually reach a dangerous sink?
2. Are there validation / sanitization steps that stop exploitation?

---

## OUTPUT CONTRACT (STRICT - FOLLOW EXACTLY)

**Line 1 MUST be EXACTLY one of the following (no code fences, no backticks, no leading spaces):**
{"vulnerability_found":"yes"}
{"vulnerability_found":"no"}

No other text on line 1.

**Line 2 MUST be a compact one-line JSON with supporting meta (no code fences):**
{"rule_ids":[],"evidence":[],"confidence":"low|medium|high","cwe":"","path":""}
- Populate with matched rule IDs (if any) and minimal evidence as "<file>:<line>". Use "unknown" if unavailable. Omit empty fields if unknown.

**Starting from line 3**, provide a brief explanation *only if needed*:
- If "yes": state the failing condition and why mitigations fail.
- If "no": state why the flow is safe (validation, unreachable sink, encrypted path, etc.).

## Correct Examples

Vulnerable:
{"vulnerability_found":"yes"}
{"rule_ids":["weak_input_validation"],"evidence":["core/a.c:120"],"confidence":"high","cwe":"CWE-787","path":"foo()->bar()->TEE_MemMove"}
Tainted length `len` used in `memcpy(dst, src, len)` without bounds check.

Not Vulnerable:
{"vulnerability_found":"no"}
{"rule_ids":[],"evidence":["unknown"],"confidence":"medium"}
Length validated (`len <= sizeof(buf)`) before copy; data encrypted before leaving secure world.
