Continue the taint analysis for the next step in the call chain (multiple parameter flows).

Inputs:
- Code to analyze: {code}
- (Optional) Upstream context: {upstream_context}
- (Optional) TEE API Documentation Context (RAG): {rag_context}

RAG POLICY (STRICT):
- Use rag_context only to reason about OP-TEE semantics (e.g., MEMREF_INOUT behavior, storage/crypto constraints, API parameter directions).
- Prefer code for dataflow; never invent lines.

FALSE-POSITIVE GUARDRAILS:
- TEE_Malloc / TEE_Free are NOT sinks.
- Random from TEE_GenerateRandom is NON-sensitive by default.
- Report only when a concrete sink is reached and attacker influence is plausible from {code}.

OUTPUT CONTRACT:
Line 1 (single JSON):
{"function":"<auto or parsed name>","propagation":[],"sanitizers":[],"sinks":[],"evidence":[],"rule_matches":{"rule_id":[],"others":[]}}

Guidance:
1) Track multi-parameter relations (buf-len, dst-src-n, ptr-offset-size, index-bound). Record "LHS <- RHS @ <file>:<line>".
2) Record sanitizers (bounds/length checks, access rights, type validation).
3) Record dangerous sinks (e.g., memcpy/TEE_MemMove to shared/out; persistent storage; outbound object writes) with lines.
4) If param_types misuse or unchecked size couples attacker input to a sink, put evidence lines in "evidence".
5) Classify rules into rule_matches: known IDs -> rule_id[], else others[].
6) If rag_context informs constraints (e.g., storage API expectations), add brief labels in FINDINGS.rag_refs.

Line 2 (FINDINGS):
FINDINGS={"items":[
  {
    "file":"<path|'unknown'>",
    "line":<int>,
    "rule":"<short_category>",
    "why":"<short_reason>",
    "function":"<CURRENT_FUNCTION>",
    "phase":"middle",
    "sink_function":"<SINK_OR_EXTERNAL_FN|'unknown'>",
    "rule_matches":{"rule_id":["<RULE_ID1>", ...],"others":["<freeform>", ...]},
    "rag_refs":["<doc:section|page?>", ...],
    "code_excerpt":"<short>"
  }
]}
If nothing qualifies: FINDINGS={"items":[]}
