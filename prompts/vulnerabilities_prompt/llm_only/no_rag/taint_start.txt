Function to analyze: {source_function}
Tainted parameters: {param_name}

You MUST respond first with a one-line JSON (no code fences):
{"function":"{source_function}","propagation":[],"sanitizers":[],"sinks":[],"evidence":[],"rule_matches":{"rule_id":[],"others":[]}}

Tasks:
1) Identify initial taint sources strictly from {code} (e.g., memref from TEE_Param for Normal World input).
2) Append propagation steps as "LHS <- RHS @ <file>:<line>" to "propagation".
3) Append any checks/sanitizers (param_types equality, size checks, access rights) with evidence lines.
4) Append non-alloc dangerous sinks (e.g., memcpy/TEE_MemMove into shared/out buffers) with evidence lines to "sinks".
5) Append notable facts (param_types mismatch vs actual access, etc.) to "evidence".
6) Classify matched rules into "rule_matches":{"rule_id":[...],"others":[...]}.
7) Non-sinks: TEE_Malloc/TEE_Free MUST NOT appear in "sinks". Random from TEE_GenerateRandom is non-sensitive by default.

Then, on the next line, output:
FINDINGS={"items":[
  {
    "file":"<path|'unknown'>",
    "line":<int>,
    "rule":"<short_category>",
    "why":"<short_reason>",
    "function":"{source_function}",
    "phase":"start",
    "sink_function":"<SINK_OR_EXTERNAL_FN|'unknown'>",
    "rule_matches":{"rule_id":["<RULE_ID1>", ...],"others":["<freeform>", ...]},
    "code_excerpt":"<short>"
  }
  // optional more items
]}
If nothing qualifies: FINDINGS={"items":[]}
