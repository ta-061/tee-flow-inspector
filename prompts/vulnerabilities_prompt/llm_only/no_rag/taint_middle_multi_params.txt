Continue the taint analysis for the next step in the call chain (multiple parameter flows).

You will receive:
- Code to analyze:
{code}
- Upstream context: {upstream_context}
- Target parameters (indices): {param_indices}

FALSE-POSITIVE GUARDRAILS:
- Random from TEE_GenerateRandom is NON-sensitive by default.
- Alloc/Free (TEE_Malloc/TEE_Free) are NOT sinks.
- Report a finding only when a concrete sink is reached and attacker influence is plausible.

WHAT TO INFER:
- Infer function name; else "unknown".
- Build TAINTED from {upstream_context}; otherwise infer only when code clearly ingests untrusted input.
- Analyze EACH parameter/symbol independently; track explicit dataflow (buf-len, dst-src-n, ptr-offset-size, index-bound). For control dependence: "implicit:<var>".

OUTPUT CONTRACT (EXACTLY TWO LINES):
Line 1:
{"function":"<auto-inferred or 'unknown'>","propagation":[],"sanitizers":[],"sinks":[],"evidence":[],"rule_matches":{"rule_id":[],"others":[]}}

Line 2:
FINDINGS={"items":[
  {
    "rule":"unencrypted_output|weak_input_validation|shared_memory_overwrite",
    "file":"<path|'unknown'>",
    "line":<int>,
    "why":"<one sentence>",
    "function":"<CURRENT_FUNCTION>",
    "phase":"middle",
    "sink_function":"<SINK_OR_EXTERNAL_FN|'unknown'>",
    "rule_matches":{"rule_id":["<RULE_ID1>", ...],"others":["<freeform>", ...]},
    "code_excerpt":"<short>"
  }
]}
If nothing qualifies: FINDINGS={"items":[]}
