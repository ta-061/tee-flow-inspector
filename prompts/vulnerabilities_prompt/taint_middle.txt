Continue the taint analysis for the next function in the call chain.

Function to analyze: {source_function}
Tainted input: {param_name} (from previous function)

You MUST respond first with a one-line JSON (no code fences):
{"function":"{source_function}","propagation":[],"sanitizers":[],"sinks":[],"evidence":[],"rule_matches":[]}

Additional output contract for inline findings:
Immediately after the one-line JSON above, output EXACTLY ONE more line:
FINDINGS={"items":[{"rule":"unencrypted_output|weak_input_validation|shared_memory_overwrite","file":"<path>","line":123,"why":"<one sentence>","evidence":"<file>:<line>","code_excerpt":"<short>"}]}
Rules:
- Always print the FINDINGS line, even when no items (use {"items":[]})
- rule MUST be one of: unencrypted_output, weak_input_validation, shared_memory_overwrite
- evidence MUST be "<file>:<line>" if known, else "unknown"
- The FINDINGS line must be a single line with no extra prose

Instructions:
1) Using ONLY the provided code, track how the tainted input flows; append steps (LHS <- RHS) to "propagation". If control depends on tainted values, add "implicit:<var>".
2) Record any validations/sanitizers that constrain the tainted value (bounds, type, access rights) in "sanitizers" with evidence "<file>:<line>" or "unknown".
3) List concrete sinks (e.g., TEE_MemMove, snprintf) in "sinks" with evidence lines.
4) If any DITING rule matches, list its `id` in "rule_matches" and add supporting evidence.
5) Keep the JSON minimal; then add up to 3 concise bullet points with key insights.

Code to analyze:
{code}
