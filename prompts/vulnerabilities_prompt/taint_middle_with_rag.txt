Continue the taint analysis for the next function in the call chain.

Function to analyze: {source_function}
Tainted input: {param_name} (from previous function)

## TEE API Documentation Context:
{rag_context}

You MUST respond first with a one-line JSON (no code fences):
{"function":"{source_function}","propagation":[],"sanitizers":[],"sinks":[],"evidence":[],"rule_matches":[]}

Instructions:
1) Use ONLY the code and the Documentation Context above when referencing API semantics. If a required detail is absent, write "unknown" and do NOT speculate.
2) Track how the tainted input flows; append steps (LHS <- RHS) to "propagation". Add "implicit:<var>" for control-dependent flows.
3) Record validations/sanitizers that constrain the tainted value in "sanitizers" with evidence "<file>:<line>" or "unknown".
4) List concrete sinks (e.g., TEE_MemMove, snprintf) in "sinks" with evidence lines.
5) If any DITING rule matches, list its `id` in "rule_matches" and add supporting evidence.
6) Keep the JSON minimal; then add up to 3 concise bullet points with key insights.

Code to analyze:
{code}
