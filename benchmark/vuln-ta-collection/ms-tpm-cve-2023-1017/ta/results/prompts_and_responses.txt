# External Function: ACT_GET_POLICY
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "ACT_GET_POLICY", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "ACT_GET_POLICY",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "ACT_GET_POLICY",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Name suggests policy retrieval, no standard write-to-buffer or IO pattern"
}

# External Function: CLEAR_CP_HASH
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "CLEAR_CP_HASH", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "CLEAR_CP_HASH",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "CLEAR_CP_HASH",
  "is_sink_candidate": true,
  "dangerous_params": [
    {
      "param_index": 0,
      "role": "dest",
      "reason": "clear/fill operation likely writes over hash buffer memory"
    },
    {
      "param_index": 1,
      "role": "len",
      "reason": "length probably controls extent of cleared buffer region"
    }
  ],
  "reason": "Name implies memset-like clearing of hash buffer with length-controlled writes"
}

# External Function: CLEAR_RP_HASH
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "CLEAR_RP_HASH", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "CLEAR_RP_HASH",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "CLEAR_RP_HASH",
  "is_sink_candidate": true,
  "dangerous_params": [
    {
      "param_index": 0,
      "role": "dest",
      "reason": "Likely clears hash buffer contents (memset-like write)."
    },
    {
      "param_index": 1,
      "role": "len",
      "reason": "Likely controls extent of buffer clearing write."
    }
  ],
  "reason": "Name suggests memset-like buffer clear of RP hash data."
}

# External Function: CopyFromOffset
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "CopyFromOffset", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "CopyFromOffset",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "CopyFromOffset",
  "is_sink_candidate": true,
  "dangerous_params": [
    {
      "param_index": 0,
      "role": "dest",
      "reason": "Copy suggests memcpy-like write into destination buffer"
    },
    {
      "param_index": 2,
      "role": "len",
      "reason": "Length likely controls extent of bytes written into dest"
    }
  ],
  "reason": "Name implies memcpy-like copy from offset into destination buffer"
}

# External Function: CopyToOffset
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "CopyToOffset", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "CopyToOffset",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "CopyToOffset",
  "is_sink_candidate": true,
  "dangerous_params": [
    {
      "param_index": 0,
      "role": "dest",
      "reason": "memcpy-like copy into buffer at offset"
    },
    {
      "param_index": 2,
      "role": "len",
      "reason": "length likely controls copied bytes extent"
    }
  ],
  "reason": "Name suggests memcpy-like write into destination buffer with length"
}

# External Function: GET_CP_HASH_POINTER
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "GET_CP_HASH_POINTER", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "GET_CP_HASH_POINTER",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "GET_CP_HASH_POINTER",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Getter-style function name; no clear write/copy/IO semantics implied"
}

# External Function: GET_DEF
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "GET_DEF", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "GET_DEF",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "GET_DEF",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Getter-style name; no standard write/persist behavior implied"
}

# External Function: GET_RP_HASH_POINTER
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "GET_RP_HASH_POINTER", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "GET_RP_HASH_POINTER",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "GET_RP_HASH_POINTER",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Getter-style function name; no standard write/copy semantics implied"
}

