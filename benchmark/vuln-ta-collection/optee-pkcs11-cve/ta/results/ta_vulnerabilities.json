{
  "analysis_date": "2026-02-21T16:34:42.733162",
  "analysis_time_seconds": 25686.412053108215,
  "analysis_time_formatted": "7.1 hours",
  "llm_provider": "openai",
  "analysis_mode": "hybrid",
  "rag_enabled": false,
  "statistics": {
    "total_flows_analyzed": 237,
    "flows_with_vulnerabilities": 72,
    "total_vulnerability_lines": 18,
    "total_structural_risk_lines": 283,
    "total_detections_before_consolidation": 349,
    "total_lines_after_consolidation": 301,
    "consolidation_rate": "13.8%",
    "severity_distribution": {
      "critical": 0,
      "high": 6,
      "medium": 14,
      "low": 0
    },
    "cwe_distribution": {
      "CWE-20/CWE-125": 2,
      "CWE‑120": 2,
      "CWE-20": 8,
      "CWE-125": 13,
      "CWE-125/CWE-787": 2,
      "CWE-125/CWE-119": 2,
      "CWE‑125": 1,
      "CWE‑126": 1,
      "CWE-120": 1,
      "CWE-119": 1,
      "CWE-189": 1
    },
    "rule_distribution": {
      "other": 270,
      "weak_input_validation": 57,
      "shared_memory_overwrite": 2
    },
    "execution_time_seconds": 25686.412053108215,
    "llm_calls": 917,
    "cache_hits": 236,
    "cache_partial_hits": 236,
    "cache_misses": 1,
    "cache_hit_rate": "99.6%",
    "token_usage": {},
    "retries": 0,
    "retry_successes": 0
  },
  "total_vulnerability_lines": 18,
  "vulnerabilities": [
    {
      "vulnerability_id": "VULN-0001",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 75,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-20/CWE-125",
      "functions": [
        "_remove_attribute"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-20/CWE-125",
        "CWE‑120",
        "CWE-20",
        "CWE-125",
        "CWE-125/CWE-787",
        "CWE-125/CWE-119"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Reads pkcs11 header via memmove without ensuring sufficient remaining bytes (end - cur >= sizeof(header)).",
        "Header-sized read from cur may exceed remaining buffer (no check that end - cur >= sizeof(header)).",
        "Reads header into pkcs11_ref then uses pkcs11_ref.size to compute offsets without ensuring next_off fits within attrs buffer.",
        "Header read from untrusted cur into local pkcs11_ref without checking that sizeof header fits before read.",
        "Reads header from cur without ensuring remaining bytes >= sizeof(header).",
        "Header read from cur using sizeof(header) without ensuring remaining buffer >= sizeof(header).",
        "Copies header from cur without confirming remaining bytes; header.size then used to drive parsing.",
        "Header read from cur without checking remaining bytes (end - cur >= sizeof(header))"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_secret",
          "generate_random_key_value",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_rsa_keys",
          "tee2pkcs_rsa_attributes",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_rsa_keys",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_ec_keys",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_eddsa_keys",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "modify_attributes_list",
          "set_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "modify_attributes_list",
          "set_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "add_missing_attribute_id",
          "set_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "Caller-supplied attributes/template buffers (params -> template -> head) originating from REE-visible memrefs",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> entry_generate_secret @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c:289",
            "entry_generate_secret -> create_attributes_from_template / generate_random_key_value -> head @ processing.c:263-266,294",
            "head passed into _remove_attribute(head, ...) @ attributes.c:61-64",
            "_remove_attribute reads header fields from cur and uses pkcs11_ref.size to compute next_off and copy lengths @ attributes.c:75-76,84"
          ],
          "sink": "TEE_MemMove calls at lines 75 and 84 that use attacker-influenced lengths/offsets"
        },
        {
          "source": "Caller-supplied attribute templates/obj_attrs (originating from REE via params)",
          "propagation_path": [
            "params -> pub_template/priv_template @ processing.c:425-431",
            "pub_head/priv_head built from templates -> passed into generate_rsa_keys @ processing.c:519",
            "pub_head/priv_head -> tee2pkcs_rsa_attributes @ processing_rsa.c:761",
            "head (obj_attrs) -> _remove_attribute via remove_empty_attribute @ attributes.c:98/101",
            "cur/end computed from h->attrs_size and used in TEE_MemMove @ attributes.c:70-75,84"
          ],
          "sink": "TEE_MemMove calls at lines 75 (header read) and 84 (in-place shift) operating on REE-derived buffer regions"
        },
        {
          "source": "Attributes buffer (obj_attrs->attrs) ultimately derived from caller-provided templates (REE-visible)",
          "propagation_path": [
            "params (caller) -> templates -> pub_head/priv_head @ processing.c",
            "pub_head/priv_head -> attribute data placed in attrs buffer -> passed into _remove_attribute @ attributes.c:64",
            "cur (pointer into attrs buffer) -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:75",
            "pkcs11_ref.size -> next_off -> TEE_MemMove(cur, cur + next_off, ...) @ attributes.c:84"
          ],
          "sink": "TEE_MemMove calls at lines 75 and 84 that read sizes from untrusted memory and use them to compute copy offsets"
        },
        {
          "source": "Caller-provided obj_attrs blob (params templates originated from REE)",
          "propagation_path": [
            "params -> pub_template/priv_template (processing.c) @ processing.c:425-431",
            "pub_head/priv_head populated from templates -> passed into generate_ec_keys @ processing.c:516",
            "obj_attrs blob (h) used in _remove_attribute: h = *head @ attributes.c:64",
            "cur calculated from h and used as src in TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:75",
            "pkcs11_ref.size -> next_off -> used in TEE_MemMove(cur, cur + next_off, ...) @ attributes.c:84"
          ],
          "sink": "TEE_MemMove reads/writes driven by attacker-controlled sizes inside _remove_attribute"
        },
        {
          "source": "Caller-provided attribute buffer (params → serialargs → templates → obj_attrs->attrs blob)",
          "propagation_path": [
            "params (REE-origin) → serialargs / templates @ processing.c:415-431",
            "templates → pub_head/priv_head (TA structures) @ processing.c:448-472",
            "pub_head/priv_head -> *head passed into generate_eddsa_keys -> remove_empty_attribute -> _remove_attribute @ processing_ec.c:739 / attributes.c:61",
            "parsing loop reads pkcs11_ref from cur via TEE_MemMove @ attributes.c:75",
            "next_off derived from pkcs11_ref.size used in TEE_MemMove shift @ attributes.c:84"
          ],
          "sink": "TEE_MemMove calls at attributes.c:75 and attributes.c:84 that read/shift memory using unvalidated sizes"
        },
        {
          "source": "Caller-provided serialized attributes buffer (params->memref.buffer) parsed into template/head then propagated into obj_attrs->attrs memory",
          "propagation_path": [
            "params[0].memref.buffer -> serialargs_alloc_get_attributes -> template/head @ object.c:1002",
            "head->attrs_size used to set end and drive loop bounds @ attributes.c:70-71",
            "cur (within head) -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:75",
            "pkcs11_ref.size -> next_off -> TEE_MemMove(cur, cur + next_off, end - (cur + next_off)) @ attributes.c:76,84"
          ],
          "sink": "TEE_MemMove reads/writes using lengths derived from untrusted parsed sizes"
        },
        {
          "source": "Caller-provided serialized attributes (params->ctrl->memref.buffer) originating from REE",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> entry_copy_object @ entry.c:310",
            "entry_copy_object builds template/head from ctrl buffer -> modify_attributes_list @ object.c:1215",
            "modify_attributes_list iterates attribute stream and calls set_attribute -> _remove_attribute @ attributes.c:70-76",
            "_remove_attribute reads header from cur via TEE_MemMove @ attributes.c:75 and later memmoves data @ attributes.c:84"
          ],
          "sink": "TEE_MemMove operations that copy based on untrusted header.size and buffer lengths"
        },
        {
          "source": "Attributes blob (cur) originally rooted in templates/serialargs ultimately derived from params (REE-visible)",
          "propagation_path": [
            "params (REE) -> pub_template/priv_template (processing.c)",
            "template bytes -> obj_attrs->h->attrs (attributes.c): cur points into attrs (@ attributes.c:70)",
            "cur -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) (@ attributes.c:75)",
            "pkcs11_ref.size -> next_off -> TEE_MemMove(cur, cur+next_off, end-(cur+next_off)) (@ attributes.c:76,84)"
          ],
          "sink": "TEE_MemMove reads header and later shifts memory using lengths derived from unvalidated header fields"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls or influences attribute/template bytes supplied via REE-visible params",
            "attrs_size or attribute entries contain crafted sizes (pkcs11_ref.size) that violate expected bounds"
          ],
          "attack_scenario": "Maliciously crafted attribute list causes _remove_attribute to compute next_off or permit a cur position where sizeof(pkcs11_ref) exceeds remaining bytes, leading to OOB read at line 75 or an in-place memmove with malformed length at line 84, potentially corrupting heap metadata or leaking memory.",
          "impact": "Memory corruption (read/write) leading to crash, information leakage, or arbitrary code execution in TA context depending on allocator/heap layout."
        },
        {
          "preconditions": [
            "Attacker supplies malformed attribute list / attrs_size in params leading to h->attrs_size inconsistent with actual buffer",
            "TA does not perform independent validation of h->attrs_size or per-entry size fields"
          ],
          "attack_scenario": "Crafted attrs_size or pkcs11_ref.size cause the header read at line 75 to read past the buffer or next_off to be manipulated so the in-place memmove at line 84 copies/overwrites data out-of-bounds, potentially corrupting memory or leaking contents when later copied to REE.",
          "impact": "Memory corruption in TEE (denial-of-service via panic/abort or more severe integrity compromise); potential disclosure of adjacent memory if later copied to REE."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed attribute data supplied via REE-visible templates/params.",
            "No additional upstream validation ensuring pkcs11_ref.size and next_off keep operations within attrs buffer bounds."
          ],
          "attack_scenario": "Provide a crafted attribute header with pkcs11_ref.size that causes next_off to point beyond attrs buffer, triggering an over-read at line 75 or an out-of-bounds/overlapping memmove at line 84 to corrupt heap/adjacent metadata or cause crashes.",
          "impact": "Memory corruption within TA (out-of-bounds read/write), possible denial-of-service (panic/crash) or exploitation for code execution depending on allocator/state."
        },
        {
          "preconditions": [
            "Attacker supplies crafted obj_attrs blob via REE-visible params/templates",
            "attrs_size and embedded pkcs11_ref.size fields are crafted to violate invariants"
          ],
          "attack_scenario": "Maliciously crafted attribute list with manipulated attrs_size and pkcs11_ref.size causes _remove_attribute to compute next_off that leads TEE_MemMove to read/write out of bounds, leading to memory corruption inside the TA.",
          "impact": "Memory corruption in TA leading to crash, data corruption, or potential code execution within TA context; confidentiality/integrity of TA secrets may be compromised."
        },
        {
          "preconditions": [
            "Attacker supplies crafted attribute list via REE-side params leading to obj_attrs with manipulated attrs_size or pkcs11_ref.size",
            "TA code reaches remove_empty_attribute/_remove_attribute (e.g., generate_eddsa_keys path)"
          ],
          "attack_scenario": "Maliciously crafted attrs blob with truncated or oversized pkcs11_ref.size causes TEE_MemMove at line 75 to read beyond available buffer or at line 84 to move overlapping memory with incorrect length, leading to memory disclosure, corruption, or crash in the TA.",
          "impact": "Memory-safety violation (out-of-bounds read/write) enabling potential crash, information disclosure of TA memory, or corruption leading to further compromise of TA state."
        },
        {
          "preconditions": [
            "Attacker controls or crafts the serialized attributes buffer supplied in params memref",
            "TA does not further validate attrs_size or individual attribute sizes beyond current checks"
          ],
          "attack_scenario": "Maliciously crafted attrs_size or attribute size causes loop parsing to accept a header but with pkcs11_ref.size that causes subsequent memmove to copy out-of-bounds or with an underflowed length, leading to memory corruption or information disclosure.",
          "impact": "Memory corruption leading to crash or arbitrary write/reading of sensitive TA memory; potential escalation to data leakage or code execution depending on layout."
        },
        {
          "preconditions": [
            "Attacker-controlled serialized attributes blob supplied via REE to params",
            "No additional runtime integrity checks on attrs_size or individual header.size fields"
          ],
          "attack_scenario": "Craft attrs_size and/or per-attribute header.size so that sizeof(header) or next_off exceeds remaining bytes; trigger TEE_MemMove to read/write past buffer, causing crash or memory corruption.",
          "impact": "Memory corruption leading to denial-of-service, potential arbitrary code execution or disclosure of TA memory depending on layout and exploitation."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed attributes blob in REE-provided memref reaches h->attrs buffer",
            "No additional validation that ensures each attribute header and size fit inside h->attrs_size"
          ],
          "attack_scenario": "Crafted attributes cause pkcs11_ref.size to be large or inconsistent so TEE_MemMove reads/writes out-of-bounds, potentially enabling memory disclosure or corruption leading to control-flow hijack or data leak.",
          "impact": "Memory corruption or information disclosure within TA; possible panic, arbitrary code execution in TA context or leakage of TA-private data."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "attributes.c:75-76|84",
          "recommendation": "Validate that (end - cur) >= sizeof(pkcs11_attribute_head) before reading header; validate pkcs11_ref.size and next_off against h->attrs_size and minimum/maximum sensible limits before using in arithmetic or memmove."
        },
        {
          "type": "range_check",
          "location": "processing.c:191",
          "recommendation": "Validate value_len from template is within allowed maximum before TEE_Malloc to avoid excessively large allocations."
        },
        {
          "type": "bounds_check",
          "location": "_remove_attribute:70-76",
          "recommendation": "Verify end - cur >= sizeof(pkcs11_attribute_head) before copying header and validate pkcs11_ref.size against remaining bytes."
        },
        {
          "type": "range_check",
          "location": "_remove_attribute:76-84",
          "recommendation": "Ensure computed next_off is within [0, h->attrs_size] and that cur + next_off <= end before performing in-place memmove."
        },
        {
          "type": "type_validation",
          "location": "entry_generate_key_pair / parsing code:415-431",
          "recommendation": "Validate templates and attrs_size fields received from REE early and reject inconsistent sizes."
        },
        {
          "type": "bounds_check",
          "location": "attributes.c:75-84",
          "recommendation": "Validate that sizeof(pkcs11_ref) <= end - cur and that next_off = sizeof(pkcs11_ref)+pkcs11_ref.size does not exceed end - cur before using it to compute memmoves."
        },
        {
          "type": "range_check",
          "location": "attributes.c:76",
          "recommendation": "Sanity-check pkcs11_ref.size against a maximum allowed attribute size and ensure next_off > 0 and next_off <= (end - cur)."
        },
        {
          "type": "mem_access_check",
          "location": "attributes.c:84",
          "recommendation": "Use safe overlap-aware copy helper or explicitly handle overlapping regions and ensure source/destination ranges are within buffer."
        },
        {
          "type": "bounds_check",
          "location": "_remove_attribute:75-84",
          "recommendation": "Validate that cur + sizeof(pkcs11_ref) <= end before reading header; verify pkcs11_ref.size is sane and that cur + next_off <= end before any memmove."
        },
        {
          "type": "range_check",
          "location": "_remove_attribute:76-84",
          "recommendation": "Sanity-check next_off against h->attrs_size and non-zero/minimum bounds to prevent integer wrap or excessive lengths."
        },
        {
          "type": "bounds_check",
          "location": "attributes.c:72-76",
          "recommendation": "Before copying header, ensure (end - cur) >= sizeof(pkcs11_attribute_head); validate pkcs11_ref.size does not cause next_off to exceed remaining bytes."
        },
        {
          "type": "range_check",
          "location": "attributes.c:76-84",
          "recommendation": "Verify computed next_off is within [sizeof(pkcs11_ref), h->attrs_size] and that cur + next_off <= end before using it to compute move length."
        },
        {
          "type": "mem_access_check",
          "location": "attributes.c:84",
          "recommendation": "Use safe move semantics with explicit validated lengths and handle malformed inputs by returning an error instead of proceeding."
        },
        {
          "type": "bounds_check",
          "location": "modify_attributes_list/_remove_attribute:70-76",
          "recommendation": "Validate that (end - cur) >= sizeof(header) before reading header and that pkcs11_ref.size does not cause next_off to exceed (end - cur) and is within reasonable limits."
        },
        {
          "type": "range_check",
          "location": "modify_attributes_list/_remove_attribute:76-84",
          "recommendation": "Check next_off and end - (cur + next_off) for underflow/overflow before calling TEE_MemMove; reject malformed inputs."
        },
        {
          "type": "type_validation",
          "location": "entry_set_attribute_value:1002-1004",
          "recommendation": "Validate template->attrs_size and individual attribute sizes when parsing serialargs_alloc_get_attributes to ensure internal consistency."
        },
        {
          "type": "bounds_check",
          "location": "attributes.c:75-76",
          "recommendation": "Ensure end - cur >= sizeof(pkcs11_attribute_head) before copying header; validate header.size against remaining bytes"
        },
        {
          "type": "bounds_check",
          "location": "attributes.c:84",
          "recommendation": "Validate next_off and that (cur + next_off) <= end before memmoving; use safe helpers that check ranges"
        },
        {
          "type": "range_check",
          "location": "modify_attributes_list:215-222",
          "recommendation": "Sanitize head->attrs_size and guard loop iterations to avoid parsing beyond buffer"
        },
        {
          "type": "bounds_check",
          "location": "_remove_attribute:70-76",
          "recommendation": "Validate that end - cur >= sizeof(pkcs11_attribute_head) before reading header; validate pkcs11_ref.size and that sizeof(pkcs11_ref)+pkcs11_ref.size <= end - cur"
        },
        {
          "type": "range_check",
          "location": "_remove_attribute:76-84",
          "recommendation": "Ensure next_off is non-zero, within remaining attrs_size and does not cause underflow in end - (cur + next_off) before memmove"
        }
      ],
      "decision_rationales": [
        "Memory-safety issues are primary: attacker-controlled sizes are used without adequate bounds, enabling OOB reads/writes at the TEE_MemMove call sites; these are clear code-level weaknesses with direct data/control flow from REE-provided templates.",
        "Memory-safety issues take precedence: both header read and in-place shift use sizes derived from potentially REE-controlled fields without sufficient local bounds checks, enabling out-of-bounds read and shared-memory overwrite in REE-visible buffers.",
        "Memory-safety risk takes precedence: untrusted size is used to compute memmove offsets without adequate validation, producing clear potential for out-of-bounds read/write and memory corruption at the two examined sink lines.",
        "Memory-safety issue (untrusted length used to compute copy offsets) is present at both lines; this yields high-confidence out-of-bounds read/write potential and takes precedence over information-disclosure classifications.",
        "Memory-safety issues take precedence: both TEE_MemMove invocations use lengths and offsets derived from unvalidated parsed fields (attrs_size, pkcs11_ref.size) with insufficient checks, creating clear out-of-bounds read/write opportunities.",
        "Memory-safety issues take precedence: both lines perform reads/writes sized by untrusted parsed fields without sufficient validation, enabling out-of-bounds read or write; thus they are classified as vulnerable.",
        "Both target memmoves consume lengths derived from untrusted parsed headers without sufficient per-header bounds checks, producing clear out-of-bounds memory-safety risks.",
        "Memory-safety issues take priority: both lines perform memory moves driven by unvalidated lengths read from potentially REE-controlled buffers, producing high-confidence vulnerabilities."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0002",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 84,
      "consolidated": true,
      "detection_count": 3,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-20/CWE-125",
      "functions": [
        "_remove_attribute"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-20/CWE-125",
        "CWE‑120",
        "CWE-20",
        "CWE-125",
        "CWE-125/CWE-787",
        "CWE-125/CWE-119"
      ],
      "rule_ids": [
        "weak_input_validation",
        "shared_memory_overwrite",
        "other"
      ],
      "descriptions": [
        "Uses pkcs11_ref.size-derived next_off to compute in-place memmove length without validating next_off or ensuring bounds, allowing OOB memory operations.",
        "In-place memmove uses next_off derived from REE-influenced pkcs11_ref.size without independent bounds checks, enabling overwrite of REE-visible buffer.",
        "Moves tail data using length computed from untrusted next_off, enabling out-of-bounds or overlapping write into attrs buffer.",
        "In-place memmove using next_off computed from untrusted pkcs11_ref.size with no sufficient bounds/sanity checks.",
        "Shifts remaining attributes using next_off derived from unvalidated pkcs11_ref.size, enabling OOB move.",
        "In-place memmove with length computed from parsed next_off can underflow/overflow and corrupt memory.",
        "Memmoves remaining bytes based on next_off computed from untrusted header.size without validating bounds.",
        "Memmove length computed from pkcs11_ref.size without validating next_off against attrs_size, enabling out-of-bounds move"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_secret",
          "generate_random_key_value",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_rsa_keys",
          "tee2pkcs_rsa_attributes",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_rsa_keys",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_ec_keys",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_eddsa_keys",
          "remove_empty_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "modify_attributes_list",
          "set_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "modify_attributes_list",
          "set_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "add_missing_attribute_id",
          "set_attribute",
          "_remove_attribute",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "Caller-supplied attributes/template buffers (params -> template -> head) originating from REE-visible memrefs",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> entry_generate_secret @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c:289",
            "entry_generate_secret -> create_attributes_from_template / generate_random_key_value -> head @ processing.c:263-266,294",
            "head passed into _remove_attribute(head, ...) @ attributes.c:61-64",
            "_remove_attribute reads header fields from cur and uses pkcs11_ref.size to compute next_off and copy lengths @ attributes.c:75-76,84"
          ],
          "sink": "TEE_MemMove calls at lines 75 and 84 that use attacker-influenced lengths/offsets"
        },
        {
          "source": "Caller-supplied attribute templates/obj_attrs (originating from REE via params)",
          "propagation_path": [
            "params -> pub_template/priv_template @ processing.c:425-431",
            "pub_head/priv_head built from templates -> passed into generate_rsa_keys @ processing.c:519",
            "pub_head/priv_head -> tee2pkcs_rsa_attributes @ processing_rsa.c:761",
            "head (obj_attrs) -> _remove_attribute via remove_empty_attribute @ attributes.c:98/101",
            "cur/end computed from h->attrs_size and used in TEE_MemMove @ attributes.c:70-75,84"
          ],
          "sink": "TEE_MemMove calls at lines 75 (header read) and 84 (in-place shift) operating on REE-derived buffer regions"
        },
        {
          "source": "Attributes buffer (obj_attrs->attrs) ultimately derived from caller-provided templates (REE-visible)",
          "propagation_path": [
            "params (caller) -> templates -> pub_head/priv_head @ processing.c",
            "pub_head/priv_head -> attribute data placed in attrs buffer -> passed into _remove_attribute @ attributes.c:64",
            "cur (pointer into attrs buffer) -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:75",
            "pkcs11_ref.size -> next_off -> TEE_MemMove(cur, cur + next_off, ...) @ attributes.c:84"
          ],
          "sink": "TEE_MemMove calls at lines 75 and 84 that read sizes from untrusted memory and use them to compute copy offsets"
        },
        {
          "source": "Caller-provided obj_attrs blob (params templates originated from REE)",
          "propagation_path": [
            "params -> pub_template/priv_template (processing.c) @ processing.c:425-431",
            "pub_head/priv_head populated from templates -> passed into generate_ec_keys @ processing.c:516",
            "obj_attrs blob (h) used in _remove_attribute: h = *head @ attributes.c:64",
            "cur calculated from h and used as src in TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:75",
            "pkcs11_ref.size -> next_off -> used in TEE_MemMove(cur, cur + next_off, ...) @ attributes.c:84"
          ],
          "sink": "TEE_MemMove reads/writes driven by attacker-controlled sizes inside _remove_attribute"
        },
        {
          "source": "Caller-provided attribute buffer (params → serialargs → templates → obj_attrs->attrs blob)",
          "propagation_path": [
            "params (REE-origin) → serialargs / templates @ processing.c:415-431",
            "templates → pub_head/priv_head (TA structures) @ processing.c:448-472",
            "pub_head/priv_head -> *head passed into generate_eddsa_keys -> remove_empty_attribute -> _remove_attribute @ processing_ec.c:739 / attributes.c:61",
            "parsing loop reads pkcs11_ref from cur via TEE_MemMove @ attributes.c:75",
            "next_off derived from pkcs11_ref.size used in TEE_MemMove shift @ attributes.c:84"
          ],
          "sink": "TEE_MemMove calls at attributes.c:75 and attributes.c:84 that read/shift memory using unvalidated sizes"
        },
        {
          "source": "Caller-provided serialized attributes buffer (params->memref.buffer) parsed into template/head then propagated into obj_attrs->attrs memory",
          "propagation_path": [
            "params[0].memref.buffer -> serialargs_alloc_get_attributes -> template/head @ object.c:1002",
            "head->attrs_size used to set end and drive loop bounds @ attributes.c:70-71",
            "cur (within head) -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:75",
            "pkcs11_ref.size -> next_off -> TEE_MemMove(cur, cur + next_off, end - (cur + next_off)) @ attributes.c:76,84"
          ],
          "sink": "TEE_MemMove reads/writes using lengths derived from untrusted parsed sizes"
        },
        {
          "source": "Caller-provided serialized attributes (params->ctrl->memref.buffer) originating from REE",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> entry_copy_object @ entry.c:310",
            "entry_copy_object builds template/head from ctrl buffer -> modify_attributes_list @ object.c:1215",
            "modify_attributes_list iterates attribute stream and calls set_attribute -> _remove_attribute @ attributes.c:70-76",
            "_remove_attribute reads header from cur via TEE_MemMove @ attributes.c:75 and later memmoves data @ attributes.c:84"
          ],
          "sink": "TEE_MemMove operations that copy based on untrusted header.size and buffer lengths"
        },
        {
          "source": "Attributes blob (cur) originally rooted in templates/serialargs ultimately derived from params (REE-visible)",
          "propagation_path": [
            "params (REE) -> pub_template/priv_template (processing.c)",
            "template bytes -> obj_attrs->h->attrs (attributes.c): cur points into attrs (@ attributes.c:70)",
            "cur -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) (@ attributes.c:75)",
            "pkcs11_ref.size -> next_off -> TEE_MemMove(cur, cur+next_off, end-(cur+next_off)) (@ attributes.c:76,84)"
          ],
          "sink": "TEE_MemMove reads header and later shifts memory using lengths derived from unvalidated header fields"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls or influences attribute/template bytes supplied via REE-visible params",
            "attrs_size or attribute entries contain crafted sizes (pkcs11_ref.size) that violate expected bounds"
          ],
          "attack_scenario": "Maliciously crafted attribute list causes _remove_attribute to compute next_off or permit a cur position where sizeof(pkcs11_ref) exceeds remaining bytes, leading to OOB read at line 75 or an in-place memmove with malformed length at line 84, potentially corrupting heap metadata or leaking memory.",
          "impact": "Memory corruption (read/write) leading to crash, information leakage, or arbitrary code execution in TA context depending on allocator/heap layout."
        },
        {
          "preconditions": [
            "Attacker supplies malformed attribute list / attrs_size in params leading to h->attrs_size inconsistent with actual buffer",
            "TA does not perform independent validation of h->attrs_size or per-entry size fields"
          ],
          "attack_scenario": "Crafted attrs_size or pkcs11_ref.size cause the header read at line 75 to read past the buffer or next_off to be manipulated so the in-place memmove at line 84 copies/overwrites data out-of-bounds, potentially corrupting memory or leaking contents when later copied to REE.",
          "impact": "Memory corruption in TEE (denial-of-service via panic/abort or more severe integrity compromise); potential disclosure of adjacent memory if later copied to REE."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed attribute data supplied via REE-visible templates/params.",
            "No additional upstream validation ensuring pkcs11_ref.size and next_off keep operations within attrs buffer bounds."
          ],
          "attack_scenario": "Provide a crafted attribute header with pkcs11_ref.size that causes next_off to point beyond attrs buffer, triggering an over-read at line 75 or an out-of-bounds/overlapping memmove at line 84 to corrupt heap/adjacent metadata or cause crashes.",
          "impact": "Memory corruption within TA (out-of-bounds read/write), possible denial-of-service (panic/crash) or exploitation for code execution depending on allocator/state."
        },
        {
          "preconditions": [
            "Attacker supplies crafted obj_attrs blob via REE-visible params/templates",
            "attrs_size and embedded pkcs11_ref.size fields are crafted to violate invariants"
          ],
          "attack_scenario": "Maliciously crafted attribute list with manipulated attrs_size and pkcs11_ref.size causes _remove_attribute to compute next_off that leads TEE_MemMove to read/write out of bounds, leading to memory corruption inside the TA.",
          "impact": "Memory corruption in TA leading to crash, data corruption, or potential code execution within TA context; confidentiality/integrity of TA secrets may be compromised."
        },
        {
          "preconditions": [
            "Attacker supplies crafted attribute list via REE-side params leading to obj_attrs with manipulated attrs_size or pkcs11_ref.size",
            "TA code reaches remove_empty_attribute/_remove_attribute (e.g., generate_eddsa_keys path)"
          ],
          "attack_scenario": "Maliciously crafted attrs blob with truncated or oversized pkcs11_ref.size causes TEE_MemMove at line 75 to read beyond available buffer or at line 84 to move overlapping memory with incorrect length, leading to memory disclosure, corruption, or crash in the TA.",
          "impact": "Memory-safety violation (out-of-bounds read/write) enabling potential crash, information disclosure of TA memory, or corruption leading to further compromise of TA state."
        },
        {
          "preconditions": [
            "Attacker controls or crafts the serialized attributes buffer supplied in params memref",
            "TA does not further validate attrs_size or individual attribute sizes beyond current checks"
          ],
          "attack_scenario": "Maliciously crafted attrs_size or attribute size causes loop parsing to accept a header but with pkcs11_ref.size that causes subsequent memmove to copy out-of-bounds or with an underflowed length, leading to memory corruption or information disclosure.",
          "impact": "Memory corruption leading to crash or arbitrary write/reading of sensitive TA memory; potential escalation to data leakage or code execution depending on layout."
        },
        {
          "preconditions": [
            "Attacker-controlled serialized attributes blob supplied via REE to params",
            "No additional runtime integrity checks on attrs_size or individual header.size fields"
          ],
          "attack_scenario": "Craft attrs_size and/or per-attribute header.size so that sizeof(header) or next_off exceeds remaining bytes; trigger TEE_MemMove to read/write past buffer, causing crash or memory corruption.",
          "impact": "Memory corruption leading to denial-of-service, potential arbitrary code execution or disclosure of TA memory depending on layout and exploitation."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed attributes blob in REE-provided memref reaches h->attrs buffer",
            "No additional validation that ensures each attribute header and size fit inside h->attrs_size"
          ],
          "attack_scenario": "Crafted attributes cause pkcs11_ref.size to be large or inconsistent so TEE_MemMove reads/writes out-of-bounds, potentially enabling memory disclosure or corruption leading to control-flow hijack or data leak.",
          "impact": "Memory corruption or information disclosure within TA; possible panic, arbitrary code execution in TA context or leakage of TA-private data."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "attributes.c:75-76|84",
          "recommendation": "Validate that (end - cur) >= sizeof(pkcs11_attribute_head) before reading header; validate pkcs11_ref.size and next_off against h->attrs_size and minimum/maximum sensible limits before using in arithmetic or memmove."
        },
        {
          "type": "range_check",
          "location": "processing.c:191",
          "recommendation": "Validate value_len from template is within allowed maximum before TEE_Malloc to avoid excessively large allocations."
        },
        {
          "type": "bounds_check",
          "location": "_remove_attribute:70-76",
          "recommendation": "Verify end - cur >= sizeof(pkcs11_attribute_head) before copying header and validate pkcs11_ref.size against remaining bytes."
        },
        {
          "type": "range_check",
          "location": "_remove_attribute:76-84",
          "recommendation": "Ensure computed next_off is within [0, h->attrs_size] and that cur + next_off <= end before performing in-place memmove."
        },
        {
          "type": "type_validation",
          "location": "entry_generate_key_pair / parsing code:415-431",
          "recommendation": "Validate templates and attrs_size fields received from REE early and reject inconsistent sizes."
        },
        {
          "type": "bounds_check",
          "location": "attributes.c:75-84",
          "recommendation": "Validate that sizeof(pkcs11_ref) <= end - cur and that next_off = sizeof(pkcs11_ref)+pkcs11_ref.size does not exceed end - cur before using it to compute memmoves."
        },
        {
          "type": "range_check",
          "location": "attributes.c:76",
          "recommendation": "Sanity-check pkcs11_ref.size against a maximum allowed attribute size and ensure next_off > 0 and next_off <= (end - cur)."
        },
        {
          "type": "mem_access_check",
          "location": "attributes.c:84",
          "recommendation": "Use safe overlap-aware copy helper or explicitly handle overlapping regions and ensure source/destination ranges are within buffer."
        },
        {
          "type": "bounds_check",
          "location": "_remove_attribute:75-84",
          "recommendation": "Validate that cur + sizeof(pkcs11_ref) <= end before reading header; verify pkcs11_ref.size is sane and that cur + next_off <= end before any memmove."
        },
        {
          "type": "range_check",
          "location": "_remove_attribute:76-84",
          "recommendation": "Sanity-check next_off against h->attrs_size and non-zero/minimum bounds to prevent integer wrap or excessive lengths."
        },
        {
          "type": "bounds_check",
          "location": "attributes.c:72-76",
          "recommendation": "Before copying header, ensure (end - cur) >= sizeof(pkcs11_attribute_head); validate pkcs11_ref.size does not cause next_off to exceed remaining bytes."
        },
        {
          "type": "range_check",
          "location": "attributes.c:76-84",
          "recommendation": "Verify computed next_off is within [sizeof(pkcs11_ref), h->attrs_size] and that cur + next_off <= end before using it to compute move length."
        },
        {
          "type": "mem_access_check",
          "location": "attributes.c:84",
          "recommendation": "Use safe move semantics with explicit validated lengths and handle malformed inputs by returning an error instead of proceeding."
        },
        {
          "type": "bounds_check",
          "location": "modify_attributes_list/_remove_attribute:70-76",
          "recommendation": "Validate that (end - cur) >= sizeof(header) before reading header and that pkcs11_ref.size does not cause next_off to exceed (end - cur) and is within reasonable limits."
        },
        {
          "type": "range_check",
          "location": "modify_attributes_list/_remove_attribute:76-84",
          "recommendation": "Check next_off and end - (cur + next_off) for underflow/overflow before calling TEE_MemMove; reject malformed inputs."
        },
        {
          "type": "type_validation",
          "location": "entry_set_attribute_value:1002-1004",
          "recommendation": "Validate template->attrs_size and individual attribute sizes when parsing serialargs_alloc_get_attributes to ensure internal consistency."
        },
        {
          "type": "bounds_check",
          "location": "attributes.c:75-76",
          "recommendation": "Ensure end - cur >= sizeof(pkcs11_attribute_head) before copying header; validate header.size against remaining bytes"
        },
        {
          "type": "bounds_check",
          "location": "attributes.c:84",
          "recommendation": "Validate next_off and that (cur + next_off) <= end before memmoving; use safe helpers that check ranges"
        },
        {
          "type": "range_check",
          "location": "modify_attributes_list:215-222",
          "recommendation": "Sanitize head->attrs_size and guard loop iterations to avoid parsing beyond buffer"
        },
        {
          "type": "bounds_check",
          "location": "_remove_attribute:70-76",
          "recommendation": "Validate that end - cur >= sizeof(pkcs11_attribute_head) before reading header; validate pkcs11_ref.size and that sizeof(pkcs11_ref)+pkcs11_ref.size <= end - cur"
        },
        {
          "type": "range_check",
          "location": "_remove_attribute:76-84",
          "recommendation": "Ensure next_off is non-zero, within remaining attrs_size and does not cause underflow in end - (cur + next_off) before memmove"
        }
      ],
      "decision_rationales": [
        "Memory-safety issues are primary: attacker-controlled sizes are used without adequate bounds, enabling OOB reads/writes at the TEE_MemMove call sites; these are clear code-level weaknesses with direct data/control flow from REE-provided templates.",
        "Memory-safety issues take precedence: both header read and in-place shift use sizes derived from potentially REE-controlled fields without sufficient local bounds checks, enabling out-of-bounds read and shared-memory overwrite in REE-visible buffers.",
        "Memory-safety risk takes precedence: untrusted size is used to compute memmove offsets without adequate validation, producing clear potential for out-of-bounds read/write and memory corruption at the two examined sink lines.",
        "Memory-safety issue (untrusted length used to compute copy offsets) is present at both lines; this yields high-confidence out-of-bounds read/write potential and takes precedence over information-disclosure classifications.",
        "Memory-safety issues take precedence: both TEE_MemMove invocations use lengths and offsets derived from unvalidated parsed fields (attrs_size, pkcs11_ref.size) with insufficient checks, creating clear out-of-bounds read/write opportunities.",
        "Memory-safety issues take precedence: both lines perform reads/writes sized by untrusted parsed fields without sufficient validation, enabling out-of-bounds read or write; thus they are classified as vulnerable.",
        "Both target memmoves consume lengths derived from untrusted parsed headers without sufficient per-header bounds checks, producing clear out-of-bounds memory-safety risks.",
        "Memory-safety issues take priority: both lines perform memory moves driven by unvalidated lengths read from potentially REE-controlled buffers, producing high-confidence vulnerabilities."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0003",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 119,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125",
        "CWE-20",
        "CWE‑125",
        "CWE‑126"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Reads pkcs11_attribute_head from cur using TEE_MemMove without ensuring the full header fits before the end of attributes region.",
        "Header copied from 'cur' without ensuring full header fits within remaining attrs region; header.size then used unchecked.",
        "Reads header from cur using TEE_MemMove(sizeof(pkcs11_ref)) while only checking cur < end, allowing out-of-bounds read when remaining bytes < sizeof(pkcs11_ref).",
        "Reads header from serialized blob at 'cur' without verifying header fits within remaining attrs region; parsed size then used for pointer arithmetic.",
        "TEE_MemMove copies sizeof(pkcs11_ref) from cur before verifying cur + sizeof(pkcs11_ref) <= end, allowing out-of-bounds read of serialized attributes.",
        "Reads fixed-size pkcs11_attribute_head from cur without ensuring remaining buffer >= header size; pkcs11_ref.size then used without robust validation.",
        "Reads sizeof(pkcs11_ref) from cur without ensuring the full header fits within end (cur + sizeof(pkcs11_ref) not checked).",
        "Reads fixed-size header from cur without ensuring sizeof(pkcs11_ref) bytes remain in buffer (cur + sizeof(pkcs11_ref) <= end missing).",
        "Fixed-size copy from 'cur' performed without confirming enough remaining bytes; pkcs11_ref.size then used to advance loop, enabling over-read or malformed-length-driven behavior.",
        "Reads header from cur without ensuring remaining bytes >= sizeof(pkcs11_ref); parsed size then controls next_off and loop advancement.",
        "TEE_MemMove copies sizeof(pkcs11_ref) from cur without ensuring sufficient bytes remain in the serialized buffer (cur+sizeof(pkcs11_ref) may exceed end).",
        "Reads header from 'cur' without verifying that sizeof(header) bytes are available; subsequent use of header.size to compute next_off trusts unvalidated data.",
        "Header copy uses cur computed from head->attrs_size with insufficient bounds check (cur < end instead of cur+sizeof(header) <= end).",
        "Reads header via TEE_MemMove without ensuring remaining buffer length >= sizeof(pkcs11_ref).",
        "Header copied from cur without ensuring full header fits in remaining buffer, enabling out-of-bounds read.",
        "Copies header from cur without ensuring enough remaining bytes; pkcs11_ref.size then used to compute next_off, enabling out-of-bounds behavior on malformed input.",
        "TEE_MemMove reads sizeof(pkcs11_ref) from 'cur' without ensuring sufficient bytes remain (no pre-read bounds check).",
        "MemMove reads sizeof(pkcs11_ref) from cur without ensuring the header is fully inside head->attrs_size bounds.",
        "Copies pkcs11_attribute_head from cur without ensuring the full header lies within the serialized attribute buffer (end - cur >= sizeof(pkcs11_ref)).",
        "Copies header from cur without verifying the full header fits in remaining bytes; header.size then drives parser advancement.",
        "Reads pkcs11_attribute_head from cur using sizeof(pkcs11_ref) without ensuring remaining bytes are sufficient.",
        "Copies struct header from cur without verifying header fits within head->attrs_size; cur derived from untrusted head.",
        "TEE_MemMove reads sizeof(pkcs11_ref) from cur without ensuring that many bytes remain (cur derived from REE-provided head).",
        "Header copied from untrusted 'cur' without ensuring remaining buffer length >= sizeof(pkcs11_ref).",
        "Fixed-size read of pkcs11_ref from cur without verifying remaining bytes (end - cur) >= sizeof(pkcs11_ref).",
        "Reads header from cur without ensuring sizeof(pkcs11_ref) bytes remain, trusting parsed size later.",
        "Reads pkcs11_attribute_head from cur without ensuring the header fits within the remaining buffer; pkcs11_ref.size then used for arithmetic.",
        "Fixed-size copy of pkcs11_attribute_head from cur without ensuring enough remaining bytes; pkcs11_ref.size (untrusted) is then used for pointer arithmetic.",
        "Reads sizeof(pkcs11_ref) from cur without verifying sufficient remaining bytes in template (possible out-of-bounds read).",
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) can read beyond end when cur is near end and remaining bytes < sizeof(pkcs11_ref) due to untrusted head->attrs_size.",
        "Reads fixed-size attribute header from cur without ensuring remaining buffer length >= sizeof(header).",
        "Reads fixed-size header from 'cur' without ensuring header fits in remaining buffer; pkcs11_ref.size (from that header) then used to compute offsets.",
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) performed without explicit check that remaining bytes >= sizeof(pkcs11_ref).",
        "TEE_MemMove copies sizeof(pkcs11_ref) from cur without verifying cur+sizeof(pkcs11_ref) <= end; pkcs11_ref.size is attacker-influenced.",
        "Reads header from cur without pre-checking that the header fits within head->attrs_size; header.size then used to compute next_off.",
        "No explicit pre-copy bound check that (cur + sizeof(pkcs11_ref)) <= end; pkcs11_ref.size used later to compute offsets can be attacker-controlled leading to out-of-bounds read.",
        "TEE_MemMove reads sizeof(pkcs11_ref) bytes from cur without ensuring that many bytes remain in the buffer derived from head (REE-supplied).",
        "TEE_MemMove reads sizeof(pkcs11_ref) from cur without ensuring sufficient bytes remain in the buffer.",
        "TEE_MemMove reads sizeof(pkcs11_ref) from cur without verifying cur+sizeof(pkcs11_ref) <= end.",
        "TEE_MemMove reads pkcs11_ref and pkcs11_ref.size is used unchecked to compute next_off causing potential out-of-bounds advancement.",
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) executes without ensuring cur + sizeof(pkcs11_ref) <= end; pkcs11_ref.size later used to compute offsets, compounding risk.",
        "Reads pkcs11_attribute_head from cur without ensuring enough bytes remain in the attribute buffer, allowing out-of-bounds read.",
        "Reads sizeof(pkcs11_ref) from cur without ensuring sufficient remaining bytes, allowing OOB read.",
        "Read of fixed header from cur without confirming cur+sizeof(header) <= end; pkcs11_ref.size (untrusted) then used to compute next_off enabling overflow/panic.",
        "MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads fixed header size from cur without ensuring cur+sizeof(header) <= end; cur and pkcs11_ref.size originate from untrusted serialized data."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_wrap_key",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_secret",
          "check_created_attrs_against_token",
          "check_attrs_misc_integrity",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "check_created_attrs_against_token",
          "check_attrs_misc_integrity",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_create_object",
          "check_created_attrs_against_token",
          "check_attrs_misc_integrity",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "check_access_attrs_against_token",
          "object_is_private",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_wrap_key",
          "check_access_attrs_against_token",
          "object_is_private",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_create_object",
          "check_access_attrs_against_token",
          "object_is_private",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_destroy_object",
          "check_access_attrs_against_token",
          "object_is_private",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_get_attribute_value",
          "check_access_attrs_against_token",
          "object_is_private",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_get_object_size",
          "check_access_attrs_against_token",
          "object_is_private",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "check_access_attrs_against_token",
          "object_is_private",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "check_access_attrs_against_token",
          "object_is_private",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "object_is_token",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "object_is_copyable",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_secret",
          "check_created_attrs_against_token",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "check_created_attrs_against_token",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_create_object",
          "check_created_attrs_against_token",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_wrap_key",
          "check_parent_attrs_against_processing",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "check_attrs_against_modification",
          "attribute_is_modifiable",
          "attr_is_modifiable_secret_key",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "check_attrs_against_modification",
          "attribute_is_modifiable",
          "attr_is_modifiable_secret_key",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "check_attrs_against_modification",
          "attribute_is_modifiable",
          "attr_is_modifiable_private_key",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "check_attrs_against_modification",
          "attribute_is_modifiable",
          "attr_is_modifiable_private_key",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "check_attrs_against_modification",
          "attribute_is_modifiable",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "check_attrs_against_modification",
          "attribute_is_modifiable",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "check_attrs_against_modification",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "check_attrs_against_modification",
          "get_bool",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_secret",
          "check_created_attrs_against_processing",
          "check_attr_bval",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "check_created_attrs_against_processing",
          "check_attr_bval",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_get_attribute_value",
          "attribute_is_exportable",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "check_attrs_against_modification",
          "attribute_is_modifiable",
          "attr_is_modifiable_certificate",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "check_attrs_against_modification",
          "attribute_is_modifiable",
          "attr_is_modifiable_certificate",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_get_attribute_value",
          "get_attribute",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_wrap_key",
          "attributes_match_reference",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_secret",
          "generate_random_key_value",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_wrap_key",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_wrap_key",
          "check_parent_attrs_against_processing",
          "parent_key_complies_allowed_processings",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "check_attrs_against_modification",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "check_attrs_against_modification",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_wrap_key",
          "alloc_key_data_to_wrap",
          "alloc_copy_attribute_value",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_wrap_key",
          "alloc_key_data_to_wrap",
          "encode_rsa_private_key_der",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "add_missing_attribute_id",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_rsa_keys",
          "tee2pkcs_rsa_attributes",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_rsa_keys",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_ec_keys",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "generate_eddsa_keys",
          "get_attribute_ptr",
          "get_attribute_ptrs",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "Serialized attributes region pointed to by head (head->attrs region)",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> params (caller memrefs) @ entry.c:353",
            "entry_wrap_key: out_buf/params etc. -> key attributes read -> get_attribute_ptrs @ attributes.c:107-119 (cur derived from head)",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove reads sizeof(pkcs11_ref) from cur into local struct"
        },
        {
          "source": "Serialized attributes region reachable via caller-provided params (params -> ctrl->memref.buffer parsed into head/template).",
          "propagation_path": [
            "params[0/1/2] (REE-provided memrefs) -> serialargs parsing -> template/head creation @ processing.c:226-268",
            "head (serialized attrs) -> get_attribute_ptrs: cur = (char*)head + sizeof(struct obj_attrs) @ attributes.c:107",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove reads sizeof(pkcs11_ref) bytes from 'cur' which may be close to/ past end of attrs region"
        },
        {
          "source": "Serialized attributes blob (head->attrs_size and embedded pkcs11_ref fields) derived from caller-controlled data",
          "propagation_path": [
            "params (TEE_Param.memref.buffer) -> head (obj_attrs) @ processing.c:448-463",
            "head->attrs_size used to compute end and cur @ attributes.c:107-108",
            "cur (pointer into serialized blob) -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove reads header from cur without ensuring sizeof(pkcs11_ref) bytes remain"
        },
        {
          "source": "Serialized attributes blob originally derived from REE-provided template (params -> parsed into head)",
          "propagation_path": [
            "params (caller REE-visible) -> template parsed -> head (TA storage) @ ta/object.c:325-341",
            "head -> get_attribute_ptrs cur pointer into head's attrs region @ attributes.c:107-119",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from cur @ attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove reads header bytes from an attacker-influenced buffer into a local struct"
        },
        {
          "source": "Serialized attribute blob derived from REE-supplied templates (head->attrs region)",
          "propagation_path": [
            "params (REE) -> pub_template/priv_template (processing.c:448,461)",
            "pub_head/priv_head built from templates -> obj_attrs head passed into get_attribute_ptrs (attributes.c:158)",
            "cur pointer = (char*)head + sizeof(struct obj_attrs) (attributes.c:107)",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads from cur (attributes.c:119)"
          ],
          "sink": "TEE_MemMove reading fixed-size header from cur (attributes.c:119)"
        },
        {
          "source": "Serialized attributes buffer (head->attrs region) reachable from TA-managed object",
          "propagation_path": [
            "cur <- (char*)head + sizeof(struct obj_attrs) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header @ ...:119",
            "pkcs11_ref.size -> next_off used to advance cur and influence subsequent reads @ ...:120"
          ],
          "sink": "TEE_MemMove reading header from potentially undersized remaining buffer"
        },
        {
          "source": "Caller-provided serialized object buffer (e.g., params ctrl->memref.buffer / serialized template)",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> params (REE-visible) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c:206",
            "entry_create_object reads ctrl->memref.buffer into serialargs -> template @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:325-333",
            "template -> head passed into get_attribute_ptrs via get_attribute_ptr -> get_attribute_ptrs @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:158",
            "cur/end computed from head->attrs_size and then TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107-119"
          ],
          "sink": "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reading header from parsed buffer"
        },
        {
          "source": "serialized attribute buffer inside struct obj_attrs (head->attrs area) — content ultimately influenced when objects are created/initialized",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> params -> object creation paths (caller-supplied) @ entry points (various)",
            "object->attributes (obj metadata) read as head in get_attribute_ptrs @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107-119",
            "cur pointer derived from head + sizeof(struct obj_attrs) and used as source in TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119"
          ],
          "sink": "TEE_MemMove copying sizeof(pkcs11_ref) bytes from cur into stack-local pkcs11_ref"
        },
        {
          "source": "REE-provided serialized attribute blob (ctrl->memref.buffer) used to build 'template'",
          "propagation_path": [
            "params (TEE_Param memref) -> serialargs_alloc_get_attributes -> template (file: /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:777-779)",
            "template -> get_attribute_ptrs: cur = (char*)template + sizeof(header) (file: /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107)",
            "get_attribute_ptrs -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) (file: /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119) [sink]"
          ],
          "sink": "TEE_MemMove copying into local pkcs11_ref structure"
        },
        {
          "source": "Serialized attribute blob inside obj->attributes (parsed from TA-managed serialized object)",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> entry_get_object_size @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c:304",
            "entry_get_object_size -> pkcs11_handle2object -> obj->attributes (head) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:953",
            "get_attribute_ptrs: cur = (char *)head + sizeof(struct obj_attrs); end = cur + head->attrs_size @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107-108",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from cur @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119"
          ],
          "sink": "TEE_MemMove reading header from potentially short/tainted buffer at cur"
        },
        {
          "source": "Caller-provided serialized object buffer (params memref -> ctrl -> template / head->attrs_size)",
          "propagation_path": [
            "params->memref.buffer -> serialargs_alloc_get_attributes -> template (object.c:1002-1004)",
            "template->attrs_size -> head->attrs_size used to set end (attributes.c:107-108)",
            "head->attrs_size controls loop cur<end and cur arithmetic (attributes.c:115-121)",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads from cur (attributes.c:119)"
          ],
          "sink": "TEE_MemMove copying sizeof(pkcs11_ref) from cur into stack-local pkcs11_ref"
        },
        {
          "source": "Serialized attribute blob (head->attrs region) originating from caller-controlled params in earlier call chains",
          "propagation_path": [
            "params (caller REE-visible) -> ctrl->memref.buffer @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1108",
            "serialargs parsing -> template/attr buffers -> obj->attributes @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1118-1209",
            "get_attribute_ptrs reads from head region: cur = (char*)head + sizeof(struct obj_attrs) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from cur @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119"
          ],
          "sink": "TEE_MemMove reading header from serialized buffer into local pkcs11_ref"
        },
        {
          "source": "caller-provided serialized attributes buffer (params->memref.buffer parsed into head)",
          "propagation_path": [
            "params->memref.buffer -> ctrlargs/template (serialargs) @ object.c:992-1004",
            "template->attrs_size -> head->attrs_size used to set end @ attributes.c:107-108",
            "cur = (char*)head + sizeof(struct obj_attrs); cur used as src for MemMove @ attributes.c:119"
          ],
          "sink": "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) at attributes.c:119"
        },
        {
          "source": "caller-supplied serialized attribute list (head->attrs_size / cur derived from head)",
          "propagation_path": [
            "params (TEE_Param from REE) -> ctrl/ctrlargs -> template parsing @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1108-1118",
            "obj->attributes (TA-private) referenced and passed into get_attribute_ptrs via get_attribute_ptr -> get_attribute_ptr @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:176",
            "get_attribute_ptrs reads header: TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove reading sizeof(pkcs11_ref) bytes from cur which may be out-of-bounds"
        },
        {
          "source": "Serialized attributes buffer (head->attrs) potentially influenced by REE/caller",
          "propagation_path": [
            "head buffer -> cur (obj buffer pointer) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from cur @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119",
            "pkcs11_ref.size (attacker-controlled) used to compute next_off and advance cur @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:120"
          ],
          "sink": "TEE_MemMove into local pkcs11_ref reading from cur"
        },
        {
          "source": "Serialized attribute buffer length (head->attrs_size) potentially derived from upstream/REE-provided data",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> entry_generate_key_pair @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c:350",
            "entry_generate_key_pair -> create/deserialize templates and pass to attribute routines @ /workspace/.../ta/processing.c:448-472",
            "get_attribute_ptrs loop uses head->attrs_size to set end and iterates cur; cur used as src for memmove @ /workspace/.../ta/attributes.c:107-119",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ /workspace/.../ta/attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove reading header struct from serialized buffer (cur)"
        },
        {
          "source": "Serialized attributes buffer (from REE via params->memref.buffer parsed into head)",
          "propagation_path": [
            "params (TEE_Param memref) -> parsed template -> head (obj_attrs) @ ta/object.c:325-333",
            "head->attrs array cursor 'cur' computed from head @ ta/attributes.c:107-108",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from 'cur' @ ta/attributes.c:119"
          ],
          "sink": "TEE_MemMove into local pkcs11_ref at line 119"
        },
        {
          "source": "object attribute buffer 'head' (may be TA-private or attacker-controlled serialized payload in some call paths)",
          "propagation_path": [
            "head -> cur = (char*)head + sizeof(struct obj_attrs) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from cur @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119",
            "pkcs11_ref.size -> next_off = sizeof(pkcs11_ref) + pkcs11_ref.size (used to advance cur) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:120"
          ],
          "sink": "TEE_MemMove reading header at cur into local pkcs11_ref"
        },
        {
          "source": "caller-supplied params memref (params -> template/head) originating from REE",
          "propagation_path": [
            "params[0].memref.buffer -> template (entry_set_attribute_value) :/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1002-1004",
            "template -> head (create_attributes_from_template) :/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1047-1052",
            "head->attrs_size -> get_attribute_ptrs cur/end calculation :/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107-108",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) sink :/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119"
          ],
          "sink": "TEE_MemMove copying header from cur into stack-local pkcs11_ref"
        },
        {
          "source": "caller-provided serialized attributes buffer (head -> cur) derived from REE input",
          "propagation_path": [
            "head (params/template) -> cur set to (char*)head + sizeof(struct obj_attrs) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from cur @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119",
            "next_off = sizeof(pkcs11_ref) + pkcs11_ref.size uses unvalidated pkcs11_ref.size to advance cur @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:120"
          ],
          "sink": "TEE_MemMove copying header into local pkcs11_ref at get_attribute_ptrs:119"
        },
        {
          "source": "Caller-supplied serialised attributes buffer (params->memref.buffer → template → head)",
          "propagation_path": [
            "params[0].memref.buffer -> template (serialargs_alloc_get_attributes) @ object.c:1002",
            "template -> head (create_attributes_from_template) @ object.c:1047",
            "head -> get_attribute_ptrs cur/end setup @ attributes.c:107-108",
            "cur (from head) -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove reads sizeof(pkcs11_ref) bytes from cur into local pkcs11_ref"
        },
        {
          "source": "attributes buffer derived from caller serial args (REE-provided)",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> entry_copy_object @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c:310",
            "entry_copy_object parsed template/head from ctrl->memref.buffer @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1108-1118",
            "head passed into get_attribute_ptrs as 'head' @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:158",
            "get_attribute_ptrs reads header at cur and calls TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119"
          ],
          "sink": "TEE_MemMove copies header from potentially attacker-controlled buffer into local struct"
        },
        {
          "source": "caller-supplied serialized attributes buffer (params.memref -> head)",
          "propagation_path": [
            "params.memref.buffer -> template/head (entry_set_attribute_value): /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1002-1004",
            "head -> get_attribute_ptrs cur/end computation: /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107-108",
            "cur -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)): /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119"
          ],
          "sink": "TEE_MemMove reading header into local pkcs11_ref"
        },
        {
          "source": "caller-provided serialized attribute buffer (params/ctrl->memref.buffer ultimately from REE)",
          "propagation_path": [
            "TA_InvokeCommandEntryPoint -> entry_copy_object: ctrl = params (entry.c:308-310)",
            "entry_copy_object -> serialargs_alloc_get_attributes -> head (object.c:1108-1118,1163-1166)",
            "check_attrs_against_modification parses head into cli_ref via TEE_MemMove (pkcs11_attributes.c:2380)",
            "get_attribute_ptrs iterates cur over head and calls TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) (pkcs11_attributes.c:107-119) [sink]"
          ],
          "sink": "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reading from untrusted buffer"
        },
        {
          "source": "caller-provided attributes buffer (params memref -> template -> head) originating from REE",
          "propagation_path": [
            "params[0].memref.buffer -> template (entry_set_attribute_value):/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1002-1004",
            "template -> head (create_attributes_from_template / modify_attributes_list) : object.c:1047-1052",
            "head -> get_attribute_ptrs cur/end setup : attributes.c:107-108",
            "cur -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) : attributes.c:119"
          ],
          "sink": "TEE_MemMove reading sizeof(pkcs11_ref) from cur"
        },
        {
          "source": "caller-provided serialized attributes (head) originating from REE",
          "propagation_path": [
            "params (TA_InvokeCommandEntryPoint) -> ctrl.memref.buffer (entry_copy_object): /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c:308-310",
            "ctrlargs -> template/head constructed from template: /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1108-1118,1163-1166",
            "head passed into check_attrs_against_modification -> get_bool -> get_attribute -> get_attribute_ptr -> get_attribute_ptrs: /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c:1171 -> /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:239 -> 176 -> 158",
            "In get_attribute_ptrs: cur <- (char*)head+sizeof(obj_attrs); TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) at line 119 (sink)"
          ],
          "sink": "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) at get_attribute_ptrs:119"
        },
        {
          "source": "REE-provided serialized attributes buffer (params->memref.buffer parsed into head)",
          "propagation_path": [
            "params (caller) -> ctrl->memref.buffer used to build template/attrs @ processing.c:226-238",
            "template bytes -> head/@cur pointer parsed in get_attribute_ptrs @ attributes.c:107-120",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from untrusted cur @ attributes.c:119"
          ],
          "sink": "TEE_MemMove reading header from untrusted buffer @ attributes.c:119"
        },
        {
          "source": "Attributes blob originally derived from REE-supplied templates (params)",
          "propagation_path": [
            "params (REE) -> templates -> pub_head/priv_head (TEE-private) @ processing.c:450-468",
            "head (obj_attrs) -> get_attribute_ptrs cur/end computed from head->attrs_size @ attributes.c:107-108",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads untrusted bytes into local struct @ attributes.c:119"
          ],
          "sink": "TEE_MemMove copies header from blob into local pkcs11_ref and its size field is used for subsequent pointer/offset arithmetic"
        },
        {
          "source": "serialized template buffer derived from REE via serialargs_alloc_get_attributes",
          "propagation_path": [
            "params (REE) -> template (serialargs_alloc_get_attributes) @ object.c:777-779",
            "template -> cur/end pointers @ attributes.c:107-108",
            "cur (template region) read into pkcs11_ref via TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove reads header bytes from cur into local pkcs11_ref"
        },
        {
          "source": "caller-provided attributes buffer (params/serial template) originating from REE",
          "propagation_path": [
            "params[0].memref.buffer -> serialargs_alloc_get_attributes -> template (object.c:1002-1004)",
            "template -> create_attributes_from_template -> head (object.c:1047-1052)",
            "head (attrs) passed into get_attribute_ptrs via get_attribute_ptr -> get_attribute (attributes.c:158,176)",
            "cur = (char*)head + sizeof(struct obj_attrs); TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) (attributes.c:107-119)"
          ],
          "sink": "TEE_MemMove copies header bytes from cur into local pkcs11_ref without ensuring sizeof(header) fits in remaining buffer"
        },
        {
          "source": "caller-supplied serialized attributes buffer (head / cur) derived from REE-visible template/control buffer",
          "propagation_path": [
            "params (REE-visible) -> head (created from template) @ object.c:1163-1166",
            "head->attrs_size used to set parsing bounds -> cur = (char*)head + sizeof(struct obj_attrs) @ attributes.c:107-108",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from cur @ attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) at attributes.c:119"
        },
        {
          "source": "Template buffer derived (indirectly) from REE-provided params (ctrl->memref.buffer) and parsed into 'template'",
          "propagation_path": [
            "params (caller REE memref) -> serialargs_alloc_get_attributes allocates template @ object.c:777-779",
            "template -> get_attribute_ptrs reads from cur derived from template @ attributes.c:107-119",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header into local stack @ attributes.c:119"
          ],
          "sink": "TEE_MemMove reads header from template buffer into local stack (possible out-of-bounds read)"
        },
        {
          "source": "head->attrs (attribute list buffer) derived from TA object storage",
          "propagation_path": [
            "head->attrs_size used to compute end and cur start -> cur advances by next_off @ attributes.c:107-121",
            "cur (pointer into attribute bytes) -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove copying sizeof(pkcs11_ref) bytes into local struct"
        },
        {
          "source": "caller-provided serialized template bytes (params->memref.buffer) -> template -> attributes buffer (head->... )",
          "propagation_path": [
            "params[0/ctrl].memref.buffer -> serialargs (processing.c:226)",
            "serialargs_alloc_get_attributes -> template (processing.c:236-238)",
            "create_attributes_from_template -> head (processing.c:263-267)",
            "get_attribute_ptrs: cur = (char*)head + sizeof(obj_attrs) (attributes.c:107) -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) (attributes.c:119)"
          ],
          "sink": "TEE_MemMove into local pkcs11_ref at get_attribute_ptrs:119"
        },
        {
          "source": "head (object attributes buffer) originating from wrapping_key->attributes (TA object storage)",
          "propagation_path": [
            "head -> cur @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107",
            "cur -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119",
            "pkcs11_ref.size influences next_off and subsequent reads @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:120"
          ],
          "sink": "TEE_MemMove reading header from cur into local pkcs11_ref"
        },
        {
          "source": "attribute buffer (head->attrs_size, cur) potentially influenced by parsed object attributes",
          "propagation_path": [
            "head (wrapping_key->attributes) -> get_attribute_ptrs: cur = (char*)head + sizeof(struct obj_attrs) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119",
            "pkcs11_ref.size used to compute next_off -> loop arithmetic influences further reads @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:120"
          ],
          "sink": "TEE_MemMove at get_attribute_ptrs:119 reading header from cur into stack pkcs11_ref"
        },
        {
          "source": "params (caller-provided memref buffer) -> template -> head (attributes list) derived from REE",
          "propagation_path": [
            "params->memref.buffer -> serialargs_alloc_get_attributes -> template (/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1002-1004)",
            "template -> create_attributes_from_template -> head (/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1047-1052)",
            "head passed into check_attrs_against_modification/get_attribute_ptrs (/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1055 and attributes.c:107)",
            "cur = (char *)head + sizeof(struct obj_attrs); TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) (/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107-119)"
          ],
          "sink": "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reading header from possibly-short buffer"
        },
        {
          "source": "Caller-supplied attribute blob (params -> ctrl->memref.buffer) potentially from REE",
          "propagation_path": [
            "params (caller) -> ctrl (entry_copy_object) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1089-1090",
            "ctrl->memref.buffer -> serialargs_alloc_get_attributes -> template/head constructed : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1118-1163",
            "head passed to check_attrs_against_modification -> get_attribute_ptrs (head) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c:1171,2373,107",
            "get_attribute_ptrs uses cur/end derived from head->attrs_size and invokes TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119"
          ],
          "sink": "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reading from untrusted region without sufficient bounds check"
        },
        {
          "source": "object attributes storage (head->attrs area) — TA-private",
          "propagation_path": [
            "head -> cur computed as (char*)head + sizeof(struct obj_attrs) @ attributes.c:107",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads header from cur @ attributes.c:119",
            "pkcs11_ref.size used to advance next_off and to index into attribute payloads @ attributes.c:120-121",
            "returned pointer(s) from get_attribute_ptrs propagate to get_attribute_ptr -> alloc_copy_attribute_value -> alloc_key_data_to_wrap -> entry_wrap_key and later written to out_buf"
          ],
          "sink": "TEE_MemMove call at attributes.c:119 performing read from computed cur"
        },
        {
          "source": "object attribute storage (head + offset) containing pkcs11 attribute entries",
          "propagation_path": [
            "head.attrs storage -> cur pointer arithmetic @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:107-108",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:119",
            "next_off computed from pkcs11_ref.size and used to advance cur -> potential out-of-bounds loop iteration"
          ],
          "sink": "TEE_MemMove reading header and subsequent loop advancement leading to out-of-bounds memory access"
        },
        {
          "source": "caller-provided serialized object buffer (head->attrs) potentially originating from REE",
          "propagation_path": [
            "params (REE) -> pub_template/priv_template -> obj_attrs head (processing.c:448-462)",
            "head passed into get_attribute_ptrs(head, ...) (attributes.c:158)",
            "cur = (char*)head + sizeof(struct obj_attrs); cur used as src in TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) (attributes.c:107-119)"
          ],
          "sink": "TEE_MemMove reads sizeof(pkcs11_ref) bytes from cur into local pkcs11_ref (attributes.c:119)"
        },
        {
          "source": "Caller-provided serialized object buffer (params -> templates -> head->attrs buffer) originating from REE",
          "propagation_path": [
            "params (REE) -> pub_template/priv_template constructed in entry_generate_key_pair @ processing.c:425-431",
            "pub_head/priv_head (obj_attrs) populated from templates -> passed into generate_rsa_keys @ processing.c:519",
            "pub_head passed into get_attribute_ptrs via get_attribute_ptr -> get_attribute_ptrs(head, ...) @ attributes.c:156-158",
            "cur pointer computed from head and used as source for TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:119"
          ],
          "sink": "TEE_MemMove reads header bytes from cur into local pkcs11_ref without ensuring the header fits within head->attrs_size (out-of-bounds read)"
        },
        {
          "source": "Serialized object buffer (head->attrs region) likely derived from REE-controlled templates",
          "propagation_path": [
            "params (REE) -> pub_template / priv_template (processing.c:425-431,448-462)",
            "pub_head/priv_head created from templates -> get_attribute_ptrs called via get_attribute_ptr (attributes.c:158)",
            "get_attribute_ptrs parses buffer and calls TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) (attributes.c:119)"
          ],
          "sink": "TEE_MemMove reading header from cur (attributes.c:119)"
        },
        {
          "source": "REE-provided object template bytes (params -> pub_template/pub_head)",
          "propagation_path": [
            "params (REE) -> pub_template/pub_head @ processing.c:425-456",
            "pub_head (REE-derived) passed into generate_ec_keys -> get_attribute_ptrs via get_attribute_ptr @ processing_ec.c:614 / processing.c:516",
            "get_attribute_ptrs reads header at cur computed from head + sizeof(struct obj_attrs) and uses pkcs11_ref.size to compute next_off @ attributes.c:107-121",
            "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) reads from untrusted-controlled location @ attributes.c:119 (sink)"
          ],
          "sink": "TEE_MemMove reading into local pkcs11_ref from potentially out-of-bounds cur"
        },
        {
          "source": "params-derived serialized object buffer (REE-visible) passed through obj_attrs->head",
          "propagation_path": [
            "params (TEE_Param memref) -> head (obj_attrs) @ processing.c:394-396",
            "head->attrs_size used to set end; cur initialized from head @ attributes.c:107-108",
            "cur (untrusted pointer into serialized buffer) -> TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)) @ attributes.c:119"
          ],
          "sink": "TEE_MemMove copies header from potentially truncated/controlled cur location into TA stack"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker-controlled or corrupted head->attrs_size or serialized content such that cur points near end or pkcs11_ref.size is malformed",
            "Ability to supply or influence the serialized attributes blob stored in head"
          ],
          "attack_scenario": "Malformed or truncated serialized attribute blob causes TEE_MemMove to read beyond the intended buffer, leading to misparsed pkcs11_ref.size and control-flow anomalies (possible panic or logic corruption).",
          "impact": "Denial-of-service via TEE_Panic or incorrect control flow; potential memory disclosure or logic errors depending on surrounding code"
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed serialized attribute blob passed via REE-visible memref",
            "attrs_size value set such that cur < end but cur + sizeof(pkcs11_ref) > end (off-by-less-than-header)"
          ],
          "attack_scenario": "Maliciously crafted attribute data causes TEE_MemMove to read beyond the serialized buffer, leading to crash (TEE_Panic via subsequent check) or exposure of adjacent memory leading to information disclosure or logic corruption (next_off computed from attacker-controlled size).",
          "impact": "Denial of service (panic/crash) and potential memory disclosure or incorrect parsing leading to downstream privilege/control-flow issues."
        },
        {
          "preconditions": [
            "Attacker-controlled serialized attribute data supplied to the TA (e.g., via params memref).",
            "head->attrs_size is crafted so that cur < end but cur + sizeof(pkcs11_ref) > end (off-by-one or truncated blob)."
          ],
          "attack_scenario": "Supply a truncated or specially-crafted serialized attributes buffer so that the MemMove at line 119 reads beyond the buffer, causing out-of-bounds read leading to crash or disclosure of adjacent memory.",
          "impact": "Information disclosure or denial-of-service (panic/crash) depending on memory layout; possible corruption if downstream uses malformed sizes as lengths."
        },
        {
          "preconditions": [
            "Attacker controls or crafts serialized attribute blob supplied via params.",
            "No upstream normalization ensures serialized blob contains well-formed attribute headers and sizes."
          ],
          "attack_scenario": "A maliciously crafted serialized attributes blob places 'cur' near the end of the region or sets pkcs11_ref.size to a large/invalid value so TEE_MemMove reads past intended bounds, leading to out-of-bounds read and subsequent incorrect arithmetic causing loop corruption or crash (TEE_Panic) and potential memory disclosure depending on layout.",
          "impact": "Out-of-bounds read leading to denial-of-service (panic/crash) and potential disclosure of adjacent TA memory contents; may enable further logic corruption."
        },
        {
          "preconditions": [
            "Attacker supplies serialized attribute blob with manipulated attrs_size or truncated content via REE-origin templates.",
            "TA accepts and stores the blob into head without validating that it contains at least sizeof(pkcs11_ref) bytes at current cur."
          ],
          "attack_scenario": "An attacker provides a truncated or malformed serialized attributes buffer such that cur is near or beyond end; the TEE_MemMove at line 119 then reads past the buffer, leading to out-of-bounds read and potential crash or disclosure of adjacent TA memory.",
          "impact": "Information disclosure of TA memory or denial-of-service (panic) due to out-of-bounds read; possible further memory corruption depending on platform behavior."
        },
        {
          "preconditions": [
            "Malformed or truncated serialized attribute blob such that end - cur < sizeof(pkcs11_ref)",
            "Attacker-controlled or corrupted attribute content accessible to TA (e.g., via serialised input)"
          ],
          "attack_scenario": "Provide or trigger a serialized object whose attrs_size or content causes cur to point near end so that the fixed-size header read overruns the intended buffer, causing out-of-bounds read and/or miscomputed next_off leading to further memory corruption or panic.",
          "impact": "Out-of-bounds read (possible information leak) or corrupted loop state leading to TEE_Panic/denial-of-service or further memory-safety issues."
        },
        {
          "preconditions": [
            "Attacker controls or forges serialized object contents or attrs_size in head",
            "No prior validation ensuring cur + sizeof(pkcs11_ref) <= end"
          ],
          "attack_scenario": "A maliciously crafted serialized attributes blob sets attrs_size and internal offsets such that cur points near end, causing TEE_MemMove to read past end and trigger an out-of-bounds read (potentially causing panic or exposing adjacent memory).",
          "impact": "Out-of-bounds read may lead to information disclosure of adjacent TA memory or cause panic/denial-of-service; may aid further exploitation."
        },
        {
          "preconditions": [
            "A crafted or corrupted serialized attributes region where head->attrs_size or embedded pkcs11_ref.size cause cur + sizeof(pkcs11_ref) to exceed end",
            "Ability to influence the serialized object contents (e.g., during object creation or via REE-provided memrefs earlier in lifecycle)"
          ],
          "attack_scenario": "An attacker supplies or manipulates serialized attribute bytes such that the memmove reads past the declared attribute region, causing out-of-bounds read from adjacent memory or triggering TEE_Panic later; this may lead to information disclosure or denial-of-service.",
          "impact": "Out-of-bounds read leading to potential information disclosure of adjacent memory or panic/DoS of the TA."
        },
        {
          "preconditions": [
            "Attacker controls or crafts the serialized attributes provided in ctrl->memref.buffer",
            "template->attrs_size is set such that cur < end but cur + sizeof(pkcs11_ref) may exceed end"
          ],
          "attack_scenario": "Malformed serialized attribute data causes the code to read beyond the intended buffer when copying the attribute header; this can trigger incorrect next_off, loop misbehavior, or panic, leading to denial of service or possible memory-safety issues.",
          "impact": "Medium: denial-of-service via TEE_Panic or logic corruption; in low-probability scenarios could lead to memory corruption depending on allocator/layout."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed serialized attribute blob in obj->attributes such that end - cur < sizeof(pkcs11_ref)",
            "Ability to supply or influence object attributes (e.g., via prior API or crafted object data)"
          ],
          "attack_scenario": "Provide a serialized object with a truncated or malicious attribute region so that the TEE_MemMove at line 119 reads beyond the valid region, causing out-of-bounds read and subsequent next_off calculation to corrupt control flow/trigger TEE_Panic or undefined behavior.",
          "impact": "Denial-of-service via TEE_Panic or potential memory corruption leading to unexpected behavior; depending on platform internals, could escalate to higher integrity compromise."
        },
        {
          "preconditions": [
            "Attacker controls or forges head->attrs_size or the serialized attribute layout in the caller buffer",
            "Serialized buffer places cur near or beyond end so that cur+sizeof(pkcs11_ref) > end"
          ],
          "attack_scenario": "A maliciously crafted serialized attributes blob causes get_attribute_ptrs to copy beyond the intended buffer, leading to out-of-bounds read (and potentially crash via subsequent panic or use of malformed pkcs11_ref.size), enabling information leak or denial-of-service.",
          "impact": "Out-of-bounds read may disclose adjacent memory or trigger panic (TEE_Panic) leading to TA crash; could enable data leakage or denial-of-service."
        },
        {
          "preconditions": [
            "Attacker supplies or manipulates the serialized attribute blob (head->attrs) such that offsets/sizes are malformed",
            "TA processes that blob via the shown code path (e.g., caller provides params leading to head)"
          ],
          "attack_scenario": "Crafted attribute blob with manipulated pkcs11_attribute_head.size or truncated buffer causes TEE_MemMove at line 119 to read beyond the intended buffer, potentially causing memory corruption or crash (TEE_Panic) and leading to denial of service or info-leak via side effects.",
          "impact": "Out-of-bounds read and incorrect traversal leading to panic or further memory-safety issues; potential DoS and depending on context possible information exposure or corruption of TA memory."
        },
        {
          "preconditions": [
            "Attacker controls or supplies serialized attribute blob placed into head (through REE-provided memref).",
            "No stricter validation that cur+sizeof(pkcs11_ref) <= end before the copy."
          ],
          "attack_scenario": "A crafted attrs_size or malformed serialized stream causes cur to point near or beyond end so that copying sizeof(pkcs11_ref) reads beyond the intended buffer, causing out-of-bounds read and possible leak or panic.",
          "impact": "Out-of-bounds read can leak adjacent memory (information disclosure) or trigger a panic/crash (availability)."
        },
        {
          "preconditions": [
            "A crafted serialized attribute blob where head->attrs_size (or surrounding structure) causes cur to be within less than sizeof(pkcs11_ref) bytes from end",
            "Attacker controls or influences the serialized attributes stored/parsed into head"
          ],
          "attack_scenario": "Attacker supplies malformed attribute list such that cur points near buffer end; TEE_MemMove reads header bytes beyond buffer, causing out-of-bounds read and potential crash or information leakage.",
          "impact": "Memory-safety violation (out-of-bounds read) leading to potential denial-of-service (panic) or information disclosure depending on memory layout."
        },
        {
          "preconditions": [
            "Attacker can supply or influence the serialized object buffer (head->attrs) contents",
            "head->attrs_size is set such that cur < end but cur + sizeof(pkcs11_ref) may exceed end"
          ],
          "attack_scenario": "Crafted attribute stream where cur is near end and declared pkcs11_ref.size is large or manipulated such that reading sizeof(pkcs11_ref) at cur overruns the buffer, causing out-of-bounds read and potential panic or disclosure.",
          "impact": "Memory-safety violation (out-of-bounds read) leading to TEE_Panic or potential reading of out-of-bounds memory; denial-of-service and possible information leakage depending on memory layout."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed serialized attribute buffer placed into head (attrs_size inconsistent with actual data).",
            "Invocation path that leads to get_attribute_ptrs with that head (e.g., via entry_generate_key_pair deserialization)."
          ],
          "attack_scenario": "Provide a serialized object whose attrs_size is smaller than the remaining bytes but loop allows cur < end while cur+sizeof(header) > end; TEE_MemMove will read past buffer boundaries causing crash or memory disclosure.",
          "impact": "Denial of Service via panic/crash or potential memory disclosure/corruption depending on surrounding memory layout."
        },
        {
          "preconditions": [
            "Attacker supplies malformed serialized attributes in REE-visible memref passed to TA",
            "Parsed head->attrs_size is such that cur may be near end (or attacker crafts pkcs11_ref.size inconsistent with remaining buffer)"
          ],
          "attack_scenario": "An attacker-provided serialized attribute stream places 'cur' within a few bytes of 'end' so that the memmove of sizeof(pkcs11_ref) reads past the buffer, leading to out-of-bounds reads or causing pkcs11_ref.size to be attacker-controlled, which can then drive next_off and loop behavior (potential panic or further memory-safety issues).",
          "impact": "Memory-safety violation (out-of-bounds read) which can lead to crashes (TEE_Panic), logic corruption, or be leveraged for further exploitation depending on surrounding code."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed serialized attribute blob reachable as 'head' (e.g., via earlier TEE_MemMove from REE to local head).",
            "Crafted pkcs11_ref.size and placement such that cur is near end and sizeof(pkcs11_ref) bytes cross buffer boundary."
          ],
          "attack_scenario": "Provide a serialized attributes blob with manipulated sizes so that the MemMove reads beyond the intended buffer, causing out-of-bounds read or TEE_Panic, potentially crashing the TA or leaking memory.",
          "impact": "Information disclosure of adjacent memory or denial-of-service (panic/crash) in TA; extent depends on whether source originates from REE or TA-private buffers."
        },
        {
          "preconditions": [
            "Attacker supplies malformed serialized attributes in the memref buffer used as template/head",
            "head->attrs_size is small or crafted so that end - cur < sizeof(pkcs11_ref)"
          ],
          "attack_scenario": "Provide a template whose attrs_size or contents make cur point near or beyond end; when get_attribute_ptrs executes the loop it will TEE_MemMove sizeof(pkcs11_ref) from cur, causing out-of-bounds read or triggering TEE_Panic via later checks.",
          "impact": "Denial of service (TEE_Panic) or memory disclosure/undefined behavior depending on platform protections"
        },
        {
          "preconditions": [
            "Attacker supplies malformed/short serialized attributes in head (via REE-controlled template/control buffer).",
            "No upstream validation ensuring remaining bytes >= sizeof(pkcs11_ref) before the copy."
          ],
          "attack_scenario": "Provide a truncated or crafted serialized attribute blob so that cur + sizeof(pkcs11_ref) exceeds end, causing the TEE to read beyond the buffer (over-read) or populate pkcs11_ref.size with attacker-controlled value, leading to incorrect parsing and potential further out-of-bounds memory operations or a panic (denial of service).",
          "impact": "Out-of-bounds read leading to misbehavior, possible information leakage, or subsequent memory corruption/denial-of-service (TEE_Panic) depending on how pkcs11_ref.size is used."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed head.attrs_size and serialized data in params memref.",
            "cur positioned such that end - cur < sizeof(pkcs11_ref) yet loop condition cur < end holds (e.g., crafted sizes)."
          ],
          "attack_scenario": "Crafted serialised attribute buffer causes TEE_MemMove to read beyond buffer, potentially causing panic (TEE_Panic) or memory disclosure/crash depending on memory layout.",
          "impact": "Denial of service via panic/crash; potential information disclosure or memory-corruption depending on platform specifics."
        },
        {
          "preconditions": [
            "Attacker supplies a crafted serialized attributes buffer (head) via REE such that head->attrs_size is inconsistent with contained entries",
            "TA accepts the template and calls into code path reaching get_attribute_ptrs"
          ],
          "attack_scenario": "A malicious client supplies a truncated or specially crafted attributes blob where cur + sizeof(pkcs11_ref) exceeds end, causing TEE_MemMove to read beyond allocated buffer and potentially crash or leak memory.",
          "impact": "Out-of-bounds read leading to denial-of-service (TEE_Panic or crash) and possible information disclosure or control-flow compromise depending on environment."
        },
        {
          "preconditions": [
            "Attacker supplies a truncated or specially-crafted serialized attributes buffer in the REE-provided memref such that cur is near end and fewer than sizeof(pkcs11_ref) bytes remain",
            "No additional bounds validation performed before the memcpy"
          ],
          "attack_scenario": "A malicious client provides a malformed attributes blob that causes TEE_MemMove to read past the valid buffer, leading to out-of-bounds read and use of attacker-controlled pkcs11_ref.size to influence subsequent parsing and copies.",
          "impact": "Out-of-bounds read and subsequent incorrect parsing could lead to crashes (TEE_Panic), logic bypass, or memory disclosure depending on platform; denial of service is likely, confidentiality/integrity impact possible depending on downstream usage."
        },
        {
          "preconditions": [
            "A malformed or truncated serialized attribute list is supplied from REE (ctrl buffer).",
            "head->attrs_size is inconsistent with actual buffer length, or pkcs11_ref.size is crafted to manipulate next_off."
          ],
          "attack_scenario": "Attacker supplies a crafted serialized attributes blob where remaining bytes < sizeof(pkcs11_ref) at cur; TEE_MemMove will read past the valid buffer, causing out-of-bounds read or mis-parsing of attribute headers; this may lead to panic or logic corruption enabling further attacks.",
          "impact": "Information disclosure from adjacent memory, denial-of-service (TEE_Panic), or corrupted attribute handling leading to privilege/control-flow issues."
        },
        {
          "preconditions": [
            "Attacker-controlled REE supplies a malformed/truncated attributes buffer in params memref",
            "TA accepts and parses the buffer into head without sufficient size validation"
          ],
          "attack_scenario": "A malicious client supplies a truncated serialized attributes list such that end - cur < sizeof(pkcs11_ref); when the TA executes TEE_MemMove at line 119 it will read beyond the buffer, causing a crash or leakage of adjacent TA memory.",
          "impact": "Out-of-bounds read may lead to denial-of-service (TEE_Panic or crash) and potential disclosure of TA memory contents to attacker-controlled outputs downstream."
        },
        {
          "preconditions": [
            "Attacker supplies a crafted serialized attributes blob in ctrl.memref.buffer/head with a truncated tail such that end - cur < sizeof(pkcs11_ref) or malformed pkcs11_ref.size",
            "TA accepts and passes head into get_attribute_ptrs (no prior full validation)"
          ],
          "attack_scenario": "Attacker-controlled serialized object causes TEE_MemMove to read beyond the declared attribute buffer, potentially leaking adjacent TA memory or causing corrupted length used downstream (next_off) leading to further OOB accesses or TEE_Panic (DoS).",
          "impact": "Memory disclosure or corruption within TA memory and possible denial-of-service via TEE_Panic; could enable further out-of-bounds reads/writes depending on downstream use of pkcs11_ref.size."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed serialized attribute blob is supplied via REE memref.",
            "Serialized blob has length such that cur < end but cur+sizeof(pkcs11_ref) may exceed end (or header fields crafted)."
          ],
          "attack_scenario": "Crafted serialized attributes cause get_attribute_ptrs to read header beyond buffer or produce a large pkcs11_ref.size, enabling out-of-bounds reads/writes or TEE_Panic, potentially leading to denial-of-service or memory corruption.",
          "impact": "High: memory-safety violation (out-of-bounds read/write) can cause crash (TEE_Panic), information disclosure, or memory corruption depending on layout and follow-up uses."
        },
        {
          "preconditions": [
            "Attacker controls the serialized attributes blob provided via REE (params)",
            "No additional validation ensuring at least sizeof(pkcs11_attribute_head) bytes remain at cur"
          ],
          "attack_scenario": "Crafted blob with truncated final entry or malicious pkcs11_ref.size causes get_attribute_ptrs to read beyond allocated blob or compute an oversized next_off, leading to over-read, pointer aliasing of attacker-controlled memory, or panic (TEE_Panic).",
          "impact": "Memory-safety violation (out-of-bounds read) can cause undefined behavior, potential crash (availability), or leakage of adjacent memory contents (confidentiality)."
        },
        {
          "preconditions": [
            "Attacker controls or supplies serialized template data (via REE caller) that results in template->attrs_size smaller than expected",
            "No additional checks are performed to ensure sizeof(pkcs11_ref) bytes remain at cur"
          ],
          "attack_scenario": "Craft a serialized template where cur is near end so that TEE_MemMove reads beyond the allocated template, causing an out-of-bounds read and potential information disclosure or crash.",
          "impact": "Out-of-bounds read can disclose adjacent TA memory or cause a crash leading to denial of service; may enable further attacks depending on memory layout."
        },
        {
          "preconditions": [
            "Attacker-controlled REE input used to build the serialized attributes list (head->attrs_size) or crafted serial object where end - cur < sizeof(pkcs11_ref).",
            "Normal-world caller is able to pass the crafted params into the TA command that leads to processing of this attributes list."
          ],
          "attack_scenario": "A malicious REE client supplies a serialized attributes blob with truncated data so that when the TA reaches this loop, TEE_MemMove reads past the valid region, causing an out-of-bounds read (and potentially subsequent logic using corrupted header fields).",
          "impact": "Out-of-bounds read can lead to crashes (TEE_Panic), logic corruption (wrong sizes/IDs), or information disclosure of adjacent TA memory depending on downstream usage."
        },
        {
          "preconditions": [
            "Attacker (REE) supplies a crafted template/serialized attributes buffer with manipulated attrs_size or truncated tail",
            "TA reaches get_attribute_ptrs parsing that buffer"
          ],
          "attack_scenario": "Provide a serialized attributes block whose declared attrs_size or contained pkcs11_ref.size cause cur to point near the buffer end; the MemMove at line 119 then reads beyond the buffer, causing out-of-bounds memory access or crash (TEE_Panic path may be triggered later).",
          "impact": "Potential denial-of-service (panic/crash) and, depending on platform, information disclosure or memory-corruption consequences."
        },
        {
          "preconditions": [
            "Attacker controls the serialized attribute blob provided in params->memref.buffer",
            "No upstream normalization/truncation prevents malformed pkcs11_ref.size or placement near end"
          ],
          "attack_scenario": "Crafted template where 'cur' is near template end or contains an oversized pkcs11_ref.size causes TEE_MemMove to read past the template bounds, potentially leaking memory or causing undefined behavior leading to crash or code corruption.",
          "impact": "Out-of-bounds read can leak sensitive memory or trigger undefined behavior/crash; subsequent logic uses pkcs11_ref.size influencing loop increments, enabling further memory-corrupting conditions."
        },
        {
          "preconditions": [
            "Malformed or truncated attribute blob such that end - cur < sizeof(pkcs11_ref)",
            "An attacker-controlled or corrupted attribute buffer (req_attrs) is provided to the code path"
          ],
          "attack_scenario": "A crafted attribute blob with truncated header causes TEE_MemMove to read past the valid buffer, potentially leaking adjacent memory or causing panic/undefined behavior.",
          "impact": "Out-of-bounds read leading to memory disclosure or crash (denial of service); in some contexts could enable further memory corruption."
        },
        {
          "preconditions": [
            "Attacker-controlled template bytes placed into params->memref.buffer",
            "Malformed attributes such that cur is near end and fewer than sizeof(pkcs11_ref) bytes remain"
          ],
          "attack_scenario": "A crafted template causes get_attribute_ptrs to read past the end of the attributes buffer via TEE_MemMove, potentially leaking memory or causing panic/abnormal termination.",
          "impact": "Out-of-bounds read leading to information disclosure or TA crash (TEE_Panic elsewhere) depending on memory layout."
        },
        {
          "preconditions": [
            "An attacker-controlled or corrupted object attribute buffer (head) with crafted attrs_size/serialized entries",
            "No earlier validation that cur + sizeof(header) is within bounds"
          ],
          "attack_scenario": "A malformed serialized attributes blob causes TEE_MemMove to read beyond intended region or produce a large pkcs11_ref.size that later advances cur past end, leading to out-of-bounds reads/writes or a panic/denial-of-service.",
          "impact": "Memory-safety violation: out-of-bounds read/write, possible panic/DoS, or memory corruption leading to compromised integrity of TA processing."
        },
        {
          "preconditions": [
            "The attribute buffer length head->attrs_size is malformed or crafted so that cur is near end and remaining bytes < sizeof(pkcs11_ref).",
            "An attacker can influence the contents/size of the attribute buffer referenced by head (depending on object provenance)."
          ],
          "attack_scenario": "An attacker supplies or manipulates attribute storage such that the header copy reads beyond the buffer, causing an out-of-bounds read which may crash the TA or leak adjacent memory depending on runtime behavior.",
          "impact": "Memory-safety violation (out-of-bounds read) that can lead to denial-of-service (TEE_Panic or crash) and potential information disclosure of adjacent TA memory."
        },
        {
          "preconditions": [
            "Attacker controls or supplies a crafted params->memref.buffer that results in head->attrs_size smaller than sizeof(pkcs11_attribute_head)",
            "No earlier validation ensures sizeof(pkcs11_attribute_head) bytes are available at cur"
          ],
          "attack_scenario": "Malicious client supplies a truncated attributes blob; when the TA calls TEE_MemMove to read the attribute header, it reads past the end of the buffer causing an out-of-bounds read and potential crash or information disclosure.",
          "impact": "Memory-safety violation: out-of-bounds read that may lead to crash, data leakage, or undefined behavior exploitable further."
        },
        {
          "preconditions": [
            "Attacker supplies malformed/too-short serialized attribute blob in params/control memref",
            "head->attrs_size is under attacker control or inconsistent with actual buffer contents"
          ],
          "attack_scenario": "An attacker provides a crafted attribute list where head->attrs_size and embedded pkcs11_ref.size cause cur to point near the end such that TEE_MemMove reads past buffer end, causing out-of-bounds read and potential crash or data disclosure.",
          "impact": "Out-of-bounds read can cause TA crash (denial of service) and may leak adjacent memory contents to TA logic; if exploited in combination with other weaknesses, could lead to information disclosure or memory corruption."
        },
        {
          "preconditions": [
            "A crafted or corrupted object with inconsistent head->attrs_size or malformed attribute headers stored in TA-private storage is present",
            "No additional validation ensuring cur+sizeof(header) <= end before the MemMove at line 119"
          ],
          "attack_scenario": "Malformed or corrupted attrs_size or earlier metadata causes TEE_MemMove to read past the end of the attributes buffer, potentially leaking adjacent memory or causing crash/undefined behavior.",
          "impact": "Out-of-bounds read leading to information disclosure of adjacent TA memory, crash, or control-flow compromise depending on downstream use."
        },
        {
          "preconditions": [
            "A corrupted or malicious pkcs11 object attrs_size or pkcs11_ref.size present in object storage",
            "Attacker can influence or supply malformed object attribute data (e.g., via previously stored object)"
          ],
          "attack_scenario": "Crafted attribute blob with pkcs11_ref.size large or attrs_size inconsistent causes next_off to advance past end, leading to out-of-bounds reads or TEE_Panic (denial-of-service) or memory disclosure depending on subsequent code paths.",
          "impact": "Memory-safety violation: potential out-of-bounds read/advance leading to crash/DoS or reading unintended memory (information disclosure)."
        },
        {
          "preconditions": [
            "Attacker-controlled or malformed serialized object buffer provided to TA (head->attrs_size smaller than claimed)",
            "No validation ensuring space for header before copying"
          ],
          "attack_scenario": "Supply a crafted attrs blob where end - cur < sizeof(pkcs11_ref); TEE_MemMove will read past buffer bounds, potentially causing panic or memory disclosure/corruption depending on runtime behavior.",
          "impact": "Memory-safety violation: possible OOB read leading to crash (TEE_Panic) or disclosure of adjacent memory; could lead to denial-of-service or information disclosure."
        },
        {
          "preconditions": [
            "Attacker controls or can influence the serialized object buffer provided in params (REE-origin).",
            "head->attrs_size or embedded pkcs11_ref.size fields are crafted to make cur+sizeof(pkcs11_ref) exceed end or to manipulate loop arithmetic."
          ],
          "attack_scenario": "A malicious REE client supplies a crafted serialized attributes buffer that causes get_attribute_ptrs to read beyond the buffer via TEE_MemMove, leading to crash or disclosure of adjacent memory in the TEE process.",
          "impact": "Information disclosure of adjacent memory or denial-of-service (panic/crash) in the Trusted Application; possible corruption of control flow if exploited in combination with other flaws."
        },
        {
          "preconditions": [
            "Attacker supplies crafted serialized object/template such that head->attrs_size and internal offsets position cur near end",
            "No upstream validation prevents malformed attrs_size or internal sizes"
          ],
          "attack_scenario": "Attacker-controlled serialized attributes cause get_attribute_ptrs to MemMove past buffer end, leading to out-of-bounds read and potential crash or memory disclosure depending on surrounding memory layout.",
          "impact": "Information disclosure or denial-of-service (panic/crash); possible memory corruption depending on subsequent use of read data."
        },
        {
          "preconditions": [
            "Attacker can control the serialized object bytes supplied via params/templates",
            "Malformed pkcs11_ref.size such that next_off causes cur to point beyond end (or len insufficient) before the copy"
          ],
          "attack_scenario": "Provide a crafted attribute blob where pkcs11_ref.size is large or malformed so that TEE_MemMove reads beyond the intended buffer; this may trigger TA panic (TEE_Panic) or memory-corruption depending on environment.",
          "impact": "Denial of service via TA panic; potential memory-corruption leading to undefined behavior depending on platform (high severity)"
        },
        {
          "preconditions": [
            "A caller (REE) supplies a serialized object in params that makes head->attrs_size small or crafted",
            "Serialized data causes cur to point near or beyond end such that sizeof(pkcs11_ref) bytes are not fully available"
          ],
          "attack_scenario": "A malicious REE client crafts a serialized attributes blob where pkcs11_ref.size or attrs_size cause the loop to position cur close to end; the MemMove then reads beyond the buffer, causing out-of-bounds read or panic, potentially leaking memory or triggering OOB behavior.",
          "impact": "Out-of-bounds read leading to potential information disclosure or TA crash (TEE_Panic from subsequent check)."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Ensure cur + sizeof(pkcs11_ref) <= end before calling TEE_MemMove; validate pkcs11_ref.size against remaining bytes before using it to compute next_off."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size for reasonable limits (e.g., not larger than remaining attrs region) before adding to next_off to avoid integer overflow/misadvance."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Ensure cur + sizeof(pkcs11_ref) <= end before copying header; validate pkcs11_ref.size against remaining bytes to prevent overflow when computing next_off."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:119-121",
          "recommendation": "Validate header.size is within reasonable limits and that sizeof(pkcs11_ref)+header.size does not overflow size_t or exceed remaining buffer."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Ensure (cur + sizeof(pkcs11_ref)) <= end before calling TEE_MemMove; validate head->attrs_size and each pkcs11_ref.size against remaining buffer length."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size is reasonable (e.g., not causing next_off to wrap or exceed remaining bytes) before using it to compute next_off or expose pointers."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Validate that cur + sizeof(pkcs11_ref) <= end before calling TEE_MemMove; validate pkcs11_ref.size is within remaining bounds before using it to compute next_off."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Sanitize pkcs11_ref.size (e.g., upper bound) and reject attributes with sizes that would cause next_off to exceed remaining buffer."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145-148",
          "recommendation": "Avoid panic on parse errors where possible; return an error to caller instead of TEE_Panic to limit crash surface."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Ensure cur + sizeof(pkcs11_ref) <= end before calling TEE_MemMove; validate pkcs11_ref.size without relying on post-copy values."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:107-109",
          "recommendation": "Validate head->attrs_size and ensure serialized blob length matches expectations before parsing."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Verify (end - cur) >= sizeof(pkcs11_ref) before calling TEE_MemMove to read the header; validate pkcs11_ref.size against remaining buffer and enforce a sane maximum."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Sanity-check pkcs11_ref.size (e.g., against head->attrs_size and a maximum) before using it to compute next_off."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Ensure before each TEE_MemMove that (cur + sizeof(pkcs11_ref)) <= end and similarly validate next_off derived from pkcs11_ref.size does not cause overflow; reject malformed attrs_size."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size against remaining buffer and reasonable limits before using it to advance cur."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145-148",
          "recommendation": "Replace TEE_Panic with graceful error return when encountering malformed serialized input to avoid denial-of-service or uncontrolled termination paths."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Ensure cur + sizeof(pkcs11_ref) <= end before invoking TEE_MemMove; validate pkcs11_ref.size and reject entries that would cause next_off to exceed remaining buffer."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size against a reasonable maximum and that next_off does not wrap/overflow."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Ensure before TEE_MemMove that cur + sizeof(pkcs11_ref) <= end; validate pkcs11_ref.size against remaining bytes before using it to compute next_off."
        },
        {
          "type": "input_validation",
          "location": "serialargs_alloc_get_attributes:777-779",
          "recommendation": "Validate serialized attribute blob lengths and structure when parsing from REE-provided memref to ensure attrs_size and contained sizes are consistent."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Before TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)), verify (end - cur) >= sizeof(pkcs11_ref) and return an error if not."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size against remaining buffer bounds before computing next_off and advancing cur."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Validate that (cur + sizeof(pkcs11_ref)) <= end before performing TEE_MemMove; also validate pkcs11_ref.size against remaining bytes before using it to compute next_off."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:107-121",
          "recommendation": "Sanity-check head->attrs_size and ensure serialized entries are well-formed and non-negative before parsing."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145-148",
          "recommendation": "Avoid panicking after the out-of-bounds copy; instead return an error if parsing detects inconsistent lengths to prevent relying on post-copy panic."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Validate that cur + sizeof(pkcs11_ref) <= end before performing TEE_MemMove; validate pkcs11_ref.size against remaining bytes before using it to advance."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Sanitize pkcs11_ref.size (e.g., cap to remaining length) and refuse malformed serialized entries rather than panicking."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145-148",
          "recommendation": "Do not rely solely on final cur>end check and TEE_Panic; perform local checks before each read to avoid transient OOB access."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Ensure cur + sizeof(pkcs11_ref) <= end before reading header; validate pkcs11_ref.size against remaining bytes before using it to compute next_off."
        },
        {
          "type": "type_validation",
          "location": "parsing call-sites: object.c:992-1004",
          "recommendation": "Validate serialized template.attrs_size and individual attribute sizes when deserializing from REE-provided buffers."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Ensure (end - cur) >= sizeof(pkcs11_ref) before invoking TEE_MemMove; validate head->attrs_size and each next_off arithmetic to prevent overflow/underflow."
        },
        {
          "type": "range_check",
          "location": "prior to loop in get_attribute_ptrs",
          "recommendation": "Validate head->attrs_size against an expected maximum and verify header size fields (pkcs11_ref.size) do not cause next_off to wrap or exceed bounds."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119-121",
          "recommendation": "Ensure cur + sizeof(pkcs11_ref) <= end before copying header; validate pkcs11_ref.size against remaining bytes before using it to advance cur."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:119-121",
          "recommendation": "Validate header fields (id/size) are sensible and within expected ranges before trusting them."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145-148",
          "recommendation": "Return an error on malformed input instead of calling TEE_Panic."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Ensure (cur + sizeof(pkcs11_attribute_head)) <= end before calling TEE_MemMove and validate pkcs11_ref.size against remaining bytes."
        },
        {
          "type": "integrity_check",
          "location": "deserialization callers:430-447|unknown",
          "recommendation": "Validate serialized object header fields (attrs_size and individual attribute sizes) immediately after parsing the serialized header."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Verify (cur + sizeof(pkcs11_ref)) <= end before performing TEE_MemMove; validate pkcs11_ref.size against remaining bytes before using it to compute next_off."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Check pkcs11_ref.size for reasonable upper bounds (e.g., not exceeding remaining buffer or an application-defined maximum) before using it to advance cursor."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Ensure (cur + sizeof(pkcs11_ref)) <= end before calling TEE_MemMove, and validate pkcs11_ref.size against remaining buffer before advancing cur."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:119-121",
          "recommendation": "Sanitize pkcs11_ref.size (e.g., impose max reasonable attribute size) and reject malformed entries rather than trusting serialized sizes."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Verify (end - cur) >= sizeof(pkcs11_attribute_head) before calling TEE_MemMove; reject or truncate malformed entries."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Validate pkcs11_ref.size against remaining buffer and reasonable limits before using it to compute offsets."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Before TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)), ensure (cur + sizeof(pkcs11_ref)) <= end and that pkcs11_ref.size is validated such that (cur + next_off) <= end before advancing."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145",
          "recommendation": "Avoid panicking on malformed input; return an error to caller instead of TEE_Panic, to prevent DoS."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Verify (end - cur) >= sizeof(pkcs11_attribute_head) before reading the header; validate pkcs11_ref.size so next_off cannot wrap or exceed end."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Check pkcs11_ref.size for reasonable limits and for overflow when computing next_off = sizeof(...) + pkcs11_ref.size."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:130-138",
          "recommendation": "Ensure computed pointers (cur + sizeof(header)) are within [cur,end) before assigning into output arrays."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Validate that (cur + sizeof(pkcs11_ref)) <= end before calling TEE_MemMove, and ensure next_off computation is checked against remaining bytes."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Sanity-check pkcs11_ref.size values (e.g., max allowed) and ensure loop advance cannot overflow or exceed end."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Before TEE_MemMove(&pkcs11_ref,...), ensure (end - cur) >= sizeof(pkcs11_ref); validate pkcs11_ref.size such that sizeof(pkcs11_ref)+pkcs11_ref.size does not exceed remaining bytes."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:120-121",
          "recommendation": "Sanitize pkcs11_ref.size (reject sizes that are implausible or would overflow size_t), and handle malformed entries gracefully rather than continuing parsing or panicking."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Validate that (end - cur) >= sizeof(pkcs11_attribute_head) before calling TEE_MemMove; validate pkcs11_ref.size against remaining bytes before using it to compute next_off or pointers."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Validate that (end - cur) >= sizeof(pkcs11_ref) before calling TEE_MemMove; validate pkcs11_ref.size and next_off against remaining bytes."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120-121",
          "recommendation": "Ensure pkcs11_ref.size is sane (e.g., upper-bounded) before using it to compute next_off and before writing outputs."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145",
          "recommendation": "Replace TEE_Panic with graceful error handling and fail-safe returns for malformed REE input."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Validate that (end - cur) >= sizeof(pkcs11_attribute_head) before reading the header and ensure pkcs11_ref.size is validated against remaining bytes before computing next_off or writing pointers."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120-138",
          "recommendation": "Check pkcs11_ref.size for sane upper bounds and ensure cur + sizeof(pkcs11_ref) + pkcs11_ref.size <= end before using it."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145-148",
          "recommendation": "Avoid calling TEE_Panic on malformed input; return an error to callers instead to prevent DoS."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Ensure cur + sizeof(pkcs11_attribute_head) <= end before TEE_MemMove and validate pkcs11_ref.size against remaining bytes before using it in arithmetic."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size is within reasonable limits (e.g., not larger than end - (cur + sizeof(head))) before computing next_off or storing pointers."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:119-121",
          "recommendation": "Check header fields for plausibility (e.g., cumulative offsets) and fail safely instead of TEE_Panic on malformed input."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119-121",
          "recommendation": "Ensure (end - cur) >= sizeof(pkcs11_attribute_head) before copying; validate pkcs11_ref.size against remaining buffer and reject malformed entries."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size for reasonable upper bounds (and non-negative) before using in next_off arithmetic to prevent overflow or huge jumps."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Ensure (cur + sizeof(struct pkcs11_attribute_head)) <= end before calling TEE_MemMove; validate pkcs11_ref.size after safely reading header."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:120-121",
          "recommendation": "Validate pkcs11_ref.size is sane (e.g., not causing next_off to overflow) and that next_off does not advance beyond end."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Verify (end - cur) >= sizeof(pkcs11_ref) before calling TEE_MemMove, and validate sizeof(pkcs11_ref)+pkcs11_ref.size <= (end - cur) before using pkcs11_ref.size."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "After reading header, ensure pkcs11_ref.size is within acceptable limits (e.g., not excessively large) and that next_off does not overflow size_t."
        },
        {
          "type": "mem_access_check",
          "location": "higher:when parsing template",
          "recommendation": "Sanitize and validate the serialized template length and contents when created/decoded from REE memory to ensure internal consistency before iterating."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Verify (end - cur) >= sizeof(pkcs11_ref) before calling TEE_MemMove, and validate pkcs11_ref.size against remaining bytes before using it to compute next_off."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Ensure cur + sizeof(pkcs11_ref) <= end before reading header and validate pkcs11_ref.size against remaining bytes to prevent next_off overflow."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size is within reasonable limits (and within remaining buffer) before using it to compute next_off."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Before TEE_MemMove, verify (end - cur) >= sizeof(pkcs11_attribute_head) and after computing next_off verify (end - cur) >= next_off."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Validate that (cur + sizeof(pkcs11_ref)) <= end before calling TEE_MemMove; similarly validate next_off within remaining buffer and on loop entry."
        },
        {
          "type": "type_validation",
          "location": "upstream:processing.c:177-184",
          "recommendation": "Validate template-derived sizes (attrs_size and embedded pkcs11_ref.size) against reasonable maximums before parsing."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Verify (cur + sizeof(pkcs11_attribute_head)) <= end before calling TEE_MemMove and ensure pkcs11_ref.size is reasonable relative to remaining bytes."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size against remaining bytes and impose an upper bound to prevent next_off overflow/underflow."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Ensure (cur + sizeof(pkcs11_ref)) <= end before calling TEE_MemMove; validate pkcs11_ref.size does not make next_off exceed remaining buffer."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Sanitize pkcs11_ref.size after reading header and before using it to compute next_off; reject obviously invalid sizes."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Validate that (size_t)(end - cur) >= sizeof(pkcs11_attribute_head) before calling TEE_MemMove; similarly validate sizeof + pkcs11_ref.size <= end before using pkcs11_ref.size to advance."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Sanity-check pkcs11_ref.size for reasonable upper bounds and that sizeof(pkcs11_ref) + pkcs11_ref.size does not wrap/overflow."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Validate that (end - cur) >= sizeof(pkcs11_ref) before calling TEE_MemMove and verify pkcs11_ref.size fits within remaining bytes before using it to compute next_off."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Check that pkcs11_ref.size is a reasonable value (e.g., does not cause next_off to wrap or exceed end) before using it to advance cur."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145",
          "recommendation": "Avoid calling TEE_Panic; instead return an error when inconsistent lengths are detected earlier."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Validate that (cur + sizeof(pkcs11_ref)) <= end and that (cur + next_off) <= end before performing TEE_MemMove and advancing cur."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Replace blind TEE_MemMove with a guarded copy that checks remaining buffer length and returns an error if insufficient."
        },
        {
          "type": "type_validation",
          "location": "attributes parsing",
          "recommendation": "Sanity-check pkcs11_ref.size for reasonable limits (e.g., not exceeding attrs_size) before use."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:119-121",
          "recommendation": "Validate pkcs11_ref.size against remaining bytes (end - cur - sizeof(pkcs11_ref)) before using it to compute next_off; reject entries with inconsistent sizes."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Ensure loop increments cannot cause cur to exceed end and handle malformed sizes safely without looping or panic."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Validate that cur + sizeof(pkcs11_attribute_head) <= end before calling TEE_MemMove; similarly validate pkcs11_ref.size before using it to compute next_off and pointer targets."
        },
        {
          "type": "type_validation",
          "location": "callers that construct head:unknown",
          "recommendation": "Validate attrs_size provenance and enforce maximum reasonable size for serialized objects before parsing."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Ensure cur + sizeof(pkcs11_ref) <= end before calling TEE_MemMove; validate head->attrs_size and pkcs11_ref.size against remaining buffer space."
        },
        {
          "type": "type_validation|range_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Validate pkcs11_ref.size for reasonable limits and check for arithmetic overflows when computing next_off."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Ensure end - cur >= sizeof(pkcs11_attribute_head) before calling TEE_MemMove; validate next_off computed from pkcs11_ref.size does not cause wrap/overflow."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Validate pkcs11_ref.size against remaining buffer and impose sane limits to prevent large next_off values."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145-148",
          "recommendation": "Avoid relying on post-loop panic; perform pre-copy checks to prevent out-of-bounds reads."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:115-121",
          "recommendation": "Validate that cur + sizeof(pkcs11_ref) <= end before calling TEE_MemMove and validate pkcs11_ref.size to ensure next_off does not advance beyond end."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120",
          "recommendation": "Check pkcs11_ref.size for reasonable maximums and that sizeof(pkcs11_ref)+pkcs11_ref.size does not overflow or exceed remaining buffer."
        },
        {
          "type": "mem_access_check",
          "location": "get_attribute_ptrs:145-150",
          "recommendation": "Avoid panic on simple bounds violation; return an error instead of TEE_Panic to prevent DoS and allow callers to handle malformed input."
        },
        {
          "type": "bounds_check",
          "location": "get_attribute_ptrs:119",
          "recommendation": "Verify (cur + sizeof(pkcs11_ref)) <= end before invoking TEE_MemMove; validate pkcs11_ref.size before using to advance cur."
        },
        {
          "type": "range_check",
          "location": "get_attribute_ptrs:120-121",
          "recommendation": "Ensure next_off is non-zero and within a sane bound (e.g., does not exceed remaining bytes) before using it to advance the loop."
        }
      ],
      "decision_rationales": [
        "Memory-safety precedence: an unchecked TEE_MemMove reading a fixed struct from a serialized region without verifying full struct fits within bounds constitutes a weak-input-validation flaw (CWE-125); existing loop condition is insufficient.",
        "The immediate sink reads a fixed header size from a current pointer only guarded by cur < end; this canonical pattern allows an attacker-controlled serialized blob to position cur such that the fixed-size read overruns the buffer, and header.size is then trusted — this is a direct memory-safety weakness (weak input validation) with high confidence.",
        "Direct evidence of an out-of-bounds read: the code copies a fixed-size header from cur without verifying that the remaining buffer contains that header; attacker-controlled serialized sizes determine cur/end and pkcs11_ref.size.",
        "Memory-safety issue (out-of-bounds read/loop arithmetic using attacker-controlled size) takes precedence; insufficient local checks before copying header make TEE_MemMove at line 119 vulnerable.",
        "The copy reads a fixed number of bytes from an untrusted-derived buffer without pre-checking remaining length; this is a classic out-of-bounds read vulnerability (CWE-125) and memory-safety takes precedence.",
        "The call performs a fixed-size read guarded only by cur < end; there is no explicit check that the full header fits in the remaining bytes, and the header's size field is trusted to advance the pointer, enabling out-of-bounds read or miscomputed offsets. Memory-safety concerns take precedence.",
        "This is primarily a memory-safety issue (out-of-bounds read) because the code reads a header-sized chunk without ensuring the full header lies within the declared attrs_size; memory-safety rules take precedence and mark the line vulnerable.",
        "This is primarily a memory-safety issue (insufficient bounds validation before copying a fixed-size header), which can be triggered by malformed attribute data; that makes the line vulnerable even though destination is TA-local.",
        "Memory-safety weakness (insufficient bounds validation before fixed-size copy) precedes any information-disclosure concerns; given REE-derived input builds the source buffer, the copy at line 119 can read beyond the intended buffer and drive incorrect control flow or panic.",
        "This is primarily a memory-safety (out-of-bounds read/advance) issue: TEE_MemMove reads a fixed header size from a dynamically-sized serialized region without confirming remaining bytes, and the parsed size is then used to advance the cursor; insufficient input validation allows malformed data to drive unsafe memory operations.",
        "The copy reads a fixed-size header from a position that is only bounded by cur<end; absent an explicit pre-copy bounds check, this yields a clear out-of-bounds read risk (CWE-125) with high confidence.",
        "The TEE_MemMove at line 119 reads a fixed header size from a buffer whose traversal relies on a size field extracted from that same buffer; there is no immediate check that cur + sizeof(header) <= end before the read, so malformed or truncated serialized data can trigger an out-of-bounds read—this is a weak input validation / traversal vulnerability with medium confidence.",
        "Memory-safety precedence: evidence shows an out-of-bounds read possibility at the MemMove call because the code fails to check header-size fits within remaining buffer; this is a clear weak input validation leading to CWE-125.",
        "Memory-safety precedence: the TEE_MemMove at line 119 can read past end because the loop only ensures cur < end, not that sizeof(header) bytes remain; this is a clear bounds-validation omission and thus a vulnerable out-of-bounds read (CWE-125).",
        "The copy reads a fixed header size from a buffer with insufficient pre-checks (only cur < end), enabling out-of-bounds read when header lies close to end; this is a clear memory-safety defect (CWE-125).",
        "Memory-safety issue (insufficient validation of remaining bytes before fixed-size copy) is present and takes precedence; this is a clear weak-input-validation vulnerability that can trigger over-read/panic.",
        "The memmove at line 119 performs a fixed-size read from a cursor derived from attacker-controlled serialized data without verifying sufficient remaining bytes; this is a clear weak input validation leading to memory-safety issues, so the line is classified vulnerable.",
        "The copy reads a fixed-size header from a cursor derived from a buffer end computed from head->attrs_size but does not verify that the full header fits; this is a classic out-of-bounds read risk (CWE-125) enabling crash or data leakage.",
        "The memmove reads a fixed header size from a buffer region computed from untrusted attrs_size without confirming sufficient remaining bytes; this is a clear out-of-bounds read risk (CWE-125) and can lead to panic or memory corruption.",
        "The copy reads a fixed-size header from a cursor into which only a weak bound (cur < end) is tested; this permits an out-of-bounds read or attacker-controlled header.size that influences subsequent parsing, meeting the memory-safety failure criterion.",
        "Memory-safety precedence: the memcpy-like call reads a fixed header size from a pointer derived from untrusted serialized data without verifying the header fits, yielding an OOB read/panic; this is a clear weak input validation bug.",
        "Memory-safety issue (out-of-bounds read) is evident: copy length is fixed (sizeof header) while the check uses cur<end but does not ensure the full header fits, so attacker-controlled head can trigger unsafe read.",
        "Memory-safety precedence: the memmove reads a fixed header size from a pointer derived from untrusted serialized data without verifying sufficient remaining length; this is a clear out-of-bounds/read risk and thus classified as vulnerable under weak_input_validation.",
        "Memory-safety risk (out-of-bounds read/parse) is present because the code copies a fixed-size header from untrusted memory without ensuring enough remaining bytes; this precedes use of attacker-controlled size fields, so the line is classified vulnerable under weak_input_validation.",
        "Memory-safety risk (out-of-bounds read) is evident where a fixed-size copy is performed without ensuring sufficient remaining bytes; per priority rules memory-safety takes precedence, so classify as weak_input_validation leading to CWE-125.",
        "The memmove at line 119 reads a fixed header size from a cursor derived from an untrusted-length field; the loop predicate cur < end does not guarantee that sizeof(header) bytes are available, so a bounded-read/validation flaw exists (CWE-126) with high confidence.",
        "Memory-safety precedence: the code performs a fixed-size read from an untrusted buffer without verifying there is enough remaining bytes for that read; this creates an unequivocal out-of-bounds/robustness risk and is classified as weak input validation.",
        "The copy reads a fixed header from an untrusted blob without ensuring the header fits entirely in the remaining buffer; the header's size field then influences buffer traversal, thus meeting memory-safety vulnerability criteria.",
        "Memory-safety precedence: the call performs a fixed-size read from an untrusted/serialized buffer without ensuring adequate remaining bytes, which is a direct over-read risk (CWE-125).",
        "The copy at line 119 reads a fixed-size header from a cursor computed from an attributes buffer whose bounds are controlled by upstream REE-derived size; there is no check that sizeof(header) fits in remaining bytes before the copy, making an out-of-bounds read feasible (memory-safety first).",
        "The sink performs a fixed-size read from a cursor into a buffer whose remaining size is not validated for the header length; this is a classical out-of-bounds/weak-input-validation issue (CWE-125) with high-confidence evidence.",
        "A direct memmove reads a fixed-size header from a buffer whose remaining length is only compared with cur < end; absence of a pre-read bounds check for the header and use of attacker-controlled size to advance the loop yields a clear out-of-bounds/read vulnerability (CWE-125).",
        "Memory-safety precedence: insufficient validation of remaining bytes before copying a fixed-size header yields a clear out-of-bounds read risk at the call site; thus classified as vulnerable (weak_input_validation).",
        "Memory-safety precedence: fixed-size copy from a pointer into a buffer derived from untrusted input occurs without verifying available bytes, enabling out-of-bounds read; this is a clear weak input validation issue (CWE-125).",
        "Memory-safety issue (insufficient input validation) is present because the header is read before ensuring enough source bytes remain; this precedence (bounds) takes priority over information-disclosure concerns.",
        "The line performs a fixed-size copy from a buffer pointer 'cur' computed from head and advanced by header-driven sizes, but lacks an immediate pre-copy check that the full header fits within the remaining buffer. This is a direct memory-safety risk (out-of-bounds read) despite existing post-loop panic and other checks, so it is reported as vulnerable.",
        "The read at line 119 directly uses attacker-controllable buffer length to compute cur/end; cur<end alone does not guarantee sizeof(header) bytes are available, so this is a memory-safety flaw (out-of-bounds read) with high confidence.",
        "The code performs an unconditional read of a fixed-size header from a buffer region determined by attacker-influenced metadata without verifying sufficient remaining length; this is a classic out-of-bounds read (CWE-125) and the existing loop condition does not guarantee safety.",
        "The code performs a fixed-size read from a pointer derived from internal metadata without ensuring the full read fits within declared attrs_size. This is a classical out-of-bounds read risk (CWE-125) with strong evidence at the exact call site.",
        "The code copies a header from object memory then immediately trusts a length field from that header to advance parsing without validating it against remaining buffer bounds, creating a clear out-of-bounds read/iteration vector.",
        "Memory-safety precedence: evidence shows a fixed-size copy from a pointer derived from external buffer with insufficient pre-copy bounds checks, which is a clear OOB-read risk (CWE-125).",
        "The MemMove at line 119 reads a fixed header size from a pointer computed from a REE-supplied buffer without verifying the header fits within the buffer bounds; this is a clear out-of-bounds read risk (CWE-125) despite downstream checks.",
        "The code performs an unconditional fixed-size read from a pointer computed from head and head->attrs_size; the loop condition cur < end does not guarantee sizeof(pkcs11_ref) bytes are available, enabling out-of-bounds read (memory-safety issue) which takes precedence over information-disclosure classification.",
        "TEE_MemMove at line 119 reads a fixed header size from a pointer computed from attacker-controllable serialized data and then uses the read size to advance the pointer; no prior per-iteration bounds check ensures the copy is within the remaining buffer, leading to out-of-bounds read/panic; memory-safety risk takes precedence over information-disclosure.",
        "Memory-safety issue (out-of-bounds read) is present because a fixed-size copy is performed from an untrusted-derived pointer without verifying sufficient remaining source bytes; memory-safety precedence applied."
      ],
      "severity_distribution": {
        "medium": 1,
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0004",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 187,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-120",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "TEE_MemMove(attr, attr_ptr, size) can copy more bytes than destination 'attr' when attr_size is NULL or not validated against 'size'."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "check_attrs_against_modification",
          "attribute_is_modifiable",
          "attr_is_modifiable_certificate",
          "get_attribute",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "attr_ptr (derived from get_attribute_ptr(head, attribute) which may reference parsed attributes/head from REE-derived data)",
          "propagation_path": [
            "params (caller memref) -> template/head -> head passed into get_attribute_ptr @ object.c:1002/1047",
            "get_attribute_ptr results attr_ptr,size -> get_attribute copies via TEE_MemMove(attr, attr_ptr, size) @ attributes.c:187"
          ],
          "sink": "TEE_MemMove(attr, attr_ptr, size) copies into caller buffer 'attr' without guaranteed bounds when attr_size is NULL or inconsistent"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can control or craft object attribute data referenced by head/get_attribute_ptr such that reported size is larger than destination buffer or attr_size is NULL.",
            "Caller passes a non-NULL attr pointer without a matching attr_size or with attr_size < size but code path does not return early."
          ],
          "attack_scenario": "Maliciously crafted attributes cause get_attribute to copy more bytes than the destination buffer holds, leading to memory corruption inside the TA.",
          "impact": "Memory corruption in TA (crash, code execution, or data corruption), potential compromise of TA integrity."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "get_attribute:180-187",
          "recommendation": "Require caller to supply a valid attr_size and always validate dest buffer length against 'size' before calling TEE_MemMove; if attr_size is NULL, refuse or use a safe maximum."
        },
        {
          "type": "type_validation",
          "location": "get_attribute_ptr:unknown",
          "recommendation": "Ensure get_attribute_ptr validates that returned attr_ptr and size are consistent and within expected object bounds."
        },
        {
          "type": "mem_access_check",
          "location": "call sites of get_attribute:various",
          "recommendation": "Callers should initialize and provide attr_size reflecting the actual destination capacity or handle BUFFER_TOO_SMALL return code safely before using buffers."
        }
      ],
      "decision_rationales": [
        "The sink performs an unconditional copy of 'size' bytes when attr is non-NULL; although a bounds-check exists when attr_size is provided, callers may pass NULL attr_size or mismatched sizes making the check ineffective—this is a weak input validation that can lead to overflow/overread."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0005",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 220,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-20",
      "functions": [
        "modify_attributes_list"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-20",
        "CWE-125"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Copies sizeof(cli_head) from cur without verifying remaining bytes (end - cur) >= sizeof(cli_head); cli_head.size then used to compute len affecting loop bounds.",
        "TEE_MemMove(&cli_head, cur, sizeof(cli_head)) can read beyond available bytes because end computed from head->attrs_size is not checked to be >= sizeof(cli_head) before the copy."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "modify_attributes_list",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "modify_attributes_list",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "params[0].memref.buffer (caller REE-provided serialized attributes)",
          "propagation_path": [
            "params[0].memref.buffer -> serialargs_alloc_get_attributes -> template/head @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1002-1004",
            "head -> cur = (char*)head + sizeof(struct obj_attrs) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:210",
            "cur -> TEE_MemMove(&cli_head, cur, sizeof(cli_head)) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:220 (sink)"
          ],
          "sink": "TEE_MemMove(&cli_head, cur, sizeof(cli_head)) into local cli_head"
        },
        {
          "source": "params/ctrl memref provided by REE parsed into template/head via serialargs",
          "propagation_path": [
            "params (REE) -> ctrl->memref.buffer (entry_copy_object) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1108",
            "ctrl buffer -> template/head via serialargs_alloc_get_attributes : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1118",
            "head->attrs_size -> modify_attributes_list cur/end computation : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:210-211",
            "cur (from head) -> TEE_MemMove(&cli_head, cur, sizeof(cli_head)) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c:220"
          ],
          "sink": "TEE_MemMove(&cli_head, cur, sizeof(cli_head)) copies data from possibly-short buffer into stack"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker-controlled REE-side serialized attributes are passed in params memref",
            "head->attrs_size is small or malformed so that cur is near end and fewer than sizeof(cli_head) bytes remain",
            "No additional validation is performed on cli_head.size or remaining bytes"
          ],
          "attack_scenario": "A malicious caller crafts the serialized attributes such that cur points near the end of the buffer or contains a malformed cli_head.size; the TEE_MemMove then reads beyond the intended region or parses an inflated cli_head.size which can cause subsequent loop arithmetic to go out-of-bounds or trigger other logic errors.",
          "impact": "Potential memory-safety issues (out-of-bounds read) and downstream logic/control-flow corruption leading to crashes or further misuse of attacker-controlled lengths."
        },
        {
          "preconditions": [
            "Attacker supplies crafted params leading to a head with attrs_size smaller than sizeof(cli_head) or with malformed attribute headers",
            "No additional checks verifying remaining bytes before this TEE_MemMove"
          ],
          "attack_scenario": "A malicious REE client supplies a crafted attribute stream where head->attrs_size or remaining bytes are smaller than sizeof(cli_head), causing TEE_MemMove to read out-of-bounds and potentially crash or leak memory.",
          "impact": "Out-of-bounds read can cause crash or disclosure of TA memory; in some contexts may be leveraged for control-flow or information disclosure."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "modify_attributes_list:215-221",
          "recommendation": "Before copying sizeof(cli_head) from cur, verify (end - cur) >= sizeof(cli_head); after parsing cli_head.size, verify (end - cur) >= len and that len is within reasonable limits."
        },
        {
          "type": "range_check",
          "location": "modify_attributes_list:221",
          "recommendation": "Validate cli_head.size is within expected maximums to prevent integer overflow or excessive allocations/iterations."
        },
        {
          "type": "bounds_check",
          "location": "modify_attributes_list:220",
          "recommendation": "Verify (end - cur) >= sizeof(cli_head) before TEE_MemMove and validate cli_head.size against remaining bytes."
        },
        {
          "type": "range_check",
          "location": "entry_copy_object:1108-1122",
          "recommendation": "Ensure serialargs_alloc_get_attributes and creation of head enforce sane max attrs_size and validate template sizes before passing to modify_attributes_list."
        },
        {
          "type": "type_validation",
          "location": "modify_attributes_list:221-225",
          "recommendation": "Validate cli_head.size is within expected bounds before using it to advance the loop or allocate."
        }
      ],
      "decision_rationales": [
        "The copy reads a fixed-size header from a buffer whose remaining size isn't checked before the copy and then uses the parsed size to advance the pointer; this is a classic weak-input-validation leading to possible out-of-bounds reads and malformed length-driven loop behavior.",
        "Memory-safety weakness (insufficient bounds validation) at the memcpy-like call is present because the code copies a fixed header size from a parsed buffer without ensuring that many bytes remain; memory-safety is prioritized over information-disclosure classification."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0006",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 265,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "attributes_match_reference"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Unconditional TEE_MemMove of sizeof(pkcs11_ref) from ref_attr without verifying ref buffer has sufficient bytes"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_wrap_key",
          "attributes_match_reference",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "req_attrs/ref->attrs (attribute reference blob) originating from wrapping key attribute retrieval",
          "propagation_path": [
            "req_attrs -> ref (entry_wrap_key) @ processing.c:1248-1250",
            "ref->attrs -> ref_attr @ attributes.c:252",
            "TEE_MemMove(&pkcs11_ref, ref_attr, sizeof(pkcs11_ref)) @ attributes.c:265 (sink)"
          ],
          "sink": "TEE_MemMove reads fixed sizeof(pkcs11_ref) bytes from caller-provided ref_attr"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker-controlled or malformed req_attrs/ref->attrs blob with length smaller than expected",
            "No prior validation ensuring ref->attrs contains sizeof(pkcs11_ref) bytes at this offset"
          ],
          "attack_scenario": "A crafted wrapping template (req_attrs) with insufficient bytes causes TEE_MemMove to read past the provided buffer, leading to out-of-bounds read of TA memory which may crash the TA or leak adjacent memory via subsequent behavior.",
          "impact": "Information disclosure or denial-of-service (TA crash); possible further memory-corruption dependent on downstream use of read data."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "attributes_match_reference:265",
          "recommendation": "Validate that remaining bytes in ref (derived from ref->attrs_count/total length) >= sizeof(pkcs11_ref) before calling TEE_MemMove."
        },
        {
          "type": "range_check",
          "location": "attributes_match_reference:277",
          "recommendation": "On advancing ref_attr, ensure cumulative offset cannot exceed total ref->attrs buffer size."
        }
      ],
      "decision_rationales": [
        "Memory-safety issue: an unconditional fixed-size read from a caller-provided blob without verifying remaining bytes creates an out-of-bounds read (CWE-125); this takes precedence over information-disclosure classification."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0007",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 832,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "entry_get_attribute_value"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Reads sizeof(cli_head) from cli_ref without ensuring remaining src bytes >= sizeof(cli_head)."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_get_attribute_value",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided params -> parsed 'template' buffer",
          "propagation_path": [
            "params (REE) -> serialargs_alloc_get_attributes -> template (TA) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:767-779",
            "template contents read into cli_head via TEE_MemMove: object.c:832",
            "cli_head.size written back into template entries via TEE_MemMove: object.c:839/854/886",
            "template copied to out->memref.buffer via TEE_MemMove: object.c:910"
          ],
          "sink": "TEE_MemMove calls at lines [832,839,854,886,910] performing reads/writes based on unverified lengths"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker supplies malformed/short attribute template in REE params",
            "TA-side parsing trusts template->attrs_size or lacks per-copy bounds checks"
          ],
          "attack_scenario": "Malformed template causes TEE_MemMove to read/write beyond template bounds, leading to info leakage or memory corruption inside TA, potentially enabling crash or code execution depending on memory layout.",
          "impact": "Out-of-bounds read/write: information disclosure or TA memory corruption; may lead to denial-of-service or further exploitation."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: around loop before TEE_MemMove at line 832",
          "recommendation": "Ensure (end - cur) >= sizeof(cli_head) before copying; validate len and each per-field access against template->attrs_size."
        },
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: before TEE_MemMove at line 910",
          "recommendation": "Use min(out->memref.size, actual_template_size) or return BUFFER_TOO_SMALL instead of copying more than template size."
        },
        {
          "type": "type_validation",
          "location": "serialargs_alloc_get_attributes: after allocation",
          "recommendation": "Sanitize and canonicalize parsed template lengths and ensure allocations match declared sizes."
        }
      ],
      "decision_rationales": [
        "Memory-safety issues take precedence: several TEE_MemMove usages perform fixed-size copies into/from buffers whose remaining size at that exact program point is not proven, creating out-of-bounds read/write risks."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0008",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 839,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "entry_get_attribute_value"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Writes cli_head.size into cli_ref->size inside template without proving dst has space."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_get_attribute_value",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided params -> parsed 'template' buffer",
          "propagation_path": [
            "params (REE) -> serialargs_alloc_get_attributes -> template (TA) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:767-779",
            "template contents read into cli_head via TEE_MemMove: object.c:832",
            "cli_head.size written back into template entries via TEE_MemMove: object.c:839/854/886",
            "template copied to out->memref.buffer via TEE_MemMove: object.c:910"
          ],
          "sink": "TEE_MemMove calls at lines [832,839,854,886,910] performing reads/writes based on unverified lengths"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker supplies malformed/short attribute template in REE params",
            "TA-side parsing trusts template->attrs_size or lacks per-copy bounds checks"
          ],
          "attack_scenario": "Malformed template causes TEE_MemMove to read/write beyond template bounds, leading to info leakage or memory corruption inside TA, potentially enabling crash or code execution depending on memory layout.",
          "impact": "Out-of-bounds read/write: information disclosure or TA memory corruption; may lead to denial-of-service or further exploitation."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: around loop before TEE_MemMove at line 832",
          "recommendation": "Ensure (end - cur) >= sizeof(cli_head) before copying; validate len and each per-field access against template->attrs_size."
        },
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: before TEE_MemMove at line 910",
          "recommendation": "Use min(out->memref.size, actual_template_size) or return BUFFER_TOO_SMALL instead of copying more than template size."
        },
        {
          "type": "type_validation",
          "location": "serialargs_alloc_get_attributes: after allocation",
          "recommendation": "Sanitize and canonicalize parsed template lengths and ensure allocations match declared sizes."
        }
      ],
      "decision_rationales": [
        "Memory-safety issues take precedence: several TEE_MemMove usages perform fixed-size copies into/from buffers whose remaining size at that exact program point is not proven, creating out-of-bounds read/write risks."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0009",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 854,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "entry_get_attribute_value"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Writes cli_head.size into cli_ref->size inside template without proving dst has space."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_get_attribute_value",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided params -> parsed 'template' buffer",
          "propagation_path": [
            "params (REE) -> serialargs_alloc_get_attributes -> template (TA) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:767-779",
            "template contents read into cli_head via TEE_MemMove: object.c:832",
            "cli_head.size written back into template entries via TEE_MemMove: object.c:839/854/886",
            "template copied to out->memref.buffer via TEE_MemMove: object.c:910"
          ],
          "sink": "TEE_MemMove calls at lines [832,839,854,886,910] performing reads/writes based on unverified lengths"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker supplies malformed/short attribute template in REE params",
            "TA-side parsing trusts template->attrs_size or lacks per-copy bounds checks"
          ],
          "attack_scenario": "Malformed template causes TEE_MemMove to read/write beyond template bounds, leading to info leakage or memory corruption inside TA, potentially enabling crash or code execution depending on memory layout.",
          "impact": "Out-of-bounds read/write: information disclosure or TA memory corruption; may lead to denial-of-service or further exploitation."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: around loop before TEE_MemMove at line 832",
          "recommendation": "Ensure (end - cur) >= sizeof(cli_head) before copying; validate len and each per-field access against template->attrs_size."
        },
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: before TEE_MemMove at line 910",
          "recommendation": "Use min(out->memref.size, actual_template_size) or return BUFFER_TOO_SMALL instead of copying more than template size."
        },
        {
          "type": "type_validation",
          "location": "serialargs_alloc_get_attributes: after allocation",
          "recommendation": "Sanitize and canonicalize parsed template lengths and ensure allocations match declared sizes."
        }
      ],
      "decision_rationales": [
        "Memory-safety issues take precedence: several TEE_MemMove usages perform fixed-size copies into/from buffers whose remaining size at that exact program point is not proven, creating out-of-bounds read/write risks."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0010",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 886,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "entry_get_attribute_value"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Copies cli_head.size back into template slot; template bounds at this point are not re-checked."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_get_attribute_value",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided params -> parsed 'template' buffer",
          "propagation_path": [
            "params (REE) -> serialargs_alloc_get_attributes -> template (TA) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:767-779",
            "template contents read into cli_head via TEE_MemMove: object.c:832",
            "cli_head.size written back into template entries via TEE_MemMove: object.c:839/854/886",
            "template copied to out->memref.buffer via TEE_MemMove: object.c:910"
          ],
          "sink": "TEE_MemMove calls at lines [832,839,854,886,910] performing reads/writes based on unverified lengths"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker supplies malformed/short attribute template in REE params",
            "TA-side parsing trusts template->attrs_size or lacks per-copy bounds checks"
          ],
          "attack_scenario": "Malformed template causes TEE_MemMove to read/write beyond template bounds, leading to info leakage or memory corruption inside TA, potentially enabling crash or code execution depending on memory layout.",
          "impact": "Out-of-bounds read/write: information disclosure or TA memory corruption; may lead to denial-of-service or further exploitation."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: around loop before TEE_MemMove at line 832",
          "recommendation": "Ensure (end - cur) >= sizeof(cli_head) before copying; validate len and each per-field access against template->attrs_size."
        },
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: before TEE_MemMove at line 910",
          "recommendation": "Use min(out->memref.size, actual_template_size) or return BUFFER_TOO_SMALL instead of copying more than template size."
        },
        {
          "type": "type_validation",
          "location": "serialargs_alloc_get_attributes: after allocation",
          "recommendation": "Sanitize and canonicalize parsed template lengths and ensure allocations match declared sizes."
        }
      ],
      "decision_rationales": [
        "Memory-safety issues take precedence: several TEE_MemMove usages perform fixed-size copies into/from buffers whose remaining size at that exact program point is not proven, creating out-of-bounds read/write risks."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0011",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 910,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "entry_get_attribute_value"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Copies template into out->memref.buffer using out->memref.size without ensuring out->memref.size <= template actual size."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_get_attribute_value",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided params -> parsed 'template' buffer",
          "propagation_path": [
            "params (REE) -> serialargs_alloc_get_attributes -> template (TA) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:767-779",
            "template contents read into cli_head via TEE_MemMove: object.c:832",
            "cli_head.size written back into template entries via TEE_MemMove: object.c:839/854/886",
            "template copied to out->memref.buffer via TEE_MemMove: object.c:910"
          ],
          "sink": "TEE_MemMove calls at lines [832,839,854,886,910] performing reads/writes based on unverified lengths"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker supplies malformed/short attribute template in REE params",
            "TA-side parsing trusts template->attrs_size or lacks per-copy bounds checks"
          ],
          "attack_scenario": "Malformed template causes TEE_MemMove to read/write beyond template bounds, leading to info leakage or memory corruption inside TA, potentially enabling crash or code execution depending on memory layout.",
          "impact": "Out-of-bounds read/write: information disclosure or TA memory corruption; may lead to denial-of-service or further exploitation."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: around loop before TEE_MemMove at line 832",
          "recommendation": "Ensure (end - cur) >= sizeof(cli_head) before copying; validate len and each per-field access against template->attrs_size."
        },
        {
          "type": "bounds_check",
          "location": "entry_get_attribute_value: before TEE_MemMove at line 910",
          "recommendation": "Use min(out->memref.size, actual_template_size) or return BUFFER_TOO_SMALL instead of copying more than template size."
        },
        {
          "type": "type_validation",
          "location": "serialargs_alloc_get_attributes: after allocation",
          "recommendation": "Sanitize and canonicalize parsed template lengths and ensure allocations match declared sizes."
        }
      ],
      "decision_rationales": [
        "Memory-safety issues take precedence: several TEE_MemMove usages perform fixed-size copies into/from buffers whose remaining size at that exact program point is not proven, creating out-of-bounds read/write risks."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0012",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 395,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-119",
      "functions": [
        "unregister_persistent_object"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-119"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "TEE_MemMove copies count * sizeof(TEE_UUID) where count = ptr->count - idx; idx/count arithmetic may be inconsistent leading to out-of-bounds copy."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_ck_token_initialize",
          "unregister_persistent_object",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "token->db_objs (TA-managed persistent DB array of UUIDs)",
          "propagation_path": [
            "idx <- get_persistent_obj_idx(token, uuid) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c:365-366",
            "ptr allocated based on token->db_objs->count @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c:371-374",
            "ptr->count set and count = ptr->count - idx @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c:392-394",
            "TEE_MemMove(&ptr->uuids[idx], &token->db_objs->uuids[idx + 1], count * sizeof(TEE_UUID)) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c:395"
          ],
          "sink": "TEE_MemMove writing count * sizeof(TEE_UUID) bytes into &ptr->uuids[idx]"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "get_persistent_obj_idx returns an idx inconsistent with token->db_objs->count (e.g., logic bug or corrupted DB)",
            "ptr allocation succeeded but token->db_objs->count and idx arithmetic yields a large or negative count interpreted as large unsigned"
          ],
          "attack_scenario": "An attacker or corrupted persistent DB causes idx/count mismatch so that the computed copy length exceeds destination capacity, resulting in out-of-bounds write in TA memory, enabling memory corruption and potential control-flow/data corruption.",
          "impact": "Memory corruption within the TA (possible crash, data corruption, or code execution depending on layout)"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "unregister_persistent_object:395",
          "recommendation": "Explicitly validate that 0 <= idx < original_count and that count computed as (ptr->count - idx) is non-negative and fits destination before calling TEE_MemMove."
        },
        {
          "type": "mem_access_check",
          "location": "unregister_persistent_object:388-397",
          "recommendation": "Use safe copy helpers that check and cap lengths, or verify arithmetic using size_t and overflow checks prior to copy."
        }
      ],
      "decision_rationales": [
        "The memmove at line 395 uses a runtime-derived 'count' as the copy length with only indirect validation (idx from helper and earlier allocation). This reliance on upstream correctness without an explicit local bounds check creates a plausible out-of-bounds write condition, so classify as weak_input_validation vulnerability with medium confidence."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0013",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 563,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-20",
      "functions": [
        "update_persistent_object_attributes"
      ],
      "sink_functions": [
        "TEE_WriteObjectData"
      ],
      "vulnerability_types": [
        "CWE-20"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "size computed from obj->attributes->attrs_size is used unchecked as write length to persistent storage"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "update_persistent_object_attributes",
          "TEE_WriteObjectData"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "caller-provided template data consumed via serialargs -> template -> obj->attributes",
          "propagation_path": [
            "params[i].memref.buffer -> template (serialargs_alloc_get_attributes) @ object.c:1002",
            "template->attrs_size -> template_size @ object.c:1040",
            "template-derived attributes moved into obj->attributes -> obj passed to update_persistent_object_attributes @ object.c:1068",
            "obj->attributes->attrs_size -> size computed @ persistent_token.c:561",
            "TEE_WriteObjectData(hdl, obj->attributes, size) @ persistent_token.c:563"
          ],
          "sink": "TEE_WriteObjectData writes TA memory to persistent storage using attacker-influenced size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "attacker supplies crafted template in params memref to set attrs_size to an oversized value",
            "TA accepts template and creates/assigns obj->attributes without enforcing a strict upper bound"
          ],
          "attack_scenario": "A malicious client supplies a template with a large attrs_size causing TEE_WriteObjectData to read beyond the valid obj->attributes buffer, possibly causing memory disclosure, crash, or corruption of persistent storage content.",
          "impact": "Memory corruption, potential disclosure of adjacent TA memory during write, persistent storage corruption, denial-of-service"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "persistent_token.c:561",
          "recommendation": "Validate obj->attributes->attrs_size against an upper bound and ensure obj->attributes buffer length >= computed size before calling TEE_WriteObjectData"
        },
        {
          "type": "type_validation",
          "location": "object.c:1002-1040",
          "recommendation": "Validate template->attrs_size when allocating and copying attributes; reject or clamp unreasonable sizes"
        },
        {
          "type": "mem_access_check",
          "location": "persistent_token.c:563",
          "recommendation": "Ensure the source buffer is fully allocated and accessible for 'size' bytes prior to write"
        }
      ],
      "decision_rationales": [
        "Direct use of a size derived from upstream (potentially REE-controlled) attribute length without a validating bounds check before TEE_WriteObjectData constitutes weak input validation and a memory-safety risk; destination is TEE persistent storage (not REE), so information-disclosure promotion does not apply."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0014",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 567,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-20",
      "functions": [
        "update_persistent_object_attributes"
      ],
      "sink_functions": [
        "TEE_TruncateObjectData"
      ],
      "vulnerability_types": [
        "CWE-20"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "size computed from obj->attributes->attrs_size (sourced from caller template) is used to truncate persistent object without validation."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "update_persistent_object_attributes",
          "TEE_TruncateObjectData"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "caller-provided params memref buffer -> template (serialargs_alloc_get_attributes)",
          "propagation_path": [
            "params->memref.buffer -> template (serialargs_alloc_get_attributes) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:992-1004",
            "template->attrs_size -> template_size = sizeof(*template) + template->attrs_size @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1040",
            "obj->attributes->attrs_size -> size = sizeof(struct obj_attrs) + obj->attributes->attrs_size @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c:561",
            "TEE_TruncateObjectData(hdl, size) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c:567"
          ],
          "sink": "TEE_TruncateObjectData called with attacker-influenced size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "attacker controls or forges params memref content used by serialargs_alloc_get_attributes",
            "the object is token-backed so update_persistent_object_attributes is invoked"
          ],
          "attack_scenario": "An attacker supplies a crafted template that results in a manipulated attrs_size; when persisted, the TA truncates persistent object data to that attacker-controlled size, causing data loss/corruption or inconsistent state.",
          "impact": "Persistent object corruption or denial of service for token-stored objects; potential downstream logical errors"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "update_persistent_object_attributes:561-567",
          "recommendation": "Validate template->attrs_size and resultant size against expected maxima and current object size before writing or truncating persistent storage."
        },
        {
          "type": "type_validation",
          "location": "entry_set_attribute_value:1002-1040",
          "recommendation": "Ensure serialargs_alloc_get_attributes validates lengths and limits for attrs_size and template contents before creating attributes."
        },
        {
          "type": "access_control",
          "location": "entry_set_attribute_value:1018-1023",
          "recommendation": "Re-verify privileges and input provenance when modifying token-backed objects; fail-safe on unexpected sizes."
        }
      ],
      "decision_rationales": [
        "Tainted length/size derived from caller data reaches a critical filesystem/persistent-object truncation API without validation; this meets memory-safety / weak input validation criteria and is plausibly exploitable."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0015",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2380,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "check_attrs_against_modification"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Reads sizeof(cli_ref) from cur (derived from REE head) without proving the header fits inside end; cli_ref.size then used to compute len enabling further OOB.",
        "TEE_MemMove reads sizeof(cli_ref) from 'cur' without verifying remaining bytes, enabling out-of-bounds read of attacker-controlled buffer."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_set_attribute_value",
          "check_attrs_against_modification",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "check_attrs_against_modification",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "params memref.buffer (REE-visible) → template → head (attrs list)",
          "propagation_path": [
            "params[0].memref.buffer -> template (serialargs_alloc_get_attributes) @ ta/object.c:1002",
            "template -> head (create_attributes_from_template) @ ta/object.c:1047",
            "head -> cur/end computed (cur = head + sizeof(obj_attrs); end = cur + head->attrs_size) @ ta/pkcs11_attributes.c:2373-2374",
            "TEE_MemMove(&cli_ref, cur, sizeof(cli_ref)) reads from cur @ ta/pkcs11_attributes.c:2380"
          ],
          "sink": "TEE_MemMove reading header at cur into local cli_ref"
        },
        {
          "source": "Caller-provided attributes buffer (params -> ctrl->memref.buffer)",
          "propagation_path": [
            "params -> ctrl (entry_copy_object) : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1089-1090",
            "ctrl->memref.buffer -> serialargs -> template/head construction : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1108-1118,1163",
            "head (attrs) -> cur/end calculation : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c:2373-2374",
            "TEE_MemMove(&cli_ref, cur, sizeof(cli_ref)) reads from cur : /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c:2380"
          ],
          "sink": "TEE_MemMove(&cli_ref, cur, sizeof(cli_ref))"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker-controlled REE input provides head->attrs_size and attribute data such that end - cur < sizeof(cli_ref) or crafted cli_ref.size leads to len arithmetic overflow"
          ],
          "attack_scenario": "Maliciously crafted attributes in caller-supplied memref cause TEE_MemMove to read beyond buffer or create incorrect len, leading to out-of-bounds read and potential memory corruption or info disclosure.",
          "impact": "Out-of-bounds read (and subsequent use of tainted sizes) may cause sensitive TA memory disclosure or control-flow/data corruption."
        },
        {
          "preconditions": [
            "Attacker supplies malformed/short attributes buffer via params.ctrl->memref.buffer",
            "head->attrs_size is set such that cur < end but remaining bytes < sizeof(cli_ref)"
          ],
          "attack_scenario": "A crafted params buffer causes the loop to attempt TEE_MemMove of sizeof(cli_ref) from a short src region, leading to read of out-of-range memory and potential crash or information disclosure.",
          "impact": "Out-of-bounds read from untrusted memory may cause TA crash, leak adjacent TA memory, or enable further corruption/exploitation depending on platform behavior."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "check_attrs_against_modification:2380",
          "recommendation": "Verify (size_t)(end - cur) >= sizeof(cli_ref) before TEE_MemMove and validate that sizeof(cli_ref)+cli_ref.size does not overflow and stays within end."
        },
        {
          "type": "range_check",
          "location": "check_attrs_against_modification:2381",
          "recommendation": "After reading cli_ref, validate cli_ref.size against a maximal allowed attribute size and ensure len computation cannot overflow."
        },
        {
          "type": "bounds_check",
          "location": "check_attrs_against_modification:2376-2381",
          "recommendation": "Before TEE_MemMove(&cli_ref, cur, sizeof(cli_ref)), ensure (end - cur) >= sizeof(cli_ref); validate cli_ref.size against remaining bytes before using it to advance cur."
        },
        {
          "type": "type_validation",
          "location": "entry_copy_object:1108-1120",
          "recommendation": "Validate templates/attrs_size parsed from serialargs to ensure internal consistency and prevent crafted sizes from misleading loop bounds."
        }
      ],
      "decision_rationales": [
        "Memory-safety concern: a read of sizeof(cli_ref) is performed from a cursor derived from untrusted head->attrs_size without an explicit bounds check ensuring the header fits; this yields a clear out-of-bounds/len-arithmetic risk.",
        "Memory-safety precedence: the TEE_MemMove reads a fixed header from a cursor into a caller-supplied buffer without confirming the remaining buffer length, enabling out-of-bounds read (CWE-125); this is a definite vulnerability despite the loop bound."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0016",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 488,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "entry_ck_token_mecha_ids"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "TEE_MemMove copies out->memref.size bytes where out->memref.size is derived from REE and may exceed the actual allocated source buffer (array)."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_ck_token_mecha_ids",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided params[2].memref.size and params[2].memref.buffer (out)",
          "propagation_path": [
            "params -> out = params + 2 @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c:445-446",
            "count <- out->memref.size / sizeof(*array) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c:470",
            "array <- tee_malloc_mechanism_list(&count) (allocation influenced by count) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c:471",
            "TEE_MemMove(out->memref.buffer, array, out->memref.size) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c:488"
          ],
          "sink": "TEE_MemMove copying out->memref.size bytes into REE-visible out->memref.buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[2].memref.size and provides a REE buffer",
            "tee_malloc_mechanism_list may allocate fewer bytes than implied by out->memref.size-derived count (or integer division/truncation causes mismatch)"
          ],
          "attack_scenario": "Malformed out->memref.size leads code to compute count and allocate an 'array' smaller than out->memref.size; TEE_MemMove then reads past 'array' causing TA memory disclosure or crash.",
          "impact": "Out-of-bounds read of TA memory (information disclosure) or crash/denial-of-service."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "entry_ck_token_mecha_ids:470-488",
          "recommendation": "Validate that allocated array size (count*sizeof(*array)) is >= out->memref.size before calling TEE_MemMove; handle mismatch without proceeding to copy."
        },
        {
          "type": "range_check",
          "location": "entry_ck_token_mecha_ids:471",
          "recommendation": "Sanitize and clamp count derived from out->memref.size to reasonable maximums and check for integer overflows before allocation."
        }
      ],
      "decision_rationales": [
        "The copy length is attacker-controlled and upstream logic can produce a mismatch between the allocated src size and the requested copy length; sanitization is present but relies on interactions with allocation behavior (unknown), so a weakness in input validation remains."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0017",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 34,
      "consolidated": true,
      "detection_count": 1,
      "severity": "medium",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-20",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-20"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "TEE_MemMove(out, src, size) copies potentially attacker-controlled 'size' bytes from REE-derived src into TA memory without local validation.",
        "Copies 'size' bytes from REE-derived src into out without an explicit bounds check of out's capacity at the memmove site.",
        "Copies 'size' bytes from src (REE-controlled serialized args) into out (&session_handle) without validating the decoded handle's provenance or bounds.",
        "Copies REE-controlled bytes into session_handle (TA-private) without validating the parsed value's legitimacy for the client."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "serialargs_alloc_get_attributes",
          "serialargs_get",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "serialargs_alloc_get_attributes",
          "serialargs_get",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_ck_login",
          "serialargs_get_session_from_handle",
          "serialargs_get",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "serialargs_get_session_from_handle",
          "serialargs_get",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided serialargs buffer (params->memref.buffer from TA entry)",
          "propagation_path": [
            "params (REE-visible) -> ctrlargs (serialargs) @ processing.c:415",
            "serialargs_get_ptr reads src from args->next (REE-derived) -> serialargs_get @ serializer.c:32",
            "TEE_MemMove(out, src, size) copies size bytes into TA memory @ serializer.c:34"
          ],
          "sink": "TEE_MemMove copying 'size' bytes from REE-derived src into TA memory"
        },
        {
          "source": "REE-provided serialargs buffer (ctrl->memref.buffer)",
          "propagation_path": [
            "ctrl->memref.buffer -> ctrlargs (object.c:1108)",
            "serialargs_get_ptr reads src from args->next -> serialargs_get (serializer.c:32)",
            "TEE_MemMove(out, src, size) copies size bytes into out (serializer.c:34)"
          ],
          "sink": "TEE_MemMove(out, src, size) in serialargs_get (serializer.c:34)"
        },
        {
          "source": "caller-provided TEE_Param.memref.buffer (REE-visible serialized args)",
          "propagation_path": [
            "params[0].memref.buffer -> ctrlargs (serialargs_init) @ ta/pkcs11_token.c:1414",
            "serialargs_get_ptr(&ctrlargs, &src, size) -> src points into REE buffer @ ta/serializer.c:32-33",
            "TEE_MemMove(out, src, size) copies into out (&session_handle) @ ta/serializer.c:34",
            "session_handle used in pkcs11_handle2session(session_handle, client) @ ta/serializer.c:167 (caller)"
          ],
          "sink": "TEE_MemMove at serializer.c:34 (copy into local session_handle)"
        },
        {
          "source": "REE-provided params ctrl->memref.buffer",
          "propagation_path": [
            "ctrl->memref.buffer -> ctrlargs (serialargs_init) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1108",
            "serialargs_get_ptr(&ctrlargs, &src, size) -> src (pointer into ctrl buffer) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c:32",
            "TEE_MemMove(out, src, size) copies REE bytes into caller-local session_handle (out) @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c:34",
            "pkcs11_handle2session(session_handle, client) uses session_handle to resolve session @ /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c:167 and /workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c:1108-1111"
          ],
          "sink": "TEE_MemMove(out, src, size) writing attacker-controlled bytes into session_handle"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls the REE-side serialargs buffer contents/length",
            "serialargs_get_ptr returns a src pointer and size is attacker-influenced or mismatched"
          ],
          "attack_scenario": "Maliciously crafted serialargs cause serialargs_get_ptr/serialargs_get to produce a src pointer or size that leads TEE_MemMove to copy out-of-bounds data into TA memory, leading to memory corruption or information exposure.",
          "impact": "Memory corruption in TA (crash or code execution) or reading unintended memory, depending on allocation/state."
        },
        {
          "preconditions": [
            "Attacker controls or crafts REE-side serialized args buffer content",
            "A caller invokes serialargs_get with a size that leads to copying more bytes than the destination out can safely hold (or serialargs_get_ptr returns a src within REE buffer but size not validated against out capacity)"
          ],
          "attack_scenario": "Malicious REE-supplied serialized data causes serialargs_get to copy excessive bytes into TA memory, potentially causing memory corruption or information disclosure depending on out buffer usage.",
          "impact": "Memory corruption within the TA (possible crash or code execution) or reading unintended data into TA structures."
        },
        {
          "preconditions": [
            "Attacker controls serialized args sent in params[0] memref buffer",
            "serialargs_get_ptr succeeds for requested size"
          ],
          "attack_scenario": "Attacker supplies a crafted session_handle value via serialized args; TA copies it into session_handle without validating its provenance, causing pkcs11_handle2session to be called with attacker-controlled handle, potentially mapping to unintended session or causing logic confusion.",
          "impact": "Incorrect session lookup or unauthorized session influence (logic/authorization bypass), depending on pkcs11_handle2session behavior."
        },
        {
          "preconditions": [
            "Attacker supplies crafted ctrl->memref.buffer (REE caller)",
            "No higher-level validation of session_handle value before use"
          ],
          "attack_scenario": "Malicious REE client crafts ctrl buffer so session_handle resolves to another session or causes session lookup to fail/return unexpected session, influencing subsequent object access/authorization.",
          "impact": "Potential unauthorized session resolution or denial of service via invalid session handle; could lead to unauthorized access checks or session confusion."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "serialargs_get:34",
          "recommendation": "Validate that src points to at least 'size' readable bytes and that 'out' has capacity >= size before TEE_MemMove; verify serialargs_get_ptr enforces these invariants."
        },
        {
          "type": "type_validation",
          "location": "callers of serialargs_get (processing.c:136,163)",
          "recommendation": "Ensure callers pass expected 'size' consistent with the serialized object's declared length and check return codes."
        },
        {
          "type": "bounds_check",
          "location": "serialargs_get:34",
          "recommendation": "Validate that 'size' does not exceed the actual capacity of 'out' before calling TEE_MemMove; ensure serialargs_get_ptr provides a length-limited view and that callers pass correct, validated sizes."
        },
        {
          "type": "type_validation",
          "location": "alloc_and_get:140",
          "recommendation": "Validate attr.attrs_size against a sane maximum before allocating and copying to prevent oversized allocations or copies."
        },
        {
          "type": "type_validation",
          "location": "serialargs_get:34",
          "recommendation": "Validate that the decoded session_handle is within expected range and bound to the client (e.g., check ownership/validity) before using it."
        },
        {
          "type": "range_check",
          "location": "serialargs_get_session_from_handle:163-169",
          "recommendation": "Ensure session_handle semantics/authority are verified and not accepted blindly from serialized input."
        },
        {
          "type": "type_validation",
          "location": "serialargs_get:32-34",
          "recommendation": "Validate parsed session_handle value against expected bounds and client context before assigning; ensure it maps to a legitimate session for this client."
        },
        {
          "type": "access_control",
          "location": "pkcs11_handle2session:167-169",
          "recommendation": "Enforce additional checks that session belongs to the client and is in an expected state before returning it to caller."
        }
      ],
      "decision_rationales": [
        "The copy reads from REE-derived memory into TA memory using a caller-supplied size without visible, sufficient validation at this program point, creating a realistic memory-safety risk (weak input validation).",
        "Although some callers pass fixed safe sizes, serialargs_get itself performs a raw memmove of 'size' bytes from a source derived from REE without validating the destination capacity at this program point; this is a generic weak-input-validation memory-safety issue warranting reporting.",
        "The line performs a direct copy of attacker-controlled bytes into a TA-internal integer used for session lookup; size/bounds are checked but semantic validation is missing, enabling weak-input-validation attack paths.",
        "Untrusted REE bytes are copied into a TA-private integer (session_handle) used subsequently to resolve sessions; while bounds reads are checked, there is insufficient semantic validation of the handle value, enabling attacker-controlled session selection. This is a weak input validation issue, not an unencrypted-output or direct buffer overflow."
      ],
      "severity_distribution": {
        "medium": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0018",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 67,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "medium",
      "primary_vulnerability_type": "CWE-125",
      "functions": [
        "alloc_and_get"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-125",
        "CWE-20",
        "CWE-189"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Copies 'size' bytes from REE-derived src into allocated buffer without semantic limits on 'size'; size originates from parsed head.size.",
        "Copies 'size' bytes from REE-derived src into allocated buffer based on head.size without sufficient validation.",
        "Copies 'size' bytes from REE-derived src into allocated buffer; 'size' (attr.attrs_size) lacks application-level bounds validation.",
        "Copies REE-controlled 'src' (size = attr.attrs_size) into allocated buffer without explicit upper bound on attrs_size here."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_secret",
          "serialargs_alloc_get_one_attribute",
          "alloc_and_get",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_generate_key_pair",
          "serialargs_alloc_get_one_attribute",
          "alloc_and_get",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_create_object",
          "serialargs_alloc_get_attributes",
          "alloc_and_get",
          "TEE_MemMove"
        ],
        [
          "TA_InvokeCommandEntryPoint",
          "entry_copy_object",
          "serialargs_alloc_get_attributes",
          "alloc_and_get",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided serialargs buffer (params->memref.buffer)",
          "propagation_path": [
            "params->memref.buffer -> serialargs_init/ctrlargs (processing.c:226)",
            "serialargs parsing yields head.size/proc length -> passed into alloc_and_get as 'size' (serializer.c:119)",
            "serialargs_get_ptr reads src from args (serializer.c:56) -> TEE_MemMove(ptr + buf0_sz, src, size) (serializer.c:67)"
          ],
          "sink": "TEE_MemMove(dst=ptr+buf0_sz, src, size) in alloc_and_get (serializer.c:67)"
        },
        {
          "source": "REE-provided control buffer (ctrl->memref.buffer) used to build serialargs and header with head.size",
          "propagation_path": [
            "ctrl->memref.buffer -> serialargs_next (serialargs_init) @ processing.c:415",
            "serialargs_get reads header into head (head.size) @ serializer.c:115",
            "alloc_and_get calls serialargs_get_ptr to obtain src pointer to REE bytes @ serializer.c:56",
            "TEE_MemMove(ptr + buf0_sz, src, size) copies REE-controlled 'size' into TA buffer @ serializer.c:67"
          ],
          "sink": "TEE_MemMove at serializer.c:67 copying REE-derived data into TEE memory"
        },
        {
          "source": "REE-provided params buffer (params/ctrl->memref.buffer) containing serialized object head",
          "propagation_path": [
            "params[0/ctrl].memref.buffer -> serialargs_init/serialargs_get @ object.c:325/serializer.c:136",
            "attr.attrs_size read into attr.attrs_size @ serializer.c:136",
            "attr.attrs_size passed as 'size' into alloc_and_get @ serializer.c:140",
            "serialargs_get_ptr reads 'size' bytes into src @ serializer.c:56",
            "TEE_MemMove(ptr + buf0_sz, src, size) performs copy @ serializer.c:67"
          ],
          "sink": "TEE_MemMove(ptr + buf0_sz, src, size) copies unvalidated, input-derived length into TEE allocation"
        },
        {
          "source": "REE-provided ctrl->memref.buffer (serialargs bytes)",
          "propagation_path": [
            "params[0].memref.buffer -> ctrlargs (object.c:1108)",
            "serialargs_get -> attr (serializer.c:136)",
            "attr.attrs_size -> serialargs_alloc_get_attributes call (object.c:1118)",
            "attr.attrs_size passed as size into alloc_and_get (serializer.c:140)",
            "serialargs_get_ptr reads src from args->next using size (serializer.c:56)",
            "TEE_MemMove(ptr + buf0_sz, src, size) copies into TA buffer (serializer.c:67)"
          ],
          "sink": "TEE_MemMove at serializer.c:67 copying REE-controlled bytes into TA memory"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Malicious/ malformed REE-provided serialargs with crafted head.size",
            "serialargs_get_ptr returns a pointer or data for the requested size (no earlier truncation)"
          ],
          "attack_scenario": "Attacker supplies a crafted size and payload such that the copy overruns the allocated region or causes an over-read, leading to memory corruption or exposure of adjacent TA memory.",
          "impact": "Arbitrary memory corruption within TA heap (potential code execution) or disclosure of TA-private memory contents, depending on layout."
        },
        {
          "preconditions": [
            "Attacker supplies crafted ctrl memref (REE) to TA with manipulated head.size and payload",
            "serialargs_get_ptr returns pointer to requested bytes (caller-provided size present)"
          ],
          "attack_scenario": "Attacker crafts head.size to cause oversized copy semantics or unexpected allocation/content, leading to out-of-bounds read/write or corruption of TA memory during TEE_MemMove.",
          "impact": "Potential memory corruption within TA (denial-of-service or code execution depending on subsequent use); exposure of integrity of TA-internal structures."
        },
        {
          "preconditions": [
            "Attacker supplies crafted params memref with attr.attrs_size set to a large or unexpected value",
            "TA processes the serialized args and reaches alloc_and_get"
          ],
          "attack_scenario": "Attacker sets attrs_size very large to cause excessive memory allocation attempts, OOM conditions, or trigger resource exhaustion; in some environments this may lead to denial-of-service or failure paths that revert state unpredictably.",
          "impact": "Denial-of-service via resource exhaustion; depending on allocator behavior could lead to degraded TA operation or error paths."
        },
        {
          "preconditions": [
            "Attacker supplies crafted ctrl memref from REE to TA_InvokeCommandEntryPoint params[0]/ctrl",
            "attr.attrs_size contains large or unexpected value not bounded by caller checks"
          ],
          "attack_scenario": "Maliciously large or malformed attr.attrs_size causes alloc_and_get to copy more bytes than intended or exhaust resources; if upper bounds assumptions elsewhere are violated, memory corruption or denial of service may follow.",
          "impact": "Potential memory-safety issues (out-of-bounds reads/overflows, resource exhaustion) leading to TA instability or further exploitability."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "alloc_and_get:48-68",
          "recommendation": "Validate 'size' against a known safe maximum and ensure combined sz fits expected object limits before serialargs_get_ptr and TEE_MemMove."
        },
        {
          "type": "type_validation",
          "location": "serializer.c:115-121",
          "recommendation": "Validate parsed head.size against logical object/schema limits (reject absurd or excessively large sizes)."
        },
        {
          "type": "bounds_check",
          "location": "alloc_and_get:48-68",
          "recommendation": "Validate head.size against remaining serialargs bytes and reasonable limits before using it to allocate and copy; enforce max attribute sizes."
        },
        {
          "type": "type_validation",
          "location": "serialargs_alloc_get_one_attribute:115-121",
          "recommendation": "Sanitize header fields (head.size) and fail early on suspicious or excessive values."
        },
        {
          "type": "bounds_check",
          "location": "alloc_and_get:48-68",
          "recommendation": "Validate attr.attrs_size against an application-specific maximum and reject unreasonable sizes before allocation and copy."
        },
        {
          "type": "range_check",
          "location": "serialargs_alloc_get_attributes:140",
          "recommendation": "Verify attrs_size is within expected semantic limits for attributes before delegating to alloc_and_get."
        },
        {
          "type": "bounds_check",
          "location": "alloc_and_get:48-68",
          "recommendation": "Validate attr.attrs_size against a conservative maximum and remaining args buffer before calling serialargs_get_ptr and before allocation; enforce upper bound on 'size'."
        },
        {
          "type": "range_check",
          "location": "serialargs_alloc_get_attributes:140",
          "recommendation": "Sanitize attr.attrs_size (from REE) with explicit maximum and reject unreasonable sizes."
        }
      ],
      "decision_rationales": [
        "The copy at line 67 uses an attacker-controllable 'size' parsed from REE data; while integer overflow is checked, there is no explicit semantic bounds validation of 'size' against expected attribute limits, producing a plausible memory-safety vulnerability (over-read/overflow) at the copy site.",
        "The sink at line 67 copies REE-controlled bytes with length derived from REE header (head.size). While overflow of combined size is checked, there is insufficient explicit validation of head.size against available/expected limits; therefore weak input validation can lead to unsafe copies.",
        "Although integer-overflow and allocation-failure checks exist, the sink uses an unvalidated, attacker-controlled length (attr.attrs_size) to drive allocation and copying; this is weak input validation and can be abused for resource exhaustion or unexpected behavior, so line 67 is classified vulnerable (weak_input_validation) with medium confidence.",
        "The copy at line 67 uses a size value derived from REE-controlled data (attr.attrs_size) with no explicit upper-bound enforcement at that program point; although some checks exist (ADD_OVERFLOW, serialargs_get_ptr failure), they do not prove a sufficient sanitizer for arbitrary attrs_size, so this is classified as weak_input_validation vulnerability."
      ],
      "severity_distribution": {
        "medium": 1,
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    }
  ],
  "total_finding_lines": 283,
  "structural_risks": [
    {
      "finding_id": "RISK-0001",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/alloc_key_data_to_wrap (call-site)",
      "line": 2777,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "encode_rsa_private_key_der"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'head' parameter aliases key->attributes (TA-private object attributes containing private key parts).",
        "Call-site binding: 'data' parameter is &key_data (TA-private out pointer) provided by caller.",
        "Call-site binding: 'sz' parameter is &key_sz (TA-private size out parameter) from caller."
      ],
      "code_excerpts": [
        "rc = encode_rsa_private_key_der(head, data, sz);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:secret",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "dst_region:TEE-private",
          "size_triplet:copy_len=4,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0002",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 34,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "add_attribute"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "computes buf_len from (*head)->attrs_size and then serializes into buffer without explicit capacity check of destination, relying on serialize to enforce bounds",
        "Computes buf_len from (*head)->attrs_size and serializes into buffer without an explicit capacity check local to caller; relies on serialize to enforce safety."
      ],
      "code_excerpts": [
        "buf_len = sizeof(struct obj_attrs) + (*head)->attrs_size; ... rc = serialize(bstart, &buf_len, data, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=buf_len"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0003",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 54,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "add_attribute"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "updates (*head)->attrs_size by adding user-controlled size without additional validation; may corrupt internal bookkeeping if size is tainted"
      ],
      "code_excerpts": [
        "(*head)->attrs_size += 2 * sizeof(uint32_t) + size;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=2*sizeof(uint32_t)+size,src_sz=size,dst_sz=(*head)->attrs_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0004",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 55,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "add_attribute"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Updates (*head)->attrs_size by adding size; untrusted size can cause overflow or incorrect size accounting if not validated"
      ],
      "code_excerpts": [
        "(*head)->attrs_size += 2 * sizeof(uint32_t) + size;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=2*sizeof(uint32_t)+size,src_sz=buf_len,dst_sz=(*head)->attrs_size"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0005",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 72,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "_remove_attribute"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Loop bound uses h->attrs_size derived from head; if attrs_size is corrupted by input, loop may OOB or mis-parse entries"
      ],
      "code_excerpts": [
        "for (; cur < end; cur += next_off) {"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=next_off,src_sz=h->attrs_size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0006",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 75,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "_remove_attribute"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: destination &pkcs11_ref is local (TEE-private) while source 'cur' derives from *head memory whose provenance is caller-controlled/unknown",
        "Reads attribute header from cur via TEE_MemMove into local pkcs11_ref; source (cur) may be in REE-derived buffer",
        "Reads attribute header from cur (possibly REE-derived) into local pkcs11_ref via TEE_MemMove; source provenance uncertain",
        "Fixed-size header read from REE-derived region without explicit check that remaining bytes >= header size.",
        "Reads attribute header from cur into local pkcs11_ref using TEE_MemMove where pkcs11_ref.size is later used to compute next_off; size originates from memory and is only implicitly bounded by end",
        "Reads attribute header from untrusted memory into local pkcs11_ref via TEE_MemMove; pkcs11_ref.size then controls subsequent offsets without strong bounds before use",
        "Binding: destination &pkcs11_ref originates as callee-local (TEE-private) while source cur is buffer derived from head; record aliasing of pointers at call-site",
        "Reading pkcs11_ref from attrs buffer where pkcs11_ref.size influences offsets without explicit bounds validation.",
        "Reads attribute header from untrusted blob (cur) to compute next_off and then uses it to bound memmove without verifying next_off fits within remaining attrs; attacker-controlled size can cause out-of-bounds behavior.",
        "dst (&pkcs11_ref) is a local TA buffer while src (cur) points into obj_attrs blob derived from caller; binding of callee params to their origins.",
        "Reading attribute header from untrusted blob without checking header fits within remaining attrs_size.",
        "Copies attribute header from parsed buffer into local pkcs11_ref; source buffer provenance unclear (could be REE-origin), sizes derived from parsed data",
        "parses pkcs11_ref.size from in-memory data and uses it to compute next_off and loop bounds without strong validation against h->attrs_size",
        "copies header at cur into local pkcs11_ref using size derived from in-memory data; parsed size later used to compute offsets without stronger validation",
        "Copies attribute header from cur without verifying there are sizeof(pkcs11_ref) bytes remaining; header.size is then trusted",
        "Binding: destination '&pkcs11_ref' is a local TA stack object (TA-private) at call site",
        "Copies header from 'cur' without first confirming sizeof(header) bytes remain; header.size then influences parsing",
        "Uses pkcs11_ref.size read from buffer at cur to compute next_off and as a memmove length without validating it against attrs_size, enabling out-of-bounds/mis-sized moves",
        "dest (&pkcs11_ref) is TA-local but src (cur) may be REE-derived buffer; binding of destination to caller origin recorded"
      ],
      "code_excerpts": [
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref));",
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)); next_off = sizeof(pkcs11_ref) + pkcs11_ref.size;",
        "TEE_MemMove(cur, cur + next_off, end - (cur + next_off));"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz= h->attrs_size,dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=end - cur,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=end - (cur + next_off),src_sz=h->attrs_size,dst_sz=h->attrs_size",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=end - (cur),dst_sz=sizeof(pkcs11_ref)",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=h->attrs_size,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=end-cur,dst_sz=sizeof(pkcs11_ref)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0007",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 84,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "weak_input_validation",
      "functions": [
        "_remove_attribute",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "weak_input_validation",
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Uses pkcs11_ref.size (derived from memory within h, potentially attacker-controlled) to compute next_off and perform an in-place TEE_MemMove without an explicit upper bound on next_off",
        "Uses pkcs11_ref.size-derived next_off to compute an in-place memmove length (end - (cur + next_off)) without an explicit upper bound on pkcs11_ref.size",
        "In-place memmove shifts trailing attributes within head buffer (cur <- cur+next_off) where buffer may be REE-visible and next_off is derived from REE-controlled size field without independent bounds validation",
        "In-place shift of trailing attributes (cur <- cur+next_off) uses next_off derived from REE-controlled size field without an independent bound check",
        "In-place shift within REE-visible buffer uses next_off derived from REE-controlled pkcs11_ref.size without independent validation, enabling overwrite.",
        "Shifts tail data left with TEE_MemMove(cur, cur + next_off, end - (cur + next_off)) using next_off derived from untrusted attribute size; may under/overlap and affects attrs_size/count",
        "Shifts tail data left using length computed from next_off derived from untrusted attribute size; overlapping move within same buffer may be unsafe if sizes are malicious",
        "Binding: dest cur and src cur+next_off are pointers into the same attrs buffer (aliasing); length depends on untrusted header-derived next_off",
        "Tail data moved using next_off derived from untrusted header, enabling overlapping/unsafe moves and attrs_size/count modifications.",
        "In-place memmove shifts remaining attributes using attacker-influenced next_off derived from pkcs11_ref.size; insufficient explicit bounds/sanity checks on pkcs11_ref.size.",
        "Copies remainder of attribute list using next_off computed from untrusted pkcs11_ref.size without strong sanity checks; len expression may be attacker-controlled causing OOB or logic errors.",
        "In-place shift of attribute bytes uses next_off from untrusted header without sufficient validation, risking OOB.",
        "in-place TEE_MemMove shifts remaining attributes using sizes derived from parsed pkcs11_ref and h->attrs_size; malformed sizes could cause incorrect memory shifts",
        "In-place shift of trailing attributes using length computed from parsed headers; malformed pkcs11_ref.size or attrs_size may cause incorrect move",
        "In-place attribute shifting uses unvalidated next_off derived from pkcs11_ref.size; malformed sizes can cause incorrect memory moves.",
        "in-place TEE_MemMove moves memory region (cur + next_off) to cur using length derived from end - (cur + next_off); if sizes miscomputed this can corrupt attribute list",
        "in-place memmove shifts trailing bytes using length computed from end and next_off; miscomputed next_off can corrupt list (overlap/misbound copy)",
        "Uses pkcs11_ref.size (from unvalidated header) to compute next_off and to memmove remaining bytes, enabling OOB reads/writes if header is malicious",
        "Binding: dest 'cur' and src 'cur + next_off' are pointers into the same attributes buffer (TA-private)",
        "Moves remaining bytes based on next_off computed from untrusted header size; may underflow/overflow if header is malicious",
        "memmove uses len computed from pkcs11_ref.size without prior robust validation against attrs_size, allowing out-of-bounds move"
      ],
      "code_excerpts": [
        "TEE_MemMove(cur, cur + next_off, end - (cur + next_off));"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "shared_memory_overwrite",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=end - (cur + next_off),src_sz=h->attrs_size,dst_sz=h->attrs_size",
          "flow_dir:TA->REE",
          "src_region:REE-visible",
          "dst_region:REE-visible",
          "size_triplet:copy_len=end - (cur + next_off),src_sz=h->attrs_size,dst_sz=h->attrs_size - next_off",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=end - (cur + next_off),src_sz=end - (cur + next_off),dst_sz=end - cur",
          "size_triplet:copy_len=end - (cur + next_off),src_sz=h->attrs_size - (cur - ((char*)h + sizeof(struct obj_attrs))),dst_sz=h->attrs_size",
          "flow_dir:TEE->TEE",
          "flow_dir:TA->TEE-private",
          "sensitivity_label:private"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0008",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 107,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'head' aliases caller-provided obj_attrs (TA-private attribute blob).",
        "Call-site binding: 'head' aliases callers' object attribute container (object state) and is used for internal parsing.",
        "Binding: 'head' originates from caller attributes container (may embed REE-derived template); used for pointer arithmetic to compute cur/end.",
        "alias of caller-provided 'head' passed into function; head typically originates from REE-derived template in higher-level callers",
        "Call-site binding: 'head' aliases caller-provided attributes structure which may be REE-originated or TA-private depending on caller"
      ],
      "code_excerpts": [
        "char *cur = (char *)head + sizeof(struct obj_attrs);",
        "void get_attribute_ptrs(struct obj_attrs *head, uint32_t attribute, void **attr, uint32_t *attr_size, size_t *count)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=head->attrs_size,dst_sz=unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=unknown,src_sz=head->attrs_size+sizeof(struct obj_attrs),dst_sz=unknown",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=NA,src_sz=head->attrs_size,dst_sz=unknown",
          "size_triplet:copy_len=head->attrs_size,src_sz=head->attrs_size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0009",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 110,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'count' is used as input max_found and updated with number of matches found (caller-provided control value).",
        "Binding: 'count' is input/output controlling max_found and updated to actual found count; caller-provided value drives loop termination and outputs.",
        "Call-site binding: '*count' used as max_found; caller-provided count influences loop's early exit"
      ],
      "code_excerpts": [
        "size_t max_found = *count; ... *count = found;",
        "size_t max_found = *count;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=0,src_sz=*count,dst_sz=sizeof(size_t)",
          "flow_dir:TA->TA",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(size_t),src_sz=*count,dst_sz=sizeof(size_t)",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(size_t),src_sz=*count,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0010",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 112,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'attr' (attr_ptr) is an out-parameter that will be filled with pointers into TA-private storage.",
        "Binding: 'attr' is caller-supplied out-pointer array; pointers stored point into template region (cur + sizeof(pkcs11_ref)).",
        "attr (out pointer) is alias-bound to caller storage; caller may supply TA or REE memory so origin is unknown",
        "Call-site binding: 'attr' output pointer is caller-supplied (may be NULL or point into caller stack/vars)"
      ],
      "code_excerpts": [
        "if (attr) { if (pkcs11_ref.size) *attr_ptr++ = cur + sizeof(pkcs11_ref); else *attr_ptr++ = NULL; }",
        "void **attr_ptr = attr;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TEE-private",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=pointer,src_sz=pkcs11_ref.size,dst_sz=sizeof(void*)",
          "flow_dir:TA->TA",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=pointer_size,src_sz=pkcs11_ref.size,dst_sz=pointer_array_length",
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA",
          "size_triplet:copy_len=sizeof(void *),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0011",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 113,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'attr_size' is updated with attribute sizes (TA-private metadata written out).",
        "Binding: 'attr_size' is caller-provided size array; receives pkcs11_ref.size values which influence upstream buffer checks.",
        "attr_size (out pointer) is alias-bound to caller storage; sizes written derive from parsed pkcs11_ref.size which may be attacker-controlled if head is REE-derived",
        "Call-site binding: 'attr_size' output pointer is caller-supplied (may be NULL or point into caller memory)"
      ],
      "code_excerpts": [
        "if (attr_size) *attr_size_ptr++ = pkcs11_ref.size;",
        "uint32_t *attr_size_ptr = attr_size;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TEE-private",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=pkcs11_ref.size,dst_sz=unknown",
          "flow_dir:TA->TA",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=4,src_sz=pkcs11_ref.size,dst_sz=number_of_matches*4",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=NA,src_sz=head->attrs_size,dst_sz=*attr_size",
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0012",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 115,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "unknown",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Loop advances by next_off derived from pkcs11_ref.size read from data in 'head' without validating next_off before use; malformed attrs_size or pkcs11_ref.size can cause logic errors or overrun.",
        "Loop advances by next_off computed from pkcs11_ref.size read from unvalidated data; malformed sizes can cause overruns or infinite loops.",
        "pkcs11_ref.size (from unvalidated template bytes) is used to compute next_off and advance cur without an upper bound check, enabling out-of-bounds next_off",
        "Computes next_off = sizeof(pkcs11_ref) + pkcs11_ref.size where pkcs11_ref.size is from untrusted bytes and not upper-bounded, enabling out-of-bounds advancement.",
        "Reads attribute headers and uses pkcs11_ref.size to advance cur (next_off) without explicit check that cur+sizeof(pkcs11_ref) and cur+next_off are within bounds before the TEE_MemMove, risking out-of-bounds read if attrs_size is inconsistent.",
        "Reads attribute header and uses header.size to advance without explicit pre-read bounds check; can cause out-of-bounds read.",
        "Parses length-prefixed attributes using pkcs11_ref.size from buffer; if pkcs11_ref.size is attacker-controlled it may cause next_off or cur arithmetic to overflow/skip checks leading to panic/out-of-bounds",
        "Loop computes next_off from pkcs11_ref.size (attacker-controlled) to advance cur; without robust range checks this can lead to mis-parsing, over-reads, or infinite loops.",
        "loop advances by next_off derived from pkcs11_ref.size (input-controlled) without per-iteration validation against end until final check, enabling crafted attrs_size/size to cause mis-iteration",
        "Loop advances by next_off computed from untrusted pkcs11_ref.size without validating each advancement against end, enabling mis-iteration or overshoot."
      ],
      "code_excerpts": [
        "for (; cur < end; cur += next_off) { ... next_off = sizeof(pkcs11_ref) + pkcs11_ref.size; }",
        "next_off = sizeof(pkcs11_ref) + pkcs11_ref.size;",
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)); next_off = sizeof(pkcs11_ref) + pkcs11_ref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=next_off,src_sz=pkcs11_ref.size,dst_sz=head->attrs_size - (cur - ((char*)head+sizeof(struct obj_attrs)))",
          "flow_dir:REE->TA",
          "size_triplet:copy_len=next_off,src_sz=pkcs11_ref.size,dst_sz=(end-cur)",
          "flow_dir:TA->TA",
          "sensitivity_label:secret",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=head->attrs_size,dst_sz=sizeof(pkcs11_ref)",
          "src_region:REE-visible",
          "size_triplet:copy_len=next_off,src_sz=head->attrs_size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0013",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 119,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "get_attribute_ptrs",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "=",
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Reads pkcs11_attribute_head from untrusted offsets inside head via TEE_MemMove without explicit validation of pkcs11_ref.size beyond loop bounds; malformed attrs_size could cause logic errors.",
        "Reads pkcs11_attribute_head from memory at cur into local struct; pkcs11_ref.size later used to compute next_off without stronger validation of serialized contents.",
        "TEE_MemMove reads pkcs11_attribute_head from cur; next_off uses pkcs11_ref.size for loop advance—size field influences control flow and can lead to overflow if corrupted.",
        "Copies header from cur (inside object attribute blob) into local pkcs11_ref; size field from that header influences subsequent next_off arithmetic (control-flow influence).",
        "Copies attribute header from serialized region into stack (TEE_MemMove) and uses pkcs11_ref.size to compute next_off without prior validation of size field, enabling out-of-bounds or integer overflow if input is malicious.",
        "Copies header from serialized region (src 'cur') into stack struct without validating pkcs11_ref.size before using it to compute next_off; malicious size may cause logic/integer errors or loop misbehavior.",
        "Header copied from serialized region without validating remaining bytes; header.size later trusted to compute next_off.",
        "Reads pkcs11_attribute_head from cur (TEE_MemMove) where cur is computed from head and head->attrs_size; pkcs11_ref.size (data-controlled) is used to compute next_off and loop progression",
        "Copies serialized attribute header from buffer at cur into local pkcs11_ref; source buffer derived from head and head->attrs_size influences src bounds and is potentially attacker-controlled",
        "Parses pkcs11_ref from serialized blob and uses pkcs11_ref.size to advance and to derive pointers; if pkcs11_ref.size is attacker-controlled, loop arithmetic and pointer arithmetic may be unsafe.",
        "Call-site binding: destination 'dest' parameter is &pkcs11_ref, a TA-stack buffer (local), so copy writes into TA-private memory.",
        "Call-site binding: source 'src' parameter aliases 'cur' which points into serialized attribute blob derived from head (origin: REE -> parsed into TA storage).",
        "Call-site binding: size 'n' is sizeof(pkcs11_ref) here but callers use variable sizes elsewhere; record that size parameter influences copy length.",
        "Copies header from serialized blob into local struct and then uses parsed size to advance loop; if parsed size is attacker-controlled, parsing and subsequent arithmetic may be unsafe.",
        "Parses header from serialized attributes and relies on parsed pkcs11_ref.size for loop arithmetic; attacker-controlled size can break bounds and lead to OOB reads.",
        "Copies bytes from 'cur' (pointer into serialized attribute blob derived from REE-supplied templates) into local pkcs11_ref; source is REE-influenced and used to compute next_off",
        "Reads pkcs11_attribute_head from cur and uses pkcs11_ref.size to compute next_off without explicit overflow/malformed-field protection; malformed size could flow to next_off and loop control.",
        "Call-site binding: dest parameter (&pkcs11_ref) is a caller stack object (TA-private) receiving bytes.",
        "Call-site binding: src parameter (cur) points into serialized attributes buffer from 'head' (TA-owned serialized region).",
        "Copies header at cur into pkcs11_ref and then uses pkcs11_ref.size to compute next_off; malformed or attacker-controlled sizes in serialized data can cause logic errors.",
        "Copies bytes from buffer 'cur' (parsed from head, possibly REE-originated) into local structure via TEE_MemMove; source origin ambiguous and copy length is derived from fixed sizeof destination.",
        "Destination &pkcs11_ref is a TA stack/local structure (TEE-private) being written by memmove from a pointer into serialized object data.",
        "Source 'cur' points inside serialized attributes buffer derived from head; origin is TA-managed serialized object storage (TEE-private).",
        "TEE_MemMove reads a fixed-size header from cur without confirming that sizeof(pkcs11_ref) bytes remain in the serialized attributes buffer; next_off is computed from the unvalidated pkcs11_ref.size, risking over-read.",
        "Copies bytes from 'cur' (within serialized object storage) into local pkcs11_ref structure; source derives from head->attrs_size data and could be malformed leading to incorrect next_off computation.",
        "TEE_MemMove reads attribute header from serialized object at cur; next_off uses parsed size to advance — malformed size can cause out-of-bounds advancement and triggers TEE_Panic check",
        "Copies attribute header from serialized object (cur) into local pkcs11_ref on stack; both source and destination are TA-managed memory but malformed size in header drives next_off and loop progress.",
        "Reading a fixed-size header from cur without verifying remaining bytes >= sizeof(pkcs11_ref); malformed pkcs11_ref.size then drives next_off and loop progression.",
        "Copies pkcs11_attribute_head from cur using TEE_MemMove without validating cur against end other than loop condition; malformed attrs_size or pkcs11_ref.size can cause out-of-bounds or panic",
        "Copies pkcs11_attribute_head from parsed buffer at cur into local pkcs11_ref using size sizeof(pkcs11_ref) while cur/end bounds depend on head->attrs_size which may be malformed or REE-influenced",
        "TEE_MemMove copies pkcs11_attribute_head from cur without ensuring cur+sizeof(pkcs11_ref) <= end; malformed head->attrs_size or pkcs11_ref.size can cause OOB read or panic.",
        "Uses pkcs11_ref.size (from serialized data in head) to compute next_off and advance 'cur' without additional bounds validation beyond final check; malformed size could cause incorrect traversal.",
        "Reads pkcs11_ref from serialized 'cur' (potentially untrusted/malformed) into local structure without validating embedded size before use.",
        "Reads header from serialized blob and uses its size field to advance traversal without validating header availability first.",
        "Copies sizeof(pkcs11_ref) from cur (derived from head + offset) into local pkcs11_ref; cur/end arithmetic uses head->attrs_size which may be derived from untrusted serialized data.",
        "Call-site binding: destination '&pkcs11_ref' is a TA-local stack buffer written by TEE_MemMove.",
        "Call-site binding: source 'cur' points into head->attrs (TA-private blob) and is used as read source for memmove.",
        "destination &pkcs11_ref is a local TA stack buffer (TEE-private) being written from src; alias/binding of dst parameter to a local struct.",
        "source 'cur' points into head-derived buffer; origin may be TA-private or derived from untrusted/template data (unknown provenance).",
        "length argument is a constant sizeof(pkcs11_ref); binding of size parameter to this constant observed at call-site.",
        "Reads attribute header via TEE_MemMove from cur (derived from head) and uses pkcs11_ref.size to compute next offset (TA memory-driven pointer arithmetic).",
        "Reads attribute header from cur (derived from head + offset) into local pkcs11_ref; source is TA attribute storage computed from head->attrs_size.",
        "Reads pkcs11_attribute_head from cur (derived from head buffer) into local struct via TEE_MemMove; fields (size/id) are attacker-controlled if head originates from REE.",
        "Copies pkcs11_attribute_head from buffer 'cur' (potentially REE-controlled) into local struct; fields like size/id are attacker-controllable.",
        "Binding: destination pointer '&pkcs11_ref' (callee dest) is a TA-local stack location passed to TEE_MemMove.",
        "Binding: source pointer 'cur' (callee src) points into object buffer that may originate from REE/shared memory.",
        "Deserializes pkcs11_attribute_head from cur via TEE_MemMove; pkcs11_ref.size directly affects next_off and loop stepping without per-field validation",
        "Deserializes pkcs11_attribute_head from cur into local struct; pkcs11_ref.size subsequently used to compute next_off without validating size field",
        "Reads attribute header from cur into pkcs11_ref via TEE_MemMove and trusts pkcs11_ref.size to compute next_off without verifying header bounds beyond loop condition; malformed size could cause next_off to skip/overrun.",
        "Reads attribute header from potentially REE-influenced buffer into pkcs11_ref and trusts pkcs11_ref.size to compute next_off without further validation.",
        "Uses pkcs11_ref.size from serialized data to compute next_off and advance cur without validating size limits beyond end check; malformed size may cause logic errors.",
        "TEE_MemMove reads a pkcs11_attribute_head from cur (parsed from head); that parsed header controls subsequent pointer arithmetic.",
        "Parses serialized attribute header by copying from 'cur' into local pkcs11_ref; src originates from head payload and controls next_off used for pointer arithmetic.",
        "reads attribute header from cur and uses pkcs11_ref.size to compute next_off and to set pointers/sizes without fully validating that the computed offsets lie within end",
        "Copies pkcs11_attribute_head from cur (derived from head which may contain REE-supplied data) into stack struct; size used later (pkcs11_ref.size) is attacker-influenced if cur is untrusted.",
        "Reads attribute header from cur and uses pkcs11_ref.size to compute offsets without proving the header fully fits inside the remaining buffer; malformed attrs_size can trigger OOB read or panic.",
        "Copies attribute header from cur then uses pkcs11_ref.size to compute next_off without validating that pkcs11_ref.size keeps cur within bounds (next_off influences loop advance)",
        "Copies attribute header from 'cur' (derived from head which may be REE-supplied) into local pkcs11_ref without validating pkcs11_ref.size before use",
        "reads attribute header from cur and uses pkcs11_ref.size to compute next_off without fully validating that the claimed size keeps cur within end",
        "Copies sizeof(pkcs11_ref) bytes from cur (pointer into head buffer, often REE-derived) into local pkcs11_ref without validating that remaining length >= sizeof(pkcs11_ref)",
        "Reads header from cur and uses its size to advance without validating that header read and next_off remain within the serialized buffer; can cause OOB or panic.",
        "Reads pkcs11_ref header from cur and uses pkcs11_ref.size to advance and to populate pointers without validating that size fits remaining buffer",
        "Copies pkcs11_ref header from cur (parsed from head which may be REE-controlled) into local struct without validating remaining bytes against pkcs11_ref.size",
        "reads attribute header via TEE_MemMove from cur (derived from head) and uses pkcs11_ref.size to compute next_off without ensuring sizeof(pkcs11_ref)+pkcs11_ref.size is within end",
        "Copies sizeof(pkcs11_ref) from cur (derived from head which may be REE-controlled) into local pkcs11_ref; size and subsequent next_off use fields from untrusted data without robust validation",
        "Reads header from serialized attributes and uses header.size to compute next offset without verifying header fits completely within remaining buffer.",
        "Reads pkcs11_attribute_head from cur (derived from head) and uses pkcs11_ref.size to compute next offset and pointers without validating size vs remaining bytes",
        "Copies pkcs11_attribute_head from cur (derived from head built from caller data) into local pkcs11_ref using size sizeof(pkcs11_ref) without validating that remaining bytes >= sizeof(pkcs11_ref)",
        "reads attribute header from cur and uses pkcs11_ref.size to compute next_off and outputs without explicit validation that cur+next_off stays within end (panic if exceeded later)",
        "copies sizeof(pkcs11_ref) from cur (derived from head which may be REE-supplied) into local structure without validating that cur+sizeof(pkcs11_ref) <= end beyond loop bound check",
        "Reads attribute header from cur and uses pkcs11_ref.size to advance; no explicit check that sizeof(pkcs11_ref) bytes remain before read.",
        "Parses length (pkcs11_ref.size) from data in head and uses it to compute next_off and result pointers without validating pkcs11_ref.size against remaining buffer, enabling out-of-bounds reads.",
        "Copies sizeof(pkcs11_ref) bytes from cur (derived from head, potentially REE-controlled) into local pkcs11_ref; length fields read later (pkcs11_ref.size) are then trusted to compute offsets.",
        "Call-site binding: destination '&pkcs11_ref' is TA-private stack storage (receives data from src).",
        "Call-site binding: source 'cur' derives from head which may be REE-supplied, so memmove reads untrusted memory.",
        "Parses pkcs11_attribute_head from untrusted 'cur' via TEE_MemMove and uses pkcs11_ref.size without validating it sufficiently before pointer arithmetic",
        "Copies pkcs11_attribute_head from parsed buffer 'cur' (untrusted) into local struct and uses its size for arithmetic without strong validation",
        "Reads pkcs11_attribute_head from cur (untrusted-derived buffer) via TEE_MemMove and uses pkcs11_ref.size to compute next_off without robust validation",
        "Copies pkcs11_attribute_head from cur (template/blob derived from REE) into local pkcs11_ref using supplied length, trusting blob fields for subsequent size arithmetic",
        "Copies attribute header bytes from template region (cur) into local pkcs11_ref on stack; source may originate from REE-derived serialized data.",
        "reads attribute header from cur (derived from head which may be REE-supplied) and uses pkcs11_ref.size to compute next offset without ensuring sizeof(header)+size stays within end before use",
        "Copies header from cur (derived from head which may be REE-supplied) into local pkcs11_ref and then uses pkcs11_ref.size to compute offsets without ensuring header+size fit before use",
        "Reads header from untrusted serialized attributes buffer and uses its size field to compute offsets without validating header fits in remaining buffer.",
        "Reads pkcs11_attribute_head from cur via TEE_MemMove and uses pkcs11_ref.size to compute next_off without validating remaining buffer length against pkcs11_ref.size",
        "Reads attribute header from cur into pkcs11_ref and uses pkcs11_ref.size to compute offsets without validating remaining buffer length first",
        "Reads pkcs11_attribute_head from potentially attacker-controlled template buffer via TEE_MemMove; pkcs11_ref.size used to advance loop and influence writes.",
        "Destination &pkcs11_ref is a local stack object; callee will write into caller stack.",
        "Source 'cur' points inside template buffer derived from head; origin is head-based buffer (parsed data).",
        "Reads pkcs11_attribute_head from cur with TEE_MemMove using size from ref data; insufficient validation that remaining bytes >= sizeof(header) before copy.",
        "Copies pkcs11_attribute_head from cur into local struct without an explicit remaining-bytes check before the copy; cur derived from head->attrs_size.",
        "Copies sizeof(pkcs11_ref) bytes from cur (pointer into head buffer) into local pkcs11_ref; src provenance (template bytes) is ambiguous",
        "TEE_MemMove reads pkcs11_attribute_head from cur (derived from head) without explicit per-entry bounds check before using pkcs11_ref.size to compute next_off; later cur> end triggers panic but intermediate uses may dereference invalid lengths.",
        "Copies pkcs11_attribute_head from cur (derived from head) without validating cur+sizeof(header) <= end before reading header->size, enabling malformed sizes to influence next_off.",
        "Parses attribute headers from buffer using pkcs11_ref.size to compute next offset and pointer results; if headers are corrupted/malicious, loop arithmetic may be influenced.",
        "Call-site binding: destination &pkcs11_ref is a local stack object written from 'cur' (caller-controlled buffer region).",
        "Call-site binding: source 'cur' points into attribute buffer derived from head->attrs_size; origin may be attacker-influenced if head stems from REE.",
        "Copies header then uses pkcs11_ref.size to compute next_off and pointers; malformed sizes in attributes can influence loop bounds and pointer arithmetic.",
        "reads pkcs11_ref header from cur (derived from head) and uses pkcs11_ref.size to compute next_off and pointer writes without explicit check that sizeof(header)+size <= end",
        "Copies header from cur (derived from head which may be REE-supplied) into local struct using sizeof(header) without proving that sizeof+payload fits before reading payload size",
        "Header read uses pkcs11_ref.size to advance without prior validation that header+payload fit inside head->attrs_size.",
        "Reads pkcs11_ref from cur and uses pkcs11_ref.size to compute next_off without validating that pkcs11_ref.size fits within remaining bytes",
        "Reads header from cur (derived from head->attrs_size) and uses header.size to compute next offset without validating header.size against remaining bytes",
        "Unvalidated read of header from serialized attributes where embedded size fields (pkcs11_ref.size) and remaining buffer length are not adequately checked.",
        "Call-site binding: destination &pkcs11_ref is a local TA stack buffer (receives bytes copied by TEE_MemMove).",
        "Call-site binding: source 'cur' points into head->attrs storage (TA-private) and is read by TEE_MemMove.",
        "Copies sizeof(pkcs11_ref) from cur without an explicit pre-check that cur+sizeof(pkcs11_ref) is <= end on the exact read site.",
        "Reads pkcs11_ref from object memory and uses pkcs11_ref.size to advance cur (next_off) without explicit upper-limit on pkcs11_ref.size, risking out-of-bounds if attrs_size is corrupted.",
        "Call-site binding: destination '&pkcs11_ref' is a caller stack buffer (TA-private) receiving data copied from object memory.",
        "Call-site binding: source 'cur' points into object attribute storage (head+offset) which is TA-private memory.",
        "Uses pkcs11_ref.size (read from src) to compute next_off without constraining pkcs11_ref.size against remaining attrs_size; a corrupted size can cause out-of-bounds reads.",
        "Reads header then uses header.size to compute next_off without validating size against remaining attrs_size.",
        "parsing uses pkcs11_ref.size from buffer to compute next_off and pointer targets without validating size bounds or provenance",
        "Copies header from buffer at cur using size from code; pkcs11_ref.size later used to compute offsets without validating that size is sane or provenance of cur",
        "Copies bytes from 'cur' (pointer into attribute buffer possibly derived from REE) into local pkcs11_ref struct; src is REE-derived so could be attacker-controlled",
        "Reads pkcs11_attribute_head from cur using TEE_MemMove; cur is derived from head->attrs_size and may be attacker-controlled leading to malformed sizes/next_off",
        "Copies bytes from cur (derived from head, potentially REE-supplied) into local pkcs11_ref on stack; source provenance uncertain",
        "Parsing loop uses sizes from serialized attributes (possibly REE-controlled) to derive next offsets; malformed sizes may drive out-of-bounds reads or large jumps.",
        "Reads attribute header from cur (derived from head + offset) with TEE_MemMove using attacker-controlled offsets/size; pkcs11_ref.size then drives next_off without validation.",
        "Copies header from cur (derived from head+offset where head.attrs_size is attacker-influenced) into pkcs11_ref using len sizeof(pkcs11_ref) while next_off is computed from untrusted pkcs11_ref.size.",
        "Copies header from cur (possibly REE-derived shared buffer) into stack struct pkcs11_ref, binding shared src into TA-private destination"
      ],
      "code_excerpts": [
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref));",
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)); next_off = sizeof(pkcs11_ref) + pkcs11_ref.size;",
        "next_off = sizeof(pkcs11_ref) + pkcs11_ref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=head->attrs_size,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=sizeof(pkcs11_ref),dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=pkcs11_ref.size+sizeof(pkcs11_ref),dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:REE->TA",
          "src_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=head->attrs_size - (cur - ((char*)head + sizeof(struct obj_attrs))),dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:unknown",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=unknown,dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:TEE->TEE",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=(end - cur)?,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=end-cur,dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:TA->TEE-private",
          "flow_dir:TEE-private->TA",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=head->attrs_size - offset,dst_sz=sizeof(pkcs11_ref)",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(pkcs11_attribute_head),src_sz=head->attrs_size,dst_sz=sizeof(pkcs11_attribute_head)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=(end-cur),dst_sz=sizeof(pkcs11_ref)",
          "src_region:REE-visible",
          "dst_region:unknown",
          "size_triplet:copy_len=next_off,src_sz=pkcs11_ref.size,dst_sz=head->attrs_size",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=end - cur,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=template->attrs_size,dst_sz=sizeof(pkcs11_ref)",
          "sensitivity_label:secret"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0014",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 120,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Computes next_off = sizeof(pkcs11_ref) + pkcs11_ref.size derived from data in memory; if pkcs11_ref.size is corrupted this can misadvance cur causing out-of-bounds or infinite loop.",
        "Computes next_off = sizeof(pkcs11_ref) + pkcs11_ref.size from data read by line 119; corrupted size can misadvance cur causing out-of-bounds or infinite loop.",
        "pkcs11_ref.size (from the copied header) is used to compute next_off and drive loop advancement; if pkcs11_ref.size is corrupted, parsing can exceed bounds or trigger panic.",
        "Uses pkcs11_ref.size (read from serialized data) to compute next_off and to set attr_size; untrusted size can influence pointer arithmetic and later copies",
        "pkcs11_ref.size from serialized data is used to compute next_off and later as reported attr_size; untrusted size can influence pointer arithmetic and later copies",
        "Uses pkcs11_ref.size (from untrusted input) to compute next_off and advance cur, enabling input-driven out-of-bounds pointer arithmetic.",
        "Uses attacker-controlled pkcs11_ref.size to compute next_off and advance cur, enabling input-driven out-of-bounds arithmetic.",
        "Computes next_off = sizeof(pkcs11_ref) + pkcs11_ref.size from unvalidated pkcs11_ref.size; if pkcs11_ref.size is large it may make cur advance past end leading to panic.",
        "Computes next_off = sizeof(pkcs11_ref) + pkcs11_ref.size from untrusted pkcs11_ref.size without validating it against remaining buffer, enabling cursor overrun.",
        "Parsed pkcs11_ref.size from untrusted data is used to compute next_off and later pointer writes without validation, enabling further OOB when malformed.",
        "Uses pkcs11_ref.size (from untrusted header) to compute next_off and advance parsing pointer; a crafted size can cause out-of-bounds advancement or TEE_Panic.",
        "Uses pkcs11_ref.size (from untrusted bytes) in next_off arithmetic (cur += next_off), enabling out-of-bounds/oversize traversal if manipulated",
        "Uses pkcs11_ref.size (from untrusted blob) in next_off arithmetic enabling out-of-bounds traversal if manipulated.",
        "Uses untrusted pkcs11_ref.size to compute next_off and advance cur without validating remaining buffer length first.",
        "Computes next_off = sizeof(pkcs11_ref) + pkcs11_ref.size where pkcs11_ref.size is from parsed buffer; a crafted size could cause loop misbehavior or overflow.",
        "Computed next_off uses pkcs11_ref.size from parsed header; a crafted size may cause loop misbehavior or arithmetic overflow leading to out-of-bounds.",
        "pkcs11_ref.size (from serialized data) is used to compute next_off without validating it against remaining buffer, enabling loop-control manipulation.",
        "pkcs11_ref.size from the copied header is used to compute next_off and advance 'cur' without sanitizing size; malformed sizes can corrupt loop bounds and subsequent pointer math.",
        "Uses pkcs11_ref.size (from untrusted data) to compute next_off for loop advancement without validating that next_off keeps cur within bounds.",
        "Uses pkcs11_ref.size (from untrusted input) to compute next_off without validating it keeps cur within bounds, enabling overflow/panic."
      ],
      "code_excerpts": [
        "next_off = sizeof(pkcs11_ref) + pkcs11_ref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=next_off,src_sz=head->attrs_size,dst_sz=unknown",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=sizeof(pkcs11_ref)+pkcs11_ref.size,src_sz=head->attrs_size,dst_sz=unknown",
          "dst_region:TEE-private",
          "size_triplet:copy_len=pkcs11_ref.size,src_sz=head->attrs_size,dst_sz=unknown",
          "flow_dir:REE->TA",
          "src_region:unknown",
          "size_triplet:copy_len=next_off,src_sz=pkcs11_ref.size,dst_sz=head->attrs_size",
          "size_triplet:copy_len=next_off,src_sz=pkcs11_ref.size,dst_sz=(end-cur)",
          "src_region:REE-visible",
          "size_triplet:copy_len=next_off,src_sz=pkcs11_ref.size,dst_sz=end - cur",
          "size_triplet:copy_len=next_off,src_sz=pkcs11_ref.size,dst_sz=head->attrs_size - (cur - ((char*)head + sizeof(struct obj_attrs)))",
          "size_triplet:copy_len=next_off,src_sz=pkcs11_ref.size + sizeof(pkcs11_ref),dst_sz=end - cur"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0015",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 130,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "=",
        "unknown"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Writes out pointers into the serialized buffer (cur + sizeof(pkcs11_ref)) into caller-provided attr array; these pointers alias into head's memory",
        "Writes out pointers into caller-provided attr array pointing inside serialized blob; these alias into head's memory and rely on head being well-formed",
        "Assigns out pointers into regions computed from cur (cur + sizeof(pkcs11_ref)), exposing pointers into internal attribute storage to the caller via attr.",
        "Assigns pointers into internal attribute storage to out-parameters (attr), exposing internal pointers to callers in TA context.",
        "Out-parameters 'attr' and 'attr_size' are populated with pointers/sizes derived from head; these pointers later escape to callers.",
        "assigns pointers (cur + sizeof(pkcs11_ref)) into output attr array when pkcs11_ref.size claimed by head may be attacker-controlled",
        "Writes pointers into attr/attr_size arrays based on cur + sizeof(pkcs11_ref) where cur is derived from head (caller-controlled); resulting pointers may point into untrusted regions.",
        "Populates attr_size out-entries from pkcs11_ref.size which later callers use for bounds checks; correctness depends on pkcs11_ref.size integrity",
        "Assigns pointers into attribute storage (cur + sizeof(pkcs11_ref)) into caller-supplied array without verifying overall array capacity (max_found), potential write-past of attr buffer.",
        "Assigns pointers into attribute storage into caller-supplied array attr_ptr without explicit verification of caller-supplied array capacity (max_found).",
        "assigns pointers into head buffer (possibly shared) into caller-provided attr array without verifying that resulting pointers are safe or canonical",
        "Assigns pointers into parsed head buffer into caller-provided attr array without validating that resulting pointers are within bounds or originate from safe memory."
      ],
      "code_excerpts": [
        "*attr_ptr++ = cur + sizeof(pkcs11_ref);",
        "if (attr) { if (pkcs11_ref.size) *attr_ptr++ = cur + sizeof(pkcs11_ref); else *attr_ptr++ = NULL; } if (attr_size) *attr_size_ptr++ = pkcs11_ref.size;",
        "if (attr) { if (pkcs11_ref.size) *attr_ptr++ = cur + sizeof(pkcs11_ref); else *attr_ptr++ = NULL; }",
        "*attr_ptr++ = cur + sizeof(pkcs11_ref); *attr_size_ptr++ = pkcs11_ref.size;",
        "if (attr_size) *attr_size_ptr++ = pkcs11_ref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(void*),src_sz=pkcs11_ref.size,dst_sz=unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=pointer_size,src_sz=pkcs11_ref.size,dst_sz=unknown",
          "dst_region:unknown",
          "size_triplet:copy_len=pointer,src_sz=pkcs11_ref.size,dst_sz=pointer",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=NA,src_sz=head->attrs_size,dst_sz=NA",
          "size_triplet:copy_len=pointer_writes,src_sz=head->attrs_size,dst_sz=*count",
          "flow_dir:TEE->TEE-private",
          "size_triplet:copy_len=sizeof(uint32_t) entries,src_sz=head->attrs_size,dst_sz=number_of_matches",
          "size_triplet:copy_len=pointer_size,src_sz=pkcs11_ref.size,dst_sz=max_found",
          "src_region:unknown",
          "size_triplet:copy_len=pointer_write,src_sz=pkcs11_ref.size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0016",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 131,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Writes pointers into caller-provided 'attr' array pointing into serialized attribute payload (exposes TEE-private addresses/content to caller context within TA flow).",
        "Writes pointers into caller-provided attr array pointing into serialized payload; relies on pkcs11_ref.size and offsets computed earlier.",
        "Assigns pointers into the serialized attribute buffer (cur + sizeof(pkcs11_ref)) into attr array; these pointers alias into head's memory",
        "Assigns pointers into the serialized attribute buffer into attr array; these pointers alias into head's memory and may point into attacker-controlled serialized data",
        "Stores pointers (cur + sizeof(pkcs11_ref)) into caller-supplied attr array; if head is REE-originated these pointers reference shared memory",
        "Assigns pointers into the attributes blob (cur + sizeof(pkcs11_ref)) into caller-supplied attr array; these pointers alias into template-derived memory",
        "Assigns pointers into the attributes blob (cur + sizeof(pkcs11_ref)) into caller-supplied attr array; these pointers alias into template-derived memory."
      ],
      "code_excerpts": [
        "*attr_ptr++ = cur + sizeof(pkcs11_ref);",
        "if (pkcs11_ref.size) *attr_ptr++ = cur + sizeof(pkcs11_ref); else *attr_ptr++ = NULL;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TEE->TEE",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(void*),src_sz=pkcs11_ref.size,dst_sz=*count (max_found)",
          "flow_dir:TA->TA",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=pkcs11_ref.size,src_sz=head->attrs_size,dst_sz=*count",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=pointer,src_sz=pkcs11_ref.size,dst_sz=sizeof(void*)",
          "size_triplet:copy_len=pointer,src_sz=pkcs11_ref.size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0017",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 132,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Stores pointers into attr array that point inside the head buffer (cur + sizeof(pkcs11_ref)); these pointers may reference shared/REE-originated memory.",
        "Stores pointers into attr array that point inside the head buffer; these may reference REE-originated memory."
      ],
      "code_excerpts": [
        "*attr_ptr++ = cur + sizeof(pkcs11_ref);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=pointer,src_sz=pkcs11_ref.size,dst_sz=sizeof(void*)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0018",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 137,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Writes attribute sizes (pkcs11_ref.size) into caller-provided attr_size array; sizes derived from serialized data affect downstream bounds checks and copies",
        "Writes attribute sizes (pkcs11_ref.size) into caller attr_size array; sizes originate from untrusted attribute metadata",
        "Writes attribute sizes (pkcs11_ref.size) into caller attr_size array; sizes originate from untrusted attribute metadata."
      ],
      "code_excerpts": [
        "*attr_size_ptr++ = pkcs11_ref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=pkcs11_ref.size,dst_sz=unknown",
          "flow_dir:REE->TA",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=sizeof(uint32_t)",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0019",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 145,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "If cur > end the code calls TEE_Panic(0) indicating detection of malformed attributes; this is an abort-path rather than graceful error handling.",
        "If cur > end the code calls TEE_Panic(0); this is an abort-path rather than graceful error handling and may be triggered by malformed attributes.",
        "Post-loop check panics if cur > end, indicating reliance on header sizes for memory safety; malformed attrs_size can trigger TEE_Panic.",
        "If cur advances past end the code TEE_Panic(0) (hard failure) is invoked; this is a defensive check but results in panic rather than graceful error handling.",
        "If parsing overruns end the code calls TEE_Panic(0), which is a hard failure rather than graceful handling.",
        "Advancing cur by attacker-controlled next_off can exceed end; code panics via TEE_Panic if cur > end rather than safely returning an error.",
        "Advancing cur by attacker-controlled next_off can exceed end; code panics via TEE_Panic if cur > end rather than returning an error.",
        "If parsing overruns end, code calls TEE_Panic which aborts execution; this is a hard failure on malformed data.",
        "If parsing overruns end the code calls TEE_Panic(0) which is a hard failure on malformed data.",
        "function panics if cur > end (TEE_Panic) which can be triggered by malformed pkcs11_ref.size from untrusted input",
        "Function calls TEE_Panic if cur > end, which is triggered by malformed sizes from untrusted input; this is a denial-of-service risk.",
        "If parsed next_off causes cur to advance beyond end, code panics (TEE_Panic), creating denial-of-service on malformed input",
        "If parsed next_off causes cur to advance beyond end, code calls TEE_Panic causing denial-of-service on malformed input.",
        "detects cur > end and calls TEE_Panic; malicious head->attrs_size or pkcs11_ref.size can trigger panic or OOB before this check",
        "cur > end check causes TEE_Panic; malformed sizes can trigger panic or OOB before this check.",
        "If parsed next_off causes cur to exceed end the code calls TEE_Panic; lack of graceful handling of malformed head is a structural risk",
        "function panics if cur > end, indicating a structural risk when parsing untrusted serialized attributes",
        "Function calls TEE_Panic if parsing advances past end, indicating fragile handling of malformed input.",
        "if parsing overruns (cur > end) code calls TEE_Panic, indicating lack of graceful handling for malformed REE-provided data",
        "If parsing overruns, function calls TEE_Panic(0) which is a denial-of-service risk when fed malformed lengths from head.",
        "When parsing overruns are detected callers invoke TEE_Panic after detecting cur > end which is a denial-of-service path if memmove reads malformed lengths.",
        "On parse overrun the code calls TEE_Panic(0), which is a denial-of-service risk when fed malformed lengths from head.",
        "If pkcs11_ref.size is crafted large, next_off may advance cur past end triggering TEE_Panic; this is a structural risk from untrusted length fields",
        "If next_off pushes cur past end the function calls TEE_Panic; parsing of untrusted lengths is a structural risk.",
        "Panics if parsing advances past end (cur > end); malformed or crafted pkcs11_ref.size can trigger panic (availability risk)",
        "Computes next_off from untrusted pkcs11_ref.size and advances cur by next_off; if next_off causes cur > end the code panics (TEE_Panic), indicating insufficient validation"
      ],
      "code_excerpts": [
        "if (cur > end) { DMSG(\"Exceeding serial object length\"); TEE_Panic(0); }",
        "next_off = sizeof(pkcs11_ref) + pkcs11_ref.size; ... if (cur > end) { TEE_Panic(0); }"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=head->attrs_size,dst_sz=0",
          "flow_dir:unknown",
          "dst_region:unknown",
          "size_triplet:copy_len=unknown,src_sz=head->attrs_size,dst_sz=unknown",
          "flow_dir:REE->TA",
          "src_region:unknown",
          "size_triplet:copy_len=next_off,src_sz=pkcs11_ref.size,dst_sz=head->attrs_size",
          "size_triplet:copy_len=NA,src_sz=head->attrs_size,dst_sz=NA",
          "src_region:REE-visible",
          "size_triplet:copy_len=next_off,src_sz=end - cur,dst_sz=NA",
          "size_triplet:copy_len=next_off,src_sz=head->attrs_size,dst_sz=unknown",
          "size_triplet:copy_len=unknown,src_sz=head->attrs_size,dst_sz=0",
          "size_triplet:copy_len=unknown,src_sz=head->attrs_size,dst_sz=next_off"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0020",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 150,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "unknown",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Function returns pointers/size values (attr_ptr/attr_size) that alias into attribute storage derived from REE data; downstream copies use these values for memmoves and must be bounds-checked.",
        "Updates caller-provided count with number of matches found; caller logic depends on this count for further decisions"
      ],
      "code_excerpts": [
        "get_attribute_ptrs populates attr and attr_size arrays with pointers/sizes into serialized attributes.",
        "*count = found;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=found,src_sz=head->attrs_size,dst_sz=unknown",
          "flow_dir:TA->TA",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(size_t),src_sz=unknown,dst_sz=sizeof(size_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0021",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 156,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptr"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding callee 'head' to caller-provided object attributes; attributes are TA-managed metadata (treated as TEE-private).",
        "Binding callee 'attr_ptr' to caller pointer; attr_ptr is set to point into attribute storage (TEE-private) and later used by callers.",
        "Binding callee 'attr_size' to caller pointer; attr_size is updated with attribute size and used for bounds checks by callers.",
        "Call-site binding: 'head' parameter aliases callers' object attributes (origin TEE-private object state).",
        "Call-site binding: 'attr_ptr' is an out-parameter that will receive a pointer into attribute storage; caller supplied pointer origin varies (caller stack or variable).",
        "Call-site binding: 'attr_size' is caller-provided size pointer used to return attribute size; its value influences downstream buffer checks."
      ],
      "code_excerpts": [
        "get_attribute_ptrs(head, attribute, attr_ptr, attr_size, &count);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=sizeof(void*)",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=sizeof(uint32_t)",
          "dst_region:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=pointer,src_sz=unknown,dst_sz=pointer",
          "src_region:unknown",
          "size_triplet:copy_len=4,src_sz=unknown,dst_sz=4"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0022",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 160,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "get_attribute_ptr"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Relies on get_attribute_ptrs to validate attribute existence and pointer integrity; only checks count and rc but does not further validate attr_ptr contents or size semantics",
        "Function trusts get_attribute_ptrs to produce a single valid pointer/count and uses count checks to decide; malformed attr lists may bypass expectations.",
        "Returns NOT_FOUND when count==0 and GENERAL_ERROR when count!=1; callers depend on these semantics for control flow",
        "Relies on count returned by helper; if helper returns unexpected sizes or multiple entries, function returns GENERAL_ERROR but does not sanitize pointer contents further."
      ],
      "code_excerpts": [
        "if (!count) return PKCS11_RV_NOT_FOUND; if (count != 1) return PKCS11_CKR_GENERAL_ERROR;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA",
          "src_region:TEE-private",
          "dst_region:unknown",
          "size_triplet:copy_len=count,src_sz=unknown,dst_sz=1",
          "size_triplet:copy_len=sizeof(count),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=1,src_sz=unknown,dst_sz=1"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0023",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 180,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "get_attribute",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "=",
        "unknown"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding callee 'attr_size' to caller pointer (e.g., &size in callers); used for bounds check and updated on return.",
        "Call-site binding: callee parameter 'attr_size' is caller stack (&size) used for bounds check and updated by callee.",
        "Call-site binding: callee 'attr_size' parameter aliases caller local &size; used for bounds check and updated on buffer-too-small return.",
        "Call-site binding: attr_size pointer aliases caller-provided size (e.g., &size in caller); used to check and report required size back to caller.",
        "Call-site binding: 'attr_size' parameter points to caller's size variable (used for buffer sizing information)",
        "Relies on get_attribute_ptr to provide correct size; only checks caller's provided attr_size against size but does not validate attr_ptr provenance/format.",
        "Binding: 'attr_size' is caller-provided length pointer; it is read and may be updated with required size causing control flow (BUFFER_TOO_SMALL path).",
        "Length 'size' returned by get_attribute_ptr is used to control the copy; its provenance affects safety of the move."
      ],
      "code_excerpts": [
        "if (attr_size && *attr_size < size) { *attr_size = size; return PKCS11_CKR_BUFFER_TOO_SMALL; }",
        "rc = get_attribute(head, attribute, &bbool, &size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=sizeof(uint32_t)",
          "flow_dir:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=0,src_sz=size,dst_sz=sizeof(uint32_t)",
          "src_region:unknown",
          "flow_dir:TA->TA",
          "dst_region:unknown",
          "size_triplet:copy_len=4,src_sz=unknown,dst_sz=4",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=sizeof(uint32_t)",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=*attr_size",
          "size_triplet:copy_len=0,src_sz=size,dst_sz=*attr_size",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=*attr_size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0024",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 186,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "get_attribute",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "=",
        "unknown"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies 'size' bytes from attr_ptr into caller buffer 'attr' via TEE_MemMove; attr_ptr provenance depends on get_attribute_ptr and size-driven copy could overwrite if callers misreport attr_size (handled above).",
        "TEE_MemMove copies 'size' bytes from attr_ptr into attr; relies on earlier attr_size check when attr_size provided.",
        "Copies attribute bytes from attr_ptr into caller buffer via TEE_MemMove; safety relies on prior attr_size check which is conditional (attr_size may be NULL).",
        "Copies 'size' bytes from attr_ptr into caller buffer via TEE_MemMove after a size check; if attr_ptr refers to untrusted/shared memory or size is attacker-influenced, this may expose data or cause overflow if checks bypassed.",
        "Internal copy: TEE_MemMove(attr, attr_ptr, size) moves attribute bytes from stored attribute pointer into caller buffer.",
        "Binding callee 'attr' to caller buffer (e.g., &bbool in callers); attr is written via TEE_MemMove from attr_ptr.",
        "TEE_MemMove copies attribute data from attr_ptr (object storage) into caller buffer 'attr'; attr_ptr is TEE-side attribute storage, attr may be TA-local or caller-provided buffer.",
        "TEE_MemMove copies 'size' bytes from attr_ptr into attr when attr is non-null; attr_ptr provenance not strongly validated here beyond get_attribute_ptr's rc",
        "Copies attribute value from attr_ptr into caller buffer attr (e.g., &bbool); attr_ptr provenance comes from get_attribute_ptrs and may point to TA or earlier REE-derived memory",
        "Copies attribute value from attr_ptr into caller buffer attr; attr_ptr provenance stems from parsed data and depends on get_attribute_ptrs correctness.",
        "TEE_MemMove copies 'size' bytes from attr_ptr into attr; if attr points to caller-controlled shared memory, this performs a write into caller region (bounds checked via attr_size).",
        "TEE_MemMove copies 'size' bytes from attr_ptr into attr; size originates from get_attribute_ptr (caller-derived data) and could be attacker-influenced if attr_ptr points into REE-origin data",
        "Call-site binding: callee parameter 'attr' is caller stack (&bbool) passed to be written by get_attribute (TA-local buffer).",
        "Copies from attr_ptr (origin determined by get_attribute_ptr) into provided buffer; attr_ptr origin and size must be trusted/validated upstream.",
        "Copies attribute data from attr_ptr into caller-provided buffer 'attr' via TEE_MemMove; if callers pass a REE-visible buffer elsewhere, this is a TA->REE copy vector.",
        "TEE_MemMove copies attribute bytes from attr_ptr (derived from object attrs) into caller buffer 'attr'; attr_ptr content origin may be TA-private object data.",
        "Relies on get_attribute_ptr to return correct size and pointer; if get_attribute_ptr is influenced, callers may receive unexpected attribute data.",
        "copies size bytes from attr_ptr into attr via TEE_MemMove where size is derived from get_attribute_ptr; limited bounds check only compares caller-provided *attr_size and may not validate attr_ptr provenance",
        "Copies attribute payload into caller buffer where size originates from attribute metadata; insufficient provenance checks may allow buffer-too-small conditions upstream.",
        "Copies 'size' bytes from attr_ptr into caller buffer attr; size originates from stored attribute metadata and attr pointer provenance may be untrusted if caller passed REE-visible buffer",
        "copies size bytes from attr_ptr into caller buffer attr via TEE_MemMove relying on get_attribute_ptr-provided size without revalidating attr_ptr or that size matches caller buffer",
        "Copies size bytes from attr_ptr into caller buffer attr after size determined by metadata from get_attribute_ptr; attr_ptr provenance may be untrusted and size validation relies on attr_size check only",
        "TEE_MemMove copies 'size' bytes from attr_ptr into attr relying on prior attr_size check; if attr_size is NULL or attr not large enough this can cause overflow",
        "Call-site binding: 'attr' (destination) at this call is &bbool from caller (TA-local buffer)",
        "Copies size bytes from attr_ptr into attr without validating attr_ptr provenance or ensuring size is bounded by caller buffers beyond attr_size check",
        "copies size bytes from attr_ptr (derived from head, possibly REE-supplied) into attr without additional validation of attr_ptr provenance; relies on earlier size check which may be manipulated",
        "Copies attribute payload of size 'size' derived from head into caller buffer; relies on prior size checks.",
        "Copies attribute bytes from attr_ptr (sourced from head via get_attribute_ptr) into caller buffer 'attr'; attr_ptr may originate from REE-parsed data.",
        "Copies attribute bytes from attr_ptr (may point into REE-origin parsed buffer) into caller buffer 'attr'.",
        "Copies attribute bytes from attr_ptr into caller buffer attr via TEE_MemMove; if attr points to REE-visible memory this writes into shared memory",
        "Binding: 'attr' is destination pointer supplied by caller (often &boolval or &key_length) and will receive size bytes from attr_ptr via TEE_MemMove.",
        "Copies attribute payload from attr_ptr into caller buffer 'attr' using size from attr metadata; correctness depends on get_attribute_ptr's validation of attr_ptr/size",
        "Copies attribute payload from attr_ptr to attr via TEE_MemMove; relies on prior size check to avoid overflow.",
        "TEE_MemMove copies 'size' bytes from attr_ptr into attr; size originates from get_attribute_ptr and attr_ptr region is not validated, so upstream input validation is weak.",
        "General copy site where size is derived from get_attribute_ptr; callers must supply correct attr_size to avoid buffer issues.",
        "Copies 'size' bytes from attr_ptr into caller buffer; size is derived from metadata and relies on get_attribute_ptr correctness.",
        "TEE_MemMove performs raw memory copy using caller-provided size 'size' without validating attr_ptr provenance or ensuring dest buffer capacity here.",
        "Generic memory copy can write into REE-visible buffers if callers pass shared memrefs as dest; potential shared-memory overwrite depending on caller context",
        "Copies attribute bytes from attr_ptr into caller buffer attr via TEE_MemMove; if caller supplies a REE-visible destination this writes into shared memory.",
        "Generic memory copy can write into REE-visible buffers if callers pass shared memrefs as dest; potential shared-memory overwrite depending on caller context."
      ],
      "code_excerpts": [
        "if (attr)\n    TEE_MemMove(attr, attr_ptr, size);",
        "if (attr) TEE_MemMove(attr, attr_ptr, size);",
        "TEE_MemMove(attr, attr_ptr, size);",
        "rc = get_attribute(head, attribute, &bbool, &size);",
        "rc = get_attribute_ptr(head, attribute, &attr_ptr, &size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=*attr_size",
          "flow_dir:unknown",
          "flow_dir:TEE->TEE",
          "sensitivity_label:private",
          "src_region:unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=(attr_size?*attr_size:unknown)",
          "flow_dir:TA->unknown",
          "dst_region:unknown",
          "flow_dir:REE->TA",
          "sensitivity_label:public",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=(*attr_size before call)",
          "flow_dir:TA->REE",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=(attr_size?*attr_size:size)",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=attr_size?*attr_size:unknown",
          "src_region:REE-visible",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=*attr_size_or_unknown",
          "flow_dir:TA->TEE-private",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=*attr_size (caller-provided)",
          "dst_region:REE-visible",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=attr_size ? *attr_size : unknown",
          "flow_dir:TEE->TEE-private",
          "flow_dir:TEE-private",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=*attr_size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0025",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 187,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "get_attribute",
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: attr buffer (dst) is written from attr_ptr (src) with size 'size'; attr/attr_ptr provenance comes from caller-managed structures",
        "Copies attribute value from attr_ptr into attr buffer; attr_ptr provenance may be REE-derived",
        "Copies attribute value into attr buffer from attr_ptr; binding shows src may originate from obj blob and dst may be TA-managed buffer.",
        "Copies attribute value into provided attr buffer from attr_ptr; origin and size of attr_ptr may be TA or REE-controlled (uncertain)",
        "copies attribute data from attr_ptr into attr buffer using size parameter; origin and bounds of attr/attr_ptr depend on upstream parsing",
        "Binding: 'attr' destination pointer provided by caller (TA-private target for attribute data)",
        "Copies 'size' bytes from attr_ptr (which may point into parsed/unchecked input) into attr without validating bounds",
        "Copies attribute bytes from attr_ptr (possibly REE-derived) into attr buffer pointer provided by caller; bind src provenance",
        "Copies attribute bytes from internal attr_ptr into caller buffer 'attr' using size determined by attribute metadata; attr is caller-provided and must be trusted for capacity checks performed earlier.",
        "Copies attribute bytes from internal attr_ptr into caller buffer using size determined by metadata; relies on earlier size checks.",
        "Copies attribute payload pointed by attr_ptr into caller-provided buffer 'attr'; relies on prior attr_size check to avoid overflow.",
        "Copies attribute payload from attr_ptr (may point into serialized/REE-controlled area) into caller buffer 'attr'; safety relies on prior attr_size checks at caller.",
        "Copies attribute payload into caller buffer; relies on caller-provided attr_size checks to avoid overflow.",
        "Copies attribute value from attr_ptr (pointer into serialized region) into caller buffer attr; attr_size is used as bound and may be influenced by serialized data",
        "Copies attribute payload from attr_ptr (pointer returned by get_attribute_ptrs) into caller buffer 'attr'; attr_ptr may alias TA storage that was populated from REE-origin data",
        "Copies attribute bytes from attr_ptr into caller-provided buffer 'attr' via TEE_MemMove; destination origin may be REE-visible leading to shared-write risk.",
        "Copies attribute bytes from attr_ptr into caller-provided buffer via TEE_MemMove; destination may be caller-controlled REE-visible buffer leading to possible info disclosure later.",
        "Caller-provided buffer 'attr' (could be caller stack or caller-supplied) is written from attr_ptr via TEE_MemMove; origin of attr in callers varies.",
        "Copies attribute data from attr_ptr (object storage) into caller buffer 'attr'; destination is caller-provided and may vary (TA-local or caller-managed), affecting exposure.",
        "Copies attribute data from attribute storage into caller buffer; downstream exposures possible if attributes contain sensitive values and are later copied to REE.",
        "TEE_MemMove copies attribute data from attr_ptr into caller-supplied buffer 'attr'; destination size is checked earlier but copy uses 'size' determined by get_attribute_ptr",
        "Copies attribute payload from attr_ptr (inside serialized object) into caller-supplied buffer 'attr'; attr and attr_size were previously checked for size but copy length is derived from parsed size.",
        "Copies 'size' bytes from attr_ptr into caller buffer 'attr'; destination may be caller stack or shared memory depending on caller.",
        "Copies 'size' bytes from attr_ptr into caller-provided attr; size originates from get_attribute_ptr and may reflect unvalidated data-derived size.",
        "Copies 'size' bytes from attr_ptr into attr; size comes from get_attribute_ptr (which may be derived from unvalidated serialized data).",
        "Call-site binding: dest 'attr' may be caller buffer (could be TA-local or caller-provided) receiving attribute bytes from attr_ptr (pointer into TA-private storage).",
        "Copies attribute value from attr_ptr (internal attribute storage) into caller-supplied buffer 'attr' (TA-local buffer in this call-site); relies on prior size checks but src length drives copy.",
        "Copies attribute payload into caller-provided buffer 'attr' using size from attribute metadata; destination is caller memory and size originates from attribute list",
        "Copies attribute payload into caller buffer using size from attribute metadata; relies on prior parsing correctness",
        "Copies attribute payload into caller-provided buffer 'attr' from attr_ptr; origin of attr_ptr may be REE-derived and destination region depends on caller.",
        "Copies attribute bytes from attr_ptr (object storage) into caller buffer 'attr'; attr may be caller-provided and thus the copy can expose TA-held data if attr is REE-visible.",
        "Copies attribute bytes from object storage into caller buffer; if caller buffer is REE-visible this can disclose TA-held data.",
        "Copies attribute bytes from attr_ptr (points into head) into caller buffer; size is derived from attr metadata and may be larger than caller buffer if not validated by caller.",
        "Copies attribute payload from attr_ptr into caller buffer 'attr' using size from metadata; caller previously relied on get_attribute_ptr for size",
        "Copies 'size' bytes from attr_ptr (pointer into attribute storage) into caller buffer attr; relies on upstream attr_size checks to be correct",
        "Copies 'size' bytes from attr_ptr (pointer derived from head contents) into caller buffer attr; size originates from metadata and may be untrusted",
        "Copies attribute payload into caller buffer using size from metadata without validating attr_ptr provenance and remaining buffer.",
        "Copies 'size' bytes from attr_ptr (found by parsing possibly REE-origin data) into caller buffer attr; relies on prior attr_size checks but attr may be NULL or attr_size absent leading to misuse",
        "Copies attribute payload from attr_ptr into caller-supplied attr buffer; provenance of attr_ptr depends on head/candidate (could be shared), size comes from attribute metadata",
        "copies size bytes from attr_ptr (derived from parsed head content) into caller buffer attr; relies on earlier size checks which may be manipulated and attr_ptr provenance is from head",
        "Copies attribute bytes from attr_ptr (may point into untrusted-derived region) into attr buffer without extra validation beyond size checks performed by callers.",
        "Copies attribute bytes from attr_ptr (which may point into REE-origin parsed buffer) into caller buffer 'attr'",
        "Copies attribute data from attr_ptr into caller buffer attr; if attr points to REE-visible memory this writes into shared memory",
        "Copies attribute payload from attr_ptr (TA-resident pointer into template) into caller buffer 'attr' (often TA-local); size driven by attr_ptr-derived size.",
        "Copies attribute payload from attr_ptr into caller-provided buffer attr; caller previously checked sizes but attr_ptr provenance depends on earlier lookup",
        "Copies attribute payload into caller buffer after a size check, but attr_ptr provenance depends on earlier parsing; potential issues if earlier parsing was inconsistent.",
        "Copies attribute payload from attr_ptr into caller buffer 'attr' using size from metadata; correctness depends on attr_ptr/size validated upstream",
        "Destination 'attr' is caller-provided buffer (may be TA-private or point into template); callee writes attribute payload into it.",
        "Source 'attr_ptr' is pointer into attribute storage (from get_attribute_ptrs); callee reads from TA-side storage.",
        "Copies attribute value pointers/data into caller-supplied buffer 'attr' using size from attribute metadata; destination/capacity not validated here.",
        "Copies attribute pointer(s) into caller-provided attr array (out-parameter); creates aliases to locations inside head",
        "Copies attr_ptr array into caller-supplied attr buffer using size from caller; binding writes pointers into caller memory (alias of &req_attrs in caller).",
        "Copies attribute pointers into caller-supplied buffer using size from caller; improper sizes could overwrite caller memory.",
        "Copies attribute bytes to caller-provided attr pointer; attr (destination) origin may be REE or TA depending on caller, so alias binding is uncertain",
        "Copies attribute value to caller-provided buffer; destination origin may be TA or REE and size is derived from parsed data.",
        "Copies attribute value into caller-supplied 'attr' pointer; destination origin depends on caller (may be REE-visible) — binding of callee param to caller-provided buffer",
        "Call-site binding: destination 'attr' (caller buffer) may be populated from attr_ptr data; origins depend on caller (populated pointers into head).",
        "Copies attribute pointers/content from attr_ptr into caller-provided attr destination; origin of attr_ptr may be derived from parsed buffers",
        "Copies attribute payload pointers/bytes from attr_ptr into attr buffer provided by caller; attr_ptr may alias into REE-derived buffers",
        "Writes into attr (caller-provided output pointer) data from attr_ptr (derived from parsed object), binding caller outputs to parsed buffer",
        "Copies attribute value pointer data from attr_ptr into attr buffer using size from caller; source/size may be attacker-controlled.",
        "Copies attribute data to attr (output array) from attr_ptr; binding of potential TA/REE sources into attr destination",
        "Copies 'size' bytes from attr_ptr into caller buffer 'attr' via TEE_MemMove; if pointers or size are tainted/misreported this can overwrite destination.",
        "Call-site binding: destination 'attr' aliases caller buffer (&bbool) provided by get_attribute caller.",
        "Call-site binding: source 'attr_ptr' originates from get_attribute_ptr and is used as copy source.",
        "Copies attribute bytes from attr_ptr into caller stack buffer 'attr' (both TA-private); size determined by 'size'.",
        "Binding of destination pointer 'attr' (caller buffer) into TEE_MemMove; origin is caller-local (&bbool) in this call-site and considered TEE-private.",
        "Binding of source pointer 'attr_ptr' (attribute storage) into TEE_MemMove; origin from get_attribute_ptr may be TA-managed or derived from REE-parsed data (ambiguous).",
        "Copy operation relies on prior conditional attr_size check; if attr_size is NULL caller-safety isn't enforced here (attr assumed non-NULL).",
        "destination pointer 'attr' is caller-provided buffer used as TEE_MemMove destination; may be smaller than 'size' unless caller-checked",
        "source pointer 'attr_ptr' originates from get_attribute_ptr and is copied into caller buffer; source provenance may be caller-influenced templates",
        "length parameter 'size' controls the copy and originates from get_attribute_ptr; if attacker-influenced, may cause over-read/over-write if caller's attr_size not properly checked",
        "Call-site binding: destination 'attr' aliases caller-local buffer (&bbool) which is TA-private; record binding of dst to TA-private.",
        "Destination 'attr' is a caller-local TA buffer (&bbool) receiving data via TEE_MemMove; dest is TA-private but may receive REE-influenced content",
        "Source 'attr_ptr' may alias object attribute storage that was derived from REE-provided templates; provenance REE->TA (attr content REE-influenced)",
        "Length 'size' is used to control the copy; although checked earlier, its provenance may be influenced by attribute metadata",
        "Dest parameter 'attr' aliases caller stack buffer (&bbool) which receives bytes from stored attribute; origin is TA stack (TEE-private).",
        "Src parameter 'attr_ptr' is pointer into stored attribute data (TA-owned), treated as TEE-private source for copy.",
        "Size parameter 'size' originates from attribute metadata and is used to control the copy; if incorrect it can cause overflow of dest.",
        "Copies attribute bytes from attr_ptr into caller-provided buffer 'attr' via TEE_MemMove; destination origin (caller buffer) can be TA-private or caller-controlled (ambiguous).",
        "Copies attribute bytes into caller buffer; destination origin can be TA-private or caller-controlled and attr_ptr provenance is ambiguous.",
        "Destination 'attr' is a caller-provided buffer (e.g., &bbool) bound into this helper and written via TEE_MemMove.",
        "Copies attribute data from attr_ptr (TEE-private object storage) into caller buffer 'attr'; if caller buffer aliases REE-visible memory this can expose TA data.",
        "Binding: destination pointer 'attr' at call-site may be a caller-provided buffer (e.g., &bbool or REE-origin); record origin as TEE-private for local buffers or REE-visible when caller supplies shared mem.",
        "Binding: source pointer 'attr_ptr' originates from get_attribute_ptr (object attribute storage) and is treated as TEE-private.",
        "alias of destination 'attr' bound to caller buffer (stack-local bbool in get_bool); copies from attr_ptr into caller buffer",
        "TEE_MemMove performs a raw memory copy from attr_ptr to attr; caller-side size check exists but copy uses 'size' returned by get_attribute_ptr which must be trusted",
        "Destination 'attr' is caller stack memory (TEE-private) while source 'attr_ptr' provenance is from get_attribute_ptr and may be unknown/shared; alias/binding of pointers at call-site",
        "Copies 'size' bytes from src to dst without in-function validation of src/dst regions or that dst has at least 'size' bytes (relies on caller); if caller-supplied sizes are tainted this is risky",
        "Call-site binding: destination 'attr' (&bbool) is caller memory (TA stack) and will be written by TEE_MemMove.",
        "Call-site binding: source 'attr_ptr' originates from get_attribute_ptr (attribute storage) and is read as src for the move.",
        "alias of caller-provided destination buffer (attr) passed into TEE_MemMove; destination originates from caller-local &bbool in get_bool",
        "alias of source pointer (attr_ptr) passed into TEE_MemMove; attr_ptr originates from get_attribute_ptr and its region could be TA-private or REE-visible (unknown)",
        "copies 'size' bytes from attr_ptr into attr without validating that attr_ptr points to trusted memory region; size originates from get_attribute_ptr and may be influenced by input",
        "Call-site binding: dest 'attr' is caller stack (&bbool) (TA-private) written by TEE_MemMove.",
        "Call-site binding: src 'attr_ptr' originates from get_attribute_ptr (obj attributes, TA-private).",
        "destination 'attr' is a caller-local buffer; TEE_MemMove will write up to 'size' bytes into it based on attr_ptr-derived size",
        "source 'attr_ptr' derives from get_attribute_ptr(head, ...); provenance of attr_ptr depends on head (caller-controlled), may be TA-private or unknown",
        "TEE_MemMove copies up to 'size' bytes from attr_ptr into caller buffer 'attr'; although bounds-checked, attr_ptr provenance depends on head which may be derived from REE-parsed template.",
        "Copies size bytes from attr_ptr (TA-private attribute storage) into attr (caller stack buffer) — dest and src are TA-private but size is caller-controlled.",
        "Binding of destination pointer 'attr' (caller buffer &bbool) into memmove; destination origin is caller stack (TA-private) but caller-provided size may be smaller.",
        "Binding of source pointer 'attr_ptr' into memmove; origin determined by get_attribute_ptr and may be REE-derived or TA-owned (ambiguous).",
        "Copies 'size' bytes without additional runtime sanitizer here; relies on caller to have validated attr_size vs size.",
        "Copies attribute bytes from attr_ptr into caller buffer attr; source may originate from object attributes derived from REE-provided templates",
        "Call-site binding: destination 'attr' is caller-provided buffer (here &bbool) — region is TEE-private stack at this call-site.",
        "Call-site binding: source 'attr_ptr' originates from get_attribute_ptr and may reference data derived from REE input (processed into TA memory) — record as unknown/TEE-private origin.",
        "Performs raw memory copy of 'size' bytes; if destination in other call-sites is REE-visible, this becomes TA->REE copy and may expose TA-held data.",
        "Raw memory copy of 'size' bytes; when callers pass REE-visible buffers this becomes a TA->REE copy and may expose TA data.",
        "Call-site binding: dest 'attr' is caller buffer (e.g., &bbool in get_bool) and src 'attr_ptr' is attribute storage pointer; copies size bytes from attr_ptr into attr.",
        "Copies size bytes from attr_ptr into attr; size originates from get_attribute_ptr and may reflect untrusted/unknown provenance without stronger validation of attr_ptr",
        "Call-site binding: dst (&bbool) is caller-local TA buffer, src (attr_ptr) originates from attribute storage (TA-private) returned by get_attribute_ptr",
        "copies 'size' bytes from attr_ptr (origin from get_attribute_ptr) into caller buffer attr relying on size without revalidating attr_ptr provenance",
        "Dest is caller stack buffer (&bbool, TA-local) while src attr_ptr provenance comes from get_attribute_ptr (may be REE-influenced); copy length 'size' derived from metadata",
        "Copies 'size' bytes from attr_ptr (obtained from get_attribute_ptr, potentially REE-derived) into caller buffer 'attr' relying on earlier check; if attr_size was NULL or check bypassed, destination may be undersized.",
        "Call-site binding: destination 'attr' is caller-owned buffer (&bbool) in TA stack/local",
        "Copies 'size' bytes from attr_ptr (origin resolved by get_attribute_ptr) into dest; src provenance and size bounds rely on upstream checks",
        "copies 'size' bytes from attr_ptr (derived from head, possibly REE-supplied) into caller buffer attr; size originates from get_attribute_ptr and may be attacker-controlled",
        "Performs raw copy from src to dest using size 'size' without validating provenance of src/size beyond upstream checks; if src or size are attacker-controlled this can copy unexpected data or overflow caller buffers.",
        "Call-site binding: destination 'attr' aliases caller stack buffer (&bbool) which is TA-private.",
        "Call-site binding: source 'attr_ptr' may point into data derived from 'head' (which can be REE-originated), so src region is unknown/possibly REE-visible.",
        "Copies attribute bytes from attr_ptr (sourced from parsed attributes) into caller buffer 'attr'; source likely originates from REE-parsed data.",
        "attr (caller buffer) is destination for copy from attr_ptr which was obtained from head derived from REE templates; alias binds caller dest to origin",
        "Destination 'attr' is caller-supplied buffer (often TA-local like &boolval) receiving bytes from attr_ptr which may originate from object attributes; alias/binding recorded.",
        "copies size bytes from attr_ptr (TA-internal) into caller-supplied attr buffer; binding dest to caller-local buffer",
        "copies 'size' bytes into attr without guaranteed destination bounds when attr_size is NULL or mismatched",
        "Copies attribute payload from attr_ptr (TA-private attribute storage) into caller buffer 'attr' (TA-local); correctness depends on get_attribute_ptr validation",
        "Call-site binding: dst 'attr' (caller buffer) receives data from attr_ptr within template; both are TEE-private buffers."
      ],
      "code_excerpts": [
        "TEE_MemMove(attr, attr_ptr, size);",
        "if (attr) TEE_MemMove(attr, attr_ptr, size);",
        "if (attr)\n\tTEE_MemMove(attr, attr_ptr, size);",
        "call-site: rc = get_attribute(head, attribute, &bbool, &size); -> TEE_MemMove(attr, attr_ptr, size)",
        "attr_ptr obtained via get_attribute_ptr(...) then used in TEE_MemMove"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=attr_size",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=attr_size",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "sensitivity_label:private",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=*attr_size",
          "flow_dir:TA->REE",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=(attr_size?*attr_size:unknown)",
          "flow_dir:TA->TEE",
          "flow_dir:TEE->TEE",
          "flow_dir:TEE-private->TEE-private",
          "size_triplet:copy_len=size,src_sz=pkcs11_ref.size,dst_sz=*attr_size",
          "size_triplet:copy_len=size,src_sz=head->attrs_size,dst_sz=*attr_size",
          "dst_region:REE-visible",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=(attr_size?*attr_size:size)",
          "flow_dir:TA->TEE-private",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=attr_size?*attr_size:unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=*attr_size_or_unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=attr_size ? *attr_size : unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=(*attr_size if provided)",
          "flow_dir:TEE->TEE-private",
          "size_triplet:copy_len=size,src_sz=pkcs11_ref.size,dst_sz=unknown",
          "size_triplet:copy_len=size,src_sz=pkcs11_ref.size,dst_sz=*count",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=*attr_size (caller-controlled)",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=*attr_size",
          "flow_dir:TA->unknown",
          "sensitivity_label:secret",
          "size_triplet:copy_len=size,src_sz=pkcs11_ref.size,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=sizeof(bbool)",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=unknown",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(bbool),src_sz=unknown,dst_sz=sizeof(bbool)",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=*attr_size /* initially sizeof(bbool) */",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=(caller_provided)",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=*attr_size or size",
          "size_triplet:copy_len=sizeof(bbool),src_sz=size,dst_sz=*attr_size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0026",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 220,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "modify_attributes_list",
        "get_attribute",
        "get_attribute / check loop"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "=",
        "unknown"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Reads client-provided attribute header into local cli_head via memmove; source may be REE-visible",
        "parses lengths from head->attrs_size and cli_head.size to bound loop and compute len without strong validation of attrs_size/cli_head.size",
        "copies cli_head from cur and then uses cli_head.size to compute len; size derived from memory without extra validation",
        "Parses cli_head from cur and uses cli_head.size to compute len without strong validation of cli_head.size relative to remaining buffer.",
        "Copies header from cur via TEE_MemMove without verifying remaining bytes; header.size influences subsequent parsing",
        "Copies cli_head from cur without explicit remaining-bytes check; cli_head.size then used to advance and parse entries.",
        "Copies cli_head from cur for parsing; subsequent len uses cli_head.size to advance parsing pointer.",
        "Copies client-supplied serialized attribute header into cli_head; source comes from cur computed from head and can affect next length computations",
        "Copies cli_head from 'cur' into local structure; source is parsed serialized data so origin may be untrusted.",
        "Copies cli_head from cur then uses cli_head.size to compute len without validating cli_head.size bounds",
        "Copies cli_head from cur and then uses cli_head.size to compute len without additional validation; malformed size could affect subsequent reads.",
        "Copies cli_head from cur into local header; subsequent use of cli_head.size influences loop offsets and pointer arithmetic based on possibly untrusted data.",
        "Copies cli_head from cur (parsed bytes) into local structure and then uses cli_head.size to compute len without explicit validation against remaining buffer",
        "Reads cli_head header from cur (head buffer) into local cli_head using sizeof(cli_head) without revalidating remaining bytes",
        "Copies cli_head header from cur (from head buffer) into local struct and then uses cli_head.size to advance/size entries without validating bounds",
        "Copies cli_head from cur (parsed from head) into local structure using sizeof without explicit remaining-bytes check beyond loop bounds",
        "Copies cli_head from 'cur' (untrusted) into local cli_head and then uses cli_head.size for length calculations without explicit validation",
        "Copies cli_head from cur and then uses cli_head.size to compute len; trusting unvalidated size field from blob can lead to out-of-bounds",
        "Copies client-supplied attribute header from template into local cli_head; source may be REE-derived template memory.",
        "Copies cli_head from cur and uses cli_head.size to set len without validating remaining bytes",
        "Destination &cli_head is local stack; memmove writes parsed header into local struct.",
        "Source 'cur' reads from template buffer; parsed size influences subsequent logic.",
        "Copies cli_head from cur into local struct without explicit check that remaining bytes >= header size.",
        "Reads cli_head from cur (refers to serialized client data) without per-entry pre-checks; cli_head.size used to advance len.",
        "Copies client-supplied attribute header from ref location into local cli_head; used length cli_head.size influences subsequent parsing",
        "Copies client-provided attribute header bytes into local cli_head from cur; src is parsed buffer and could be attacker-controlled",
        "Copies attribute header from cur into local cli_head; cur originates from serialized buffer possibly from REE",
        "Copies client-provided header from cur into cli_head on stack; cur may be from shared buffer",
        "Copies bytes from 'cur' into local cli_head; 'cur' likely references serialized input region (unknown), destination is stack-local.",
        "Call-site binding: destination &cli_head is a stack-allocated struct receiving data from 'cur' (serialised input) which may originate from REE; dst is TA-private.",
        "Copies serial header bytes from 'cur' into local cli_head via TEE_MemMove; source 'cur' may be REE-originated serialized input (shared).",
        "Copies serial header from potentially REE-originated buffer into local cli_head; serialized input provenance may be untrusted.",
        "alias of destination '&cli_head' bound to local struct on stack; copies from 'cur' (serial buffer) into local header",
        "Copies header from serial buffer 'cur' (likely REE-originated) into TA stack-local cli_head; caller ensures len calculations but serial buffer provenance is REE-visible.",
        "Call-site copies a header from serialized input ('cur') into a local struct; source 'cur' originates from serial buffer (REE-visible) and is aliased into local TEE memory",
        "Copies serialized header from cur (likely serialized REE/TA source) into local cli_head; origin of cur may be shared or internal depending on parsing path.",
        "Copies serialized header bytes from cur (possibly REE-provided serial buffer) into local cli_head via fixed-size memcpy",
        "Call-site binding: dest '&cli_head' is local stack, src 'cur' is buffer parsed from serialized input (caller-controlled); copies fixed sizeof(cli_head).",
        "Copies sizeof(cli_head) from cur into stack cli_head where cur is derived from head (which may be REE-supplied); relies on surrounding loop bounds to be correct",
        "Copies attribute header from cur (derived from head which may be REE-supplied) relying on loop bounds; insufficient per-item validation of cli_ref.size before using it to advance len.",
        "Copies sizeof(cli_head) from cur which is derived from head buffer (client-supplied); cli_head.size later used without separate validation here",
        "reads header from cur into cli_head using sizeof(cli_head) where cur is derived from head (which may be REE-supplied); size field subsequently used to advance loop",
        "Copies header from 'cur' (parsed from head buffer) into local cli_head using fixed sizeof(cli_head) without validating remaining bytes against cli_head.size first",
        "Copies sizeof(cli_head) bytes from cur (derived from head, which may be REE-supplied) into local cli_head without additional per-field validation beyond loop bounds.",
        "Call-site binding: destination '&cli_head' is local stack structure receiving bytes from 'cur' (parsed input)",
        "copies attribute header from cur (within head derived from REE) into local cli_head and uses returned cli_head.size to advance parsing without extra validation",
        "Parses client attribute header by copying from serial buffer 'cur' into local cli_head; 'cur' originates from REE-provided serial data.",
        "Copies serialized attribute header from cur into local cli_head; dest is local stack, src is parsed buffer",
        "Copies from 'cur' (pointer into template buffer allocated from serial args which is derived from REE data) into local cli_head; source may contain REE-derived content.",
        "Copies attribute header from template (which may be derived from REE-serialized data) into local cli_head; template provenance includes REE-provided serial buffer.",
        "copies sizeof(cli_head) from cur (derived from head which may be REE-supplied) into local cli_head",
        "Reads cli_head from cur which points into parsed attribute buffer (originates from caller-supplied head/template)",
        "Call-site binding: copies into local cli_head from 'cur' (template region) on stack; source is template memory.",
        "destination &cli_head is a local/TEE-private buffer receiving data from cur (region derived from head); binding of dst to caller origin",
        "copy from cur uses sizeof(cli_head) while loop bounds use head->attrs_size; cli_head.size then used to compute len without stronger validation",
        "parses cli_head.size from unvalidated buffer and uses it to compute len and advance cur without ensuring sufficient remaining bytes for each copy.",
        "Copies header from potentially REE-influenced buffer 'cur' into TA stack cli_head; length used without verifying remaining bytes at call-site",
        "cli_head.size (from REE-derived template) is used to compute len and drive the loop without strict upper bounds validation",
        "Copies header from parsed stream without verifying remaining bytes; header.size then used to drive parsing."
      ],
      "code_excerpts": [
        "TEE_MemMove(&cli_head, cur, sizeof(cli_head));",
        "TEE_MemMove(&cli_head, cur, sizeof(cli_head)); len = sizeof(cli_head) + cli_head.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=unknown,dst_sz=sizeof(cli_head)",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=head->attrs_size,dst_sz=sizeof(cli_head)",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=end - cur,dst_sz=sizeof(cli_head)",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=end-cur,dst_sz=sizeof(cli_head)",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=cli_head.size+sizeof(cli_head),dst_sz=sizeof(cli_head)",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=(end-cur),dst_sz=sizeof(cli_head)",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=template->attrs_size,dst_sz=sizeof(cli_head)",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=len,dst_sz=sizeof(cli_head)",
          "flow_dir:REE->TEE",
          "flow_dir:REE->TEE-private",
          "size_triplet:copy_len=sizeof(cli_head)+cli_head.size,src_sz=head->attrs_size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0027",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 221,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "modify_attributes_list"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Uses cli_head.size (from unvalidated header) to compute len and advance loop, enabling OOB or infinite loop if header is malicious",
        "Uses cli_head.size to compute len and advance loop, enabling mis-parsing or OOB if header is malicious.",
        "Uses cli_head.size (from unvalidated header) to compute len and advance loop, enabling OOB or infinite loop if header is malicious.",
        "Uses cli_head.size (unvalidated) to compute loop advance 'len', enabling OOB or logic issues if malicious."
      ],
      "code_excerpts": [
        "len = sizeof(cli_head) + cli_head.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=len,src_sz=head->attrs_size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0028",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 235,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "get_bool asserts rc == PKCS11_CKR_OK after get_attribute; if get_attribute returns BUFFER_TOO_SMALL the assert can trigger, causing an availability issue."
      ],
      "code_excerpts": [
        "rc = get_attribute(head, attribute, &bbool, &size); if (rc == PKCS11_RV_NOT_FOUND) return false; assert(rc == PKCS11_CKR_OK);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0029",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 236,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool/get_attribute"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "get_bool asserts rc == OK after get_attribute; if attribute parsing originates from REE, relying on assert may be insufficient validation."
      ],
      "code_excerpts": [
        "if (rc == PKCS11_RV_NOT_FOUND) return false; assert(rc == PKCS11_CKR_OK);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=1,src_sz=unknown,dst_sz=1"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0030",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 241,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Asserts rc == OK after get_attribute; if attribute data originate from REE parsing, relying on assert may be insufficient validation.",
        "get_bool asserts on unexpected rc values (other than NOT_FOUND and OK), which could lead to TA abort if callers receive BUFFER_TOO_SMALL.",
        "get_bool asserts rc == PKCS11_CKR_OK after calling get_attribute; if get_attribute returns BUFFER_TOO_SMALL an assert can crash (DoS)."
      ],
      "code_excerpts": [
        "if (rc == PKCS11_RV_NOT_FOUND)\n    return false;\n\nassert(rc == PKCS11_CKR_OK);",
        "if (rc == PKCS11_RV_NOT_FOUND) return false; assert(rc == PKCS11_CKR_OK);",
        "rc = get_attribute(head, attribute, &bbool, &size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=1,src_sz=unknown,dst_sz=1",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(bbool),src_sz=size,dst_sz=sizeof(bbool)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0031",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 244,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "get_bool uses assert(rc == PKCS11_CKR_OK) for unexpected error codes which may abort the TA instead of graceful error handling."
      ],
      "code_excerpts": [
        "assert(rc == PKCS11_CKR_OK);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=sizeof(uint8_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0032",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 265,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "attributes_match_reference",
        "get_attribute"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies referenced attribute header into local pkcs11_ref from ref_attr which may be in REE-managed memory",
        "Copies pkcs11_ref from ref_attr (origin of ref_attr unclear); if ref_attr is attacker-controlled, header fields may be tainted.",
        "Copies pkcs11_ref from ref_attr into local pkcs11_ref; ref_attr provenance may be caller-controlled serialized data.",
        "Copies pkcs11_ref from ref_attr into local struct; ref_attr provenance may be internal or external depending on call-site (used for reference comparisons).",
        "Copies pkcs11_ref from ref_attr (external data) into local structure and uses its size fields for subsequent checks",
        "Copies pkcs11_ref header from ref_attr (reference buffer) into local pkcs11_ref; origin of ref_attr may be REE or TA-managed depending on caller",
        "Copies pkcs11_ref from ref_attr into local struct; ref_attr provenance may be untrusted and size used later without full validation",
        "Copies pkcs11_ref from ref_attr (reference data) into local pkcs11_ref without validating ref_attr length here",
        "Copies pkcs11_ref from ref_attr (source from caller) into local header for reference checks; binds callee params to caller-origin",
        "Copies serialized attribute header from ref_attr into pkcs11_ref (local); ref_attr may point into REE-origin template.",
        "Copies pkcs11_ref from ref_attr (possibly REE-origin) into local structure for further processing",
        "Destination &pkcs11_ref is local; writing ref header into stack from ref_attr source.",
        "Source 'ref_attr' is derived from caller data (possibly template/ref buffer); origin considered TEE-private here.",
        "Copies pkcs11_ref from ref->attrs without an explicit overall buffer-length check against ref->attrs_count/total bytes; malformed ref could cause out-of-bounds reads.",
        "Copies pkcs11_ref from ref_attr into local struct without validating that ref->attrs contains enough bytes for header.",
        "Copies header from ref_attr without validating that ref buffer contains enough bytes for the header.",
        "Reads attribute header from ref_attr into pkcs11_ref and then trusts pkcs11_ref.size for further operations without extra validation",
        "Copies attribute header from ref_attr into local pkcs11_ref; ref_attr provenance may be attacker-controlled",
        "Copies referenced attribute header from ref_attr into local pkcs11_ref; src may be REE-derived",
        "Copies reference header from ref_attr into local pkcs11_ref; source origin unknown (could be serialized input).",
        "Copies reference structure from ref_attr into local pkcs11_ref via TEE_MemMove; ref_attr provenance may be untrusted input.",
        "Copies reference structure from ref_attr (possibly untrusted) into local pkcs11_ref.",
        "Copies ref metadata from ref_attr into local pkcs11_ref; source may be untrusted serialized data",
        "Copies pkcs11_ref structure from ref_attr into local pkcs11_ref; origin of ref_attr is context-dependent (unknown)",
        "Copies pkcs11_ref from ref_attr (parsed data); subsequent use of pkcs11_ref.size may be attacker-controlled if not validated",
        "copies fixed-size pkcs11_ref from ref_attr into local structure; both are TA-managed in this path",
        "Copies referenced attribute header from ref_attr (parsed data) into local pkcs11_ref; ref_attr is from REE-origin serial buffer.",
        "Copies reference attribute into pkcs11_ref from ref_attr; source originates from parsed data",
        "copies sizeof(pkcs11_ref) from ref_attr into local pkcs11_ref; ref_attr provenance may be REE-derived",
        "Copies pkcs11_ref from ref_attr (pointer into parsed data) into local pkcs11_ref; source likely from parsed/REE-provided buffer",
        "Call-site binding: copies pkcs11_ref from ref_attr (likely from serialized template region) into local pkcs11_ref.",
        "destination &pkcs11_ref is local and receives bytes from ref_attr (origin region tied to head/cur)",
        "Copies reference structure from ref_attr into local pkcs11_ref; origin of ref_attr is parsed data (unknown)",
        "Copies pkcs11_ref from ref_attr using sizeof(pkcs11_ref) without an explicit overall bounds check against ref->attrs total bytes; a malformed ref can cause out-of-bounds read.",
        "Call-site binding: destination '&pkcs11_ref' is a local TA stack object (TEE-private) receiving data from ref_attr.",
        "Call-site binding: source 'ref_attr' aliases ref->attrs provided by caller (origin from req_attrs); origin considered TA-private but upstream provenance varies.",
        "Call-site bindings: ref_attr aliases ref->attrs provided by caller; pkcs11_ref is local TA storage receiving the copy."
      ],
      "code_excerpts": [
        "TEE_MemMove(&pkcs11_ref, ref_attr, sizeof(pkcs11_ref));"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=unknown,dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=pkcs11_ref.size_or_unknown,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=ref_attr_size,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=pkcs11_ref.size_or_remaining,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=pkcs11_ref.size,dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=ref->attrs_count_bytes,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=head->attrs_size,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=sizeof(pkcs11_ref),dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:REE->TEE-private",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=ref_size,dst_sz=sizeof(pkcs11_ref)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0033",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 298,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies pkcs11_ref from ref_attr (caller-supplied reference); subsequent get_attribute_ptr uses pkcs11_ref.id/size influencing control flow.",
        "Copies pkcs11_ref from ref_attr (possibly REE-originated serialized ref) into local header; ref_attr size influences subsequent attribute lookups",
        "Copies pkcs11_ref from ref_attr into local structure before using id/size to fetch attributes; malformed input can influence control flow.",
        "Copies pkcs11_ref from ref_attr prior to querying attribute pointer; the ref structure guides subsequent attribute lookup and may be attacker-influenced.",
        "Copies pkcs11_ref from ref_attr then uses pkcs11_ref.id/size to look up attributes; ref_attr provenance may be untrusted",
        "Copies pkcs11_ref from ref_attr into local struct before using its id/size; ref_attr provenance varies by caller",
        "Copies pkcs11_ref from ref_attr into local struct before using pkcs11_ref.id/size for lookups; ref_attr may be attacker-controlled",
        "Copies pkcs11_ref from ref_attr into local pkcs11_ref before using id/size to fetch attribute pointers; ref_attr provenance may be untrusted",
        "Copies pkcs11_ref from ref_attr into local struct before using its id/size to lookup attributes; source may be attacker-controlled",
        "Copies referenced attribute header from ref_attr into local pkcs11_ref prior to lookup; source origin may be untrusted serialized data.",
        "Copies pkcs11_ref header from ref_attr before using its id to query attributes; relies on integrity of ref_attr contents",
        "Destination &pkcs11_ref is local; callee writes header from ref_attr.",
        "Source 'ref_attr' originates from caller context; treated as TEE-private here.",
        "Copies header from ref_attr into pkcs11_ref and then uses its id/size for a lookup without validating ref_attr provenance",
        "Copies attribute header from ref_attr into local pkcs11_ref before further parsing; source region uncertain",
        "Copies referenced attribute header into local pkcs11_ref before resolving value; source may be untrusted",
        "Copies reference header into local pkcs11_ref; source is ref_attr (unknown origin).",
        "Copies ref metadata from ref_attr into local pkcs11_ref at alternate codepath; source provenance may be REE-visible",
        "copies fixed-size pkcs11_ref from ref_attr into local structure before lookup; origin likely TA-private",
        "Copies referenced attribute header from ref_attr into pkcs11_ref for subsequent get_attribute_ptr; source likely REE-origin.",
        "Copies reference attribute into pkcs11_ref from ref_attr (similar parsing path)",
        "copies sizeof(pkcs11_ref) from ref_attr into pkcs11_ref at another call site; binding shows ref_attr origin",
        "Copies pkcs11_ref from ref_attr into local structure before using it to index attributes; relies on validity of ref_attr/size",
        "Call-site binding: similar copy of pkcs11_ref from ref_attr into local; used to lookup attribute pointer next.",
        "destination &pkcs11_ref is local and source ref_attr derives from parsed head data",
        "Copies reference structure from ref_attr into local pkcs11_ref at another call-site; source provenance unclear"
      ],
      "code_excerpts": [
        "TEE_MemMove(&pkcs11_ref, ref_attr, sizeof(pkcs11_ref));"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=unknown,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=ref_attr_len,dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=ref_attr_size,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=pkcs11_ref.size_or_remaining,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=pkcs11_ref.size,dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=sizeof(pkcs11_ref),dst_sz=sizeof(pkcs11_ref)",
          "flow_dir:REE->TEE-private",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=ref_size,dst_sz=sizeof(pkcs11_ref)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0034",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 344,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "some_helper"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies prefix string from prefix (possibly REE-origin) into local prefix2 buffer without explicit max bound beyond prefix_len",
        "copies prefix into prefix2 using prefix_len+1; if prefix_len derived from unvalidated source this may overflow prefix2",
        "Copies prefix into preallocated buffer using prefix_len+1 provided by caller; binding of src/dst origins recorded",
        "Copies prefix string into prefix2 using prefix_len+1; must ensure prefix_len is valid to avoid overflow.",
        "Copies prefix into prefix2 using prefix_len computed elsewhere; dest buffer and prefix_len must be consistent to avoid overflow",
        "Copies prefix string into prefix2 buffer using prefix_len+1; relies on prefix_len correctness and destination sizing.",
        "Copies prefix bytes into prefix2 buffer; boundaries depend on prefix_len computed earlier — ensure prefix_len is validated before copy.",
        "Copies prefix into prefix2 (both likely TA buffers); operation appears internal and not REE-driven but still performs raw memory copy.",
        "Copies prefix bytes into prefix2 using prefix_len provided by caller; caller must ensure prefix_len bounds, otherwise memory corruption possible",
        "Copies prefix bytes into preallocated prefix2 buffer; caller must ensure prefix_len+1 fits destination to avoid overflow",
        "Copies prefix+1 bytes into prefix2 based on prefix_len computed earlier; source origin not validated here and destination sizing must be ensured by caller",
        "Copies prefix bytes into prefix2 using prefix_len+1 as length; origin/provenance of prefix is unclear and prefix2 size assumptions not shown here",
        "Copies prefix into caller-provided prefix2 buffer; dest provenance depends on caller and length calculation uses prefix_len",
        "Copies prefix bytes into prefix2 buffer; length derived from prefix_len may allow out-of-bounds if prefix_len incorrect.",
        "Copies prefix string into prefix2 buffer using prefix_len+1; depends on caller-provided prefix_len being correct",
        "Destination 'prefix2' is TA-allocated buffer; writes prefix bytes into it.",
        "Source 'prefix' is provided by caller; origin region unknown (could be REE-visible or TA-private).",
        "Copies prefix into prefix2 using prefix_len+1; destination prefix2 sized by caller must be adequate, otherwise overflow risk exists (no explicit check here).",
        "Copies prefix string into prefix2 using prefix_len derived elsewhere; origin of prefix may be caller-controlled",
        "Copies prefix bytes from prefix (unknown origin) into prefix2 buffer then writes padding; source size used in copy is prefix_len+1",
        "Copies logging prefix into prefix2 from prefix (likely TA or REE); potential read from external buffer into local buffer",
        "Copies prefix into prefix2 using prefix_len provided by caller logic; bounds depend on prefix_len check upstream.",
        "Copies prefix string into prefix2 using prefix_len+1 as length; length derived earlier and used without further upper-bound here",
        "Call-site binding: dest 'prefix2' is TA buffer, src 'prefix' may be caller or TA data; copies prefix_len+1 bytes without additional runtime bound here.",
        "Copies prefix into prefix2; both likely TA-local but length expression (prefix_len + 1) must be correct to avoid overflow",
        "copies prefix (REE-provided) into prefix2 buffer using prefix_len+1 without explicit destination-size check here",
        "Copies prefix into local buffer without visible destination-size check here.",
        "Copies prefix string into prefix2 with length prefix_len+1 where prefix may originate from earlier data; destination is TA buffer",
        "copies prefix (src) into prefix2 using prefix_len derived earlier; if prefix originates from REE, length/contents may be untrusted",
        "Copies prefix bytes into local prefix2 buffer from 'prefix' source; origin of 'prefix' may be caller/REE-provided.",
        "Copies prefix string into prefix2; destination is caller buffer and sized by caller, then modified; potential overwrite if sizes incorrect",
        "Copies prefix (source possibly caller-provided or from serial data) into prefix2 buffer; length calculation uses prefix_len which may be influenced by input.",
        "copies prefix_len+1 bytes from prefix into prefix2 (both likely TA buffers); shows direct buffer copy with computed length",
        "Copies prefix bytes within TA-local buffers (prefix2 <- prefix); uses prefix_len+1 as length, bounds depend on prefix_len correctness",
        "Call-site binding: copies prefix string into prefix2 buffer; sizes computed with prefix_len (derived earlier).",
        "destination prefix2 is local; source prefix may be from parsed data or constant, binding of src/dst at call-site",
        "Copies prefix string into prefix2 buffer using prefix_len-based size; origin of prefix may be REE-influenced"
      ],
      "code_excerpts": [
        "TEE_MemMove(prefix2, prefix, prefix_len + 1);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=prefix_len + 1,src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "src_region:unknown",
          "size_triplet:copy_len=prefix_len+1,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=prefix_len+1,src_sz=strlen(prefix),dst_sz=prefix_len+1",
          "size_triplet:copy_len=prefix_len+1,src_sz=prefix_len+1,dst_sz=unknown",
          "flow_dir:TEE->TEE",
          "sensitivity_label:public",
          "flow_dir:TA->TEE-private",
          "size_triplet:copy_len=prefix_len+1,src_sz=prefix_len+1,dst_sz=prefix2_capacity",
          "size_triplet:copy_len=prefix_len+1,src_sz=unknown,dst_sz=prefix2_size",
          "dst_region:REE-visible",
          "size_triplet:copy_len=prefix_len+1,src_sz=prefix_len+1,dst_sz=allocated_prefix2_size",
          "flow_dir:REE->TEE-private",
          "size_triplet:copy_len=prefix_len+1,src_sz=unknown,dst_sz=prefix2_capacity",
          "size_triplet:copy_len=prefix_len+1,src_sz=unknown,dst_sz=allocated_size_of_prefix2",
          "size_triplet:copy_len=prefix_len + 1,src_sz=prefix_len + 1,dst_sz=unknown",
          "size_triplet:copy_len=prefix_len+1,src_sz=unknown,dst_sz=prefix_len+1+4",
          "size_triplet:copy_len=prefix_len + 1,src_sz=prefix_len + 1,dst_sz=prefix_len + 1",
          "size_triplet:copy_len=prefix_len+1,src_sz=unknown,dst_sz=prefix_len+1",
          "flow_dir:TEE->TEE-private",
          "size_triplet:copy_len=prefix_len + 1,src_sz=unknown,dst_sz=prefix_len + 1"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0035",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 352,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "get_attribute_ptrs",
        "get_attribute / parsing",
        "check_attrs_against_modification"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Small copy of attribute bytes into local buffer using MIN(pkcs11_ref.size, sizeof(data)); src originates from attribute blob (caller-controlled).",
        "loads pkcs11_ref from cur then copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes; pkcs11_ref.size is from parsed data",
        "Copies attribute header from cur into pkcs11_ref and then small sample into local data[]; uses MIN(pkcs11_ref.size, sizeof(data)) to limit copy.",
        "Copies pkcs11_ref into local struct and then copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes into data; pkcs11_ref.size (from serialized data) controls copy length",
        "Copies header then a small sample of attribute bytes into local data[]; source is serialized object memory, destination is stack buffer, size uses MIN(parsed_size, sizeof(data)) limiting copy.",
        "Copies bytes from cur+sizeof(pkcs11_ref) into small local buffer 'data' using MIN(pkcs11_ref.size, sizeof(data)); pkcs11_ref.size originates from parsed data and parsing relies on head->attrs_size",
        "Copies into small local buffer 'data' using pkcs11_ref.size derived from parsed input; parsing assumptions may be violated by malformed attrs_size.",
        "Reads pkcs11_ref from cur into local structure; source is serialized data within head and may be malformed.",
        "Copies MIN(pkcs11_ref.size, sizeof(data)) bytes from cur+sizeof(pkcs11_ref) into local buffer; pkcs11_ref.size read from serialized stream may be maliciously large or malformed.",
        "Uses pkcs11_ref.size from serialized stream to bound a copy into a fixed-size local buffer; malformed size could cause logic errors or truncation/over-read concerns.",
        "Copies small sample bytes from cur+header into a local data[] for logging; source is TA attribute area computed from cur and pkcs11_ref.size.",
        "Copies small preview bytes from serialized attribute payload into local buffer; source pointer computed as cur + sizeof(pkcs11_ref)",
        "Copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from serialized payload into a small local buffer; relies on pkcs11_ref.size parsed from data.",
        "Copies a bounded portion of serialized data into a small local buffer using MIN; relies on parsed size.",
        "Copies small sample bytes from attribute payload into local data array using pkcs11_ref.size as bound; if pkcs11_ref.size is untrusted, MIN is used but initial header read may be malformed.",
        "Reads pkcs11_ref header from cur then copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from the following payload; header size used to bound copy but header itself came from untrusted data",
        "Copies header into pkcs11_ref from cur without rechecking remaining length; subsequent copy uses MIN(pkcs11_ref.size, sizeof(data)) but header read may be OOB",
        "Copies attribute header into local pkcs11_ref from cur (head-derived); then separately copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes into stack buffer — size driven by untrusted metadata",
        "Copies header and then up to MIN(pkcs11_ref.size, sizeof(data)) bytes from parsed buffer; pkcs11_ref.size originates from untrusted serialized data and influences copy length",
        "Copies pkcs11_ref from cur into local variable; cur is iterating over head built from caller data and size validation relies on loop bounds and pkcs11_ref.size",
        "Reads pkcs11_ref from cur via MemMove then copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from cur+sizeof(pkcs11_ref) without validating full bounds",
        "Copies small sample bytes from attribute payload into local data buffer using MIN(pkcs11_ref.size, sizeof(data)) — reads untrusted size but bounds with MIN",
        "Copies attribute header from cur into pkcs11_ref (local) while iterating template; source may be REE-derived.",
        "Copies small sample bytes from cur+sizeof(pkcs11_ref) into local buffer using MIN(pkcs11_ref.size, sizeof(data)); pkcs11_ref.size derived from untrusted data",
        "Reads pkcs11_ref from cur then copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from cur+header into data; uses untrusted size for min computation",
        "Destination &pkcs11_ref is local stack; writing header from cur.",
        "Copies MIN(pkcs11_ref.size, sizeof(data)) bytes from cur+sizeof(pkcs11_ref) into local buffer; pkcs11_ref.size originates from untrusted template bytes and used without an explicit upper-limit validation beyond MIN",
        "Reads attribute header then copies up to MIN(pkcs11_ref.size, sizeof(data)) into local buffer 'data' — copy is bounded by MIN which mitigates overflow.",
        "Reads header from cur then copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from cur+header; pkcs11_ref.size is attacker-controlled if cur is REE-derived and header/payload bounds not fully validated",
        "Copies up to MIN(pkcs11_ref.size, sizeof(data)) from cur into local buffer; pkcs11_ref.size is attacker-controlled if head is untrusted and not validated",
        "Copies pkcs11_ref.size bytes from cur into local buffer using MIN but pkcs11_ref.size itself was derived from untrusted data without prior validation.",
        "Copies small sample bytes from attribute value into local buffer using MIN(pkcs11_ref.size, sizeof(data)); pkcs11_ref.size originates from parsed header",
        "Copies bytes from attribute payload into a small local buffer 'data' using MIN(pkcs11_ref.size, sizeof(data)); pkcs11_ref.size influences copy length",
        "Reads attribute header into pkcs11_ref and then copies up to sizeof(data) bytes from following payload into local data[]; payload length is attacker-controlled via pkcs11_ref.size",
        "Copies attribute header into pkcs11_ref from cur; cur may be from serialized object (untrusted), influencing subsequent size calculations",
        "Copies pkcs11_ref header from cur into local structure; cur likely points into serialized buffer (caller-controlled).",
        "Copies pkcs11_ref header from cur into local struct, then copies following bytes into small local buffer using MIN(pkcs11_ref.size, sizeof(data)) — header-driven length used to bound second copy",
        "Copies MIN(pkcs11_ref.size, sizeof(data)) bytes from cur into local data[] using size derived from parsed pkcs11_ref; if pkcs11_ref was attacker-controlled this may under/over-run without extra checks",
        "Copies data with length derived from parsed pkcs11_ref.size; if pkcs11_ref is attacker-controlled this may lead to incorrect assumptions about available source bytes.",
        "Copies bytes using pkcs11_ref.size derived from parsed input; size origin must be validated.",
        "copies pkcs11_ref and up to MIN(pkcs11_ref.size, sizeof(data)) bytes from cur into local structures relying on pkcs11_ref.size parsed from untrusted data",
        "Copies pkcs11_ref from cur into local structure without validating that cur+sizeof(pkcs11_ref) is within bounds",
        "reads pkcs11_ref header from cur (parsing REE-derived blob) into local pkcs11_ref; subsequent use of pkcs11_ref.size influences other copies",
        "Copies pkcs11_ref from buffer 'cur' into local structure; 'cur' is parsed serial data (REE-origin).",
        "Copies pkcs11_ref from cur into local structure and then copies following bytes into local data array; sources from parsed buffer",
        "copies sizeof(pkcs11_ref) from cur into local pkcs11_ref; cur originates from parsed head (possibly REE)",
        "Copies pkcs11_ref header from cur (parsed buffer) into local pkcs11_ref; source cur originates from parsed/REE buffer",
        "Call-site binding: copies pkcs11_ref from serialized buffer 'cur' into local pkcs11_ref; source is template region.",
        "destination &pkcs11_ref local, source cur derives from head/serialized data",
        "Copies attribute header from cur into pkcs11_ref then copies data into local small buffer; cli-provided sizes drive MIN() used for copy"
      ],
      "code_excerpts": [
        "TEE_MemMove(&data[0], cur + sizeof(pkcs11_ref), MIN(pkcs11_ref.size, sizeof(data)));",
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref)); TEE_MemMove(&data[0], cur + sizeof(pkcs11_ref), MIN(pkcs11_ref.size, sizeof(data)));",
        "TEE_MemMove(&pkcs11_ref, cur, sizeof(pkcs11_ref));"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=MIN(pkcs11_ref.size, sizeof(data)),src_sz=pkcs11_ref.size,dst_sz=sizeof(data)",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=MIN(pkcs11_ref.size, sizeof(data)),src_sz=end - cur,dst_sz=sizeof(data)",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=sizeof(pkcs11_ref) then MIN(pkcs11_ref.size,sizeof(data)),src_sz=pkcs11_ref.size+sizeof(pkcs11_ref),dst_sz=sizeof(pkcs11_ref) or sizeof(data)",
          "size_triplet:copy_len=MIN(pkcs11_ref.size,sizeof(data)),src_sz=pkcs11_ref.size,dst_sz=sizeof(data)",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=head->attrs_size,dst_sz=sizeof(pkcs11_ref)",
          "sensitivity_label:private",
          "size_triplet:copy_len=MIN(pkcs11_ref.size,sizeof(data)),src_sz=head->attrs_size,dst_sz=sizeof(data)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=end - cur,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=template->attrs_size,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=unknown,dst_sz=sizeof(pkcs11_ref)",
          "size_triplet:copy_len=MIN(pkcs11_ref.size,sizeof(data)),src_sz=end - (cur+sizeof(pkcs11_ref)),dst_sz=sizeof(data)",
          "size_triplet:copy_len=MIN(pkcs11_ref.size,sizeof(data)),src_sz=end - (cur + sizeof(pkcs11_ref)),dst_sz=sizeof(data)",
          "flow_dir:REE->TEE-private",
          "size_triplet:copy_len=sizeof(pkcs11_ref),src_sz=end-cur,dst_sz=sizeof(pkcs11_ref)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0036",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 353,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "get_attribute_ptrs",
        "get_attribute_ptrs / related",
        "TEE_MemMove (callsite)",
        "TEE_MemMove (caller context)"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Extracts up to MIN(pkcs11_ref.size, sizeof(data)) bytes into small local buffer, uses MIN to limit copy",
        "Copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from serialized attribute payload into small local array; uses MIN as safeguard.",
        "Copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from serialized attribute into local buffer; length driven by pkcs11_ref.size parsed from REE-influenced data",
        "Copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from serialized attribute into local array; size derived from serialized data affects copy length.",
        "Copies payload bytes into local 'data' buffer using MIN(pkcs11_ref.size, sizeof(data)); copy length derived from untrusted header but bounded by local buffer size",
        "Copies payload into local buffer bounded by MIN(header.size, local_size) — bounded but header itself came from untrusted input.",
        "Copies attribute bytes into fixed-size local array using MIN(pkcs11_ref.size, sizeof(data)); source pointer is cur + sizeof(pkcs11_ref) (may be REE-derived)",
        "Copies attribute payload into small local buffer using MIN(pkcs11_ref.size, sizeof(data)); pkcs11_ref.size originates from untrusted header parsed earlier",
        "Copies a small amount (MIN(pkcs11_ref.size, sizeof(data))) from attribute payload into local data[]; MIN bounds used but provenance of pkcs11_ref.size is from parsed data",
        "Copies a small sample of attribute bytes from parsed buffer into local 'data' array; source may be untrusted and size is constrained by MIN(...) but provenance remains untrusted",
        "Copies few bytes of attribute data into local small buffer 'data' using MIN(pkcs11_ref.size, sizeof(data)); source size controlled by pkcs11_ref, which is untrusted.",
        "Copies attribute bytes into small local buffer using MIN(pkcs11_ref.size, sizeof(data)); pkcs11_ref.size is attacker-controlled and earlier header read may be unsafe.",
        "Destination &data[0] is local small buffer; writes up to MIN(pkcs11_ref.size, sizeof(data)) bytes from template payload.",
        "Copies up to MIN(pkcs11_ref.size, sizeof(data)) from attribute payload into local buffer; header-to-payload size relation relies on prior header validity.",
        "Copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from serialized attribute into small local array 'data' - size is attacker-controlled leading to potential info flow or truncation",
        "Copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from serialized area into local small buffer; size derived from parsed header.",
        "Copies payload bytes (cur + sizeof(pkcs11_ref)) into small local buffer using MIN(pkcs11_ref.size, sizeof(data)) to limit copy",
        "Copies MIN(pkcs11_ref.size, sizeof(data)) bytes from cur+offset into local buffer; pkcs11_ref.size comes from parsed input and must be trusted elsewhere",
        "Copies MIN(pkcs11_ref.size, sizeof(data)) bytes from cur+sizeof(pkcs11_ref) into stack buffer 'data'; pkcs11_ref.size is derived from parsed REE data and could be manipulated.",
        "Copies bytes based on parsed pkcs11_ref.size (from REE) into a fixed stack buffer; though MIN is used, pkcs11_ref parsing must be robust to avoid misinterpretation.",
        "copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from cur+sizeof(pkcs11_ref) into local data; size derived from REE-parsed header",
        "copies data governed by pkcs11_ref.size parsed from REE blob; parsing-bound size may be attacker-controlled",
        "Copies a small data fragment from serial buffer into local array 'data'; source originates from REE-provided serial stream.",
        "Copies attribute payload into local data buffer using MIN(pkcs11_ref.size, sizeof(data)); size is attacker-controlled via parsed ref",
        "copies MIN(pkcs11_ref.size, sizeof(data)) bytes from cur+sizeof(pkcs11_ref) into data; pkcs11_ref.size is derived from parsed input and may be attacker-controlled if not fully validated",
        "copies MIN(pkcs11_ref.size, sizeof(data)) bytes where pkcs11_ref.size is attacker-controlled if parsed input not validated",
        "Copies small data fragment from parsed buffer (cur + sizeof(pkcs11_ref)) into local 'data' array using MIN(pkcs11_ref.size, sizeof(data))",
        "Call-site binding: copies up to MIN(pkcs11_ref.size, sizeof(data)) bytes from template area into local data[] buffer.",
        "destination &data[0] local, source cur+sizeof(pkcs11_ref) is within parsed buffer; length MIN(pkcs11_ref.size, sizeof(data)) used",
        "Copies attribute bytes into local data[] using MIN(pkcs11_ref.size, sizeof(data)); source is parsed buffer influenced by REE"
      ],
      "code_excerpts": [
        "TEE_MemMove(&data[0], cur + sizeof(pkcs11_ref), MIN(pkcs11_ref.size, sizeof(data)));"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=MIN(pkcs11_ref.size, sizeof(data)),src_sz=pkcs11_ref.size,dst_sz=sizeof(data)",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=MIN(pkcs11_ref.size,sizeof(data)),src_sz=pkcs11_ref.size,dst_sz=sizeof(data)",
          "flow_dir:unknown",
          "src_region:unknown",
          "flow_dir:REE->TEE-private"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0037",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 366,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TA_InvokeCommandEntryPoint"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies enum rc into caller memref (REE-visible); structural binding recorded though not sensitive."
      ],
      "code_excerpts": [
        "TEE_MemMove(params[0].memref.buffer, &rc, sizeof(rc));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(rc),src_sz=sizeof(rc),dst_sz=params[0].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0038",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 435,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: copies 'ref' into local head variable; 'ref' provenance (caller buffer) not proven TEE-private",
        "Copies header struct from ref into local head via memmove; ref source may be REE-managed",
        "Copies header 'head' from ref (likely caller-provided) into local head variable; binding shows ref origin may be REE-visible.",
        "copies 'head' structure from ref into local head using sizeof(head); origin of ref may be external but is used unchecked",
        "Copies struct head from ref into local head; binds caller ref provenance to destination local variable",
        "Copies serialized object header from ref into local head via TEE_MemMove; ref provenance impacts trust (could be TA-managed or external), caller checks follow.",
        "Copies serialized head from ref into local head; if ref is attacker-controlled, head.attrs_count may be tainted and affect later logic.",
        "Copies head from ref into local head; ref length must match sizeof(head) else behavior is uncertain",
        "Copies raw header 'ref' into local 'head'; origin of 'ref' is caller-provided data (unknown provenance), so a malformed or attacker-controlled 'ref' could influence local state.",
        "Copies 'head' structure from external 'ref' into local head via fixed sizeof(head); source 'ref' may be from serialized input and not strongly validated here",
        "Copies serialized head from external ref into local head using fixed sizeof(head) without validating source size.",
        "Copies 'head' structure from ref (serialized) into local head; source serialization may be untrusted and affects attrs_count checks.",
        "Copies header 'head' from serialized ref into local head variable; ref buffer origin may be caller-provided serialized object",
        "Copies head struct from external 'ref' into local 'head' without validating origin; malformed or attacker-influenced 'ref' may affect subsequent logic.",
        "Copies head struct from ref into local head; ref provenance uncertain and head.attrs_count is used later to branch.",
        "Copies 'head' from ref (serialized header) into local head without validating ref length first",
        "Copies head struct from ref into local head via sizeof(head); ref provenance may be REE or TA-managed",
        "Copies serialized head from ref into head local via fixed-size copy; ref provenance may be untrusted and head.attrs_count used later",
        "Copies head from ref into local head via sizeof(head); ref provenance may be external and no explicit length check is visible here",
        "Copies 'head' from ref into local head; ref originates from caller-provided data and may be untrusted",
        "Copies serialized head from ref into local head via fixed-size move; if ref is attacker-controlled this aliases attacker data into head fields",
        "Copies serialized header 'head' from ref into local head variable; ref may be REE-derived leading to untrusted content in local structure.",
        "Copies head structure from ref into local 'head' using sizeof(head); correctness assumes ref contains a valid head",
        "Destination &head is local; memmove reads 'ref' into local head struct.",
        "Copies 'head' struct from ref without validating that ref points to a buffer of sufficient length before reading head.attrs_count/attrs_size.",
        "Copies into 'pre' which is set to NULL earlier; destination is invalid leading to memory-safety issue (caller misuse), origin of ref may be REE or TA",
        "Copies struct head from ref into local head and then indexes head.attrs_count; ref provenance not validated here",
        "Copies serial object head from 'ref' into local head structure; source may be untrusted buffer",
        "Copies head from ref into local head; ref likely points into serialized object buffer whose provenance is upstream",
        "Copies head structure from ref into local head; source may be serialized external data, binding untrusted src into TA-local struct",
        "Copies header from ref into local head; source 'ref' origin unknown (could be REE or TA-owned).",
        "Copies header 'head' from ref into local head via fixed-size MemMove; source ref may be untrusted",
        "Copies head from ref; origin of ref may be external and head.attrs_count used later—binding reflects potential external influence",
        "copies ref into head structure; origin of ref may be external and head used afterwards without additional validation",
        "Copies 'head' struct from ref (source unknown) into local head; origin of ref may be REE-influenced and head used to drive loops",
        "copies head structure from ref into local head; both are likely TA-managed at this call-site",
        "Copies head structure from ref pointer into local 'head'; ref likely points into REE-origin serialized attributes.",
        "Copies head from ref into local head variable; ref originates from parsed attribute list",
        "copies sizeof(head) from ref into head (binding of destination to local head from ref source)",
        "Copies 'head' structure from ref into local head variable; correctness depends on validity of ref and size of head",
        "Call-site binding: copies 'ref' into local 'head' structure; origin of 'ref' uncertain (could be REE-provided serialized data).",
        "destination &head is local and receives bytes from ref (origin tied to caller-provided head/new buffers)",
        "Copies head structure from ref (unknown provenance) into local head variable; caller-supplied ref may be untrusted"
      ],
      "code_excerpts": [
        "TEE_MemMove(&head, ref, sizeof(head));"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(head),src_sz=unknown,dst_sz=sizeof(head)",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=sizeof(head),src_sz=ref_len,dst_sz=sizeof(head)",
          "size_triplet:copy_len=sizeof(head),src_sz=ref_size,dst_sz=sizeof(head)",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:unknown",
          "size_triplet:copy_len=sizeof(head),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(head),src_sz=sizeof(head),dst_sz=sizeof(head)",
          "flow_dir:REE->TEE-private"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0039",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 447,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "get_attribute_ptrs",
        "attributes.c (debug print)",
        "attributes printing",
        "some helper",
        "TEE_MemMove (callsite)",
        "attributes parsing"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove",
        "unknown"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: copies prefix (caller-provided) into pre buffer which may be uninitialized; origin of prefix is external",
        "Copies prefix into pre buffer before logging; pre may point into TEEspace but prefix provenance uncertain",
        "Copies caller-supplied prefix into pre buffer via TEE_MemMove; origin of pre and prefix may be caller-controlled leading to potential overflow if not validated",
        "copies prefix into pre using strlen(prefix) without showing allocation of pre here; destination origin/size unclear (potential overflow)",
        "Copies prefix (caller-provided) into pre buffer before logging; records aliasing of caller buffer into local logging buffer",
        "Copies prefix string into pre buffer using strlen(prefix) without explicit check of pre capacity at this site (caller must ensure buffer is large enough).",
        "Copies prefix into pre buffer for logging; ensure pre is allocated and prefix length sane to avoid overflow or information leak to logs.",
        "Copies prefix into pre buffer (dest) using strlen(prefix) as length; origin and size of 'pre' not validated here (caller must ensure buffer large enough).",
        "Copies prefix into pre buffer using strlen(prefix); source prefix may be attacker-influenced affecting length used",
        "Copies prefix into pre buffer (dest) using strlen(prefix) length; dest origin and size must be ensured by caller (potential risk if pre not allocated appropriately)",
        "Copies prefix into 'pre' which may be a logging buffer; source 'prefix' provenance is uncertain (could be REE-originated), so copy may move untrusted data into TA memory or vice versa depending on caller.",
        "Copies prefix into 'pre' buffer; source 'prefix' provenance is unclear and destination 'pre' may be TA stack/buffer — length uses strlen(prefix) without explicit destination size here.",
        "Copies prefix string into pre buffer using strlen(prefix) without verifying pre capacity here; caller must ensure pre is allocated and large enough",
        "Copies prefix into pre buffer before logging; source may be caller-provided and length computed via strlen, rely on prefix validity.",
        "Copies strlen(prefix) bytes from prefix (caller-provided) into pre; prefix origin may be REE-visible and length unchecked relative to pre capacity.",
        "Copies caller-provided prefix into pre without ensuring pre capacity relative to strlen(prefix).",
        "Copies prefix string into pre buffer using strlen(prefix); destination pre may be uninitialized if allocation failed elsewhere",
        "Copies prefix into pre buffer before logging; origin and size of pre must be valid to avoid overwrite or logging of untrusted data.",
        "Copies prefix into pre buffer before logging; source may be external but the copy itself is an internal memory move used for message composition.",
        "Copies prefix bytes into pre using strlen(prefix) (caller-controlled); if pre is NULL or undersized this may cause crash",
        "Copies prefix into pre buffer using strlen(prefix) without verifying destination pre size; if prefix is REE-controlled this can overflow",
        "Copies strlen(prefix) bytes into pre without shown bounds check; prefix origin may be untrusted leading to potential overflow or unexpected reads",
        "Copies caller-supplied prefix into 'pre' without verifying pre is non-NULL or large enough here (caller responsibility), creating a potential overwrite or crash",
        "Copies prefix into pre using strlen(prefix) bytes; pre destination must be valid and prefix provenance unclear here",
        "copies prefix (caller-provided) into pre buffer; binding of pre/prefix origins may be REE or TA depending on caller, risk is aliasing of shared buffers",
        "Copies prefix into pre buffer before printing; dest 'pre' may be uninitialized if allocation failed—possible sink of unverified memory",
        "Copies prefix into pre buffer without explicit bounds check on pre length (caller must ensure pre has space)",
        "Copies prefix bytes into pre buffer prior to logging; destination 'pre' may be uninitialized leading to potential memmove into invalid memory.",
        "Copies a prefix string into pre (caller-provided); origin of pre and prefix may be REE-derived or set earlier—potential aliasing of shared buffer into logging output",
        "Copies prefix into pre buffer before logging; depends on prefix buffer being large enough",
        "Destination 'pre' is local buffer expected to be provisioned; writing prefix bytes into it may overflow if 'pre' not sized correctly.",
        "Copies prefix into pre without validating destination capacity here; caller must ensure pre allocated large enough.",
        "Copies prefix into pre without validating pre capacity at this site.",
        "Copies prefix into pre buffer; destination origin and size not validated here (caller must ensure pre is large enough)",
        "Copies prefix into pre using strlen(prefix) without ensuring pre buffer size; pre originates from caller and may be NULL if not allocated.",
        "Copies prefix into pre (pre may be uninitialized/NULL) using strlen(prefix) as length; destination origin/size not validated",
        "Copies prefix into pre (buffer) for logging; length uses strlen(prefix) which relies on prefix being NUL-terminated",
        "Copies prefix string into 'pre' buffer; source 'prefix' provenance unclear (possibly REE), and length uses strlen(prefix) without explicit dst size here",
        "Copies prefix into pre buffer prior to logging; prefix provenance uncertain and length uses strlen(prefix)",
        "Copies prefix into pre (caller-provided buffer) using strlen(prefix) without explicit dst bounds here; destination origin at call-site determines risk.",
        "Copies prefix into pre buffer for logging; src may be external and length determined by strlen(prefix) without explicit dst bounds here",
        "Copies prefix into 'pre' buffer; 'pre' may be REE-visible or TA-owned depending on earlier allocation—origin uncertain.",
        "Copies prefix into pre using strlen(prefix) without explicit bounds here; if pre's allocation is attacker-controlled or insufficient this may overflow.",
        "Copies prefix into pre using strlen(prefix) without explicit local bounds here; potential overflow if pre not sized appropriately",
        "alias of destination 'pre' bound to local pointer derived earlier; copies prefix (possibly REE-originated) into pre without explicit bounds here",
        "Copies prefix (potentially REE-originated) into local buffer without an explicit bounds check at this site.",
        "Copies prefix into pre buffer using strlen(prefix) as length; length computed from prefix which may be unbounded relative to pre",
        "Call-site binding: dest 'pre' may be TA buffer, src 'prefix' origin unclear (could be caller-provided); copies strlen(prefix) bytes which is caller-controlled length.",
        "Copies prefix bytes into pre using strlen(prefix) as length; origin of prefix may be untrusted and dst buffer pre provenance/size not shown here",
        "Copies prefix using strlen(prefix) into pre where pre buffer provenance/size is not shown here.",
        "Copies prefix into pre; prefix may be caller-controlled and length computed by strlen(prefix) should be validated against pre buffer size",
        "copies prefix into pre buffer using strlen(prefix) where prefix may be REE-supplied; destination size not evident here",
        "Copies prefix into pre for logging; source prefix may be caller-controlled leading to potential oversized copy if prefix length miscomputed",
        "Copies strlen(prefix) bytes from prefix (caller-provided) into pre without ensuring pre has adequate size; origin of prefix may be REE-visible.",
        "Copies prefix bytes into pre using strlen(prefix) without clear bounds on pre's size at this callsite.",
        "copies prefix into pre using strlen(prefix) bytes; if prefix pointer originates from REE, length and contents are attacker-controlled",
        "Copies prefix into 'pre' buffer using strlen(prefix); destination 'pre' origin/size not validated here — potential unsafe write if pre not sized.",
        "Copies prefix into buffer 'pre' using strlen(prefix) without validating destination size here.",
        "Copies prefix into pre buffer for logging; if prefix is attacker-controlled this could lead to unexpected logging content or overflow if pre is undersized",
        "Copies 'prefix' into 'pre'; source 'prefix' may be external/REE-derived and is used untrusted in logging path.",
        "copies strlen(prefix) bytes into pre (pre may be TA buffer but prefix provenance could be REE); binds prefix source to destination pre",
        "Copies prefix into pre buffer before logging; prefix provenance uncertain (could be caller-provided), bounds depend on strlen(prefix)",
        "Call-site binding: copies prefix into 'pre' buffer before logging; origin of prefix uncertain, may be external.",
        "destination pre (likely buffer) receives prefix bytes; binding of prefix source to origin shown at call-site",
        "Copies prefix into pre buffer for logging; prefix origin may be untrusted leading to log injection risk"
      ],
      "code_excerpts": [
        "TEE_MemMove(pre, prefix, strlen(prefix));",
        "if (prefix) TEE_MemMove(pre, prefix, strlen(prefix));"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=strlen(prefix),src_sz=strlen(prefix),dst_sz=unknown",
          "src_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=strlen(prefix),src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "flow_dir:TA->TA",
          "flow_dir:TEE->TEE",
          "flow_dir:TA->TEE-private",
          "size_triplet:copy_len=strlen(prefix),src_sz=strlen(prefix),dst_sz=pre_capacity",
          "size_triplet:copy_len=strlen(prefix),src_sz=strlen(prefix),dst_sz=pre_size",
          "dst_region:REE-visible",
          "flow_dir:REE->TEE-private",
          "size_triplet:copy_len=strlen(prefix),src_sz=unknown,dst_sz=pre_capacity"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0040",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 1188,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute (call-site binding)"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: 'head' parameter receives 'head' (local attributes list) from caller context; origin is TEE-private.",
        "Binding: 'attr' parameter receives &bbool (local stack variable); callee will write into caller's stack memory.",
        "Binding: 'attr_size' parameter receives &size (local) controlling buffer size checks inside callee."
      ],
      "code_excerpts": [
        "rc = get_attribute(head, PKCS11_CKA_EXTRACTABLE, &bbool, &size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=sizeof(bbool),src_sz=unknown,dst_sz=sizeof(bbool)",
          "size_triplet:copy_len=4,src_sz=unknown,dst_sz=sizeof(size)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0041",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 1237,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Generic pattern: copying into caller-provided buffers can move TA-private or REE-originating data depending on call-site; sizes may be derived from untrusted sources at some sites.",
        "Call-site binding (representative): copying local handle into caller-visible out buffer in object.c uses TEE_MemMove to write into REE-visible memory"
      ],
      "code_excerpts": [
        "TEE_MemMove(dest, src, n);",
        "TEE_MemMove(out->memref.buffer, &obj_handle, sizeof(obj_handle));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=n,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(obj_handle),src_sz=sizeof(obj_handle),dst_sz=out->memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0042",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 1528,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding callee parameter 'head' to caller-provided obj_attrs; attributes derive from REE-provided templates so content is REE-influenced though stored TA-side"
      ],
      "code_excerpts": [
        "return get_bool(head, PKCS11_CKA_PRIVATE);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0043",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 2134,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding of callee params from caller: &boolval and &boolsize passed; origin of obj->attributes traces to earlier REE-derived object data."
      ],
      "code_excerpts": [
        "rc = get_attribute(obj->attributes, PKCS11_CKA_EXTRACTABLE, &boolval, &boolsize);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=boolsize"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0044",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 2140,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding of callee params from caller: &boolval and &boolsize; underlying attributes may originate from REE buffers."
      ],
      "code_excerpts": [
        "rc = get_attribute(obj->attributes, PKCS11_CKA_SENSITIVE, &boolval, &boolsize);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=boolsize"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0045",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 2179,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of obj->attributes passed into get_bool; origin is object metadata (TA-private) but may reflect earlier REE-provided templates"
      ],
      "code_excerpts": [
        "return get_bool(obj->attributes, attr->id);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=sizeof(struct obj_attrs*)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0046",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 2259,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding of callee params from caller: &boolval and &boolsize used to retrieve PKCS11_CKA_TRUSTED from obj->attributes (caller-influenced)."
      ],
      "code_excerpts": [
        "rc = get_attribute(obj->attributes, PKCS11_CKA_TRUSTED, &boolval, &boolsize);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=boolsize"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0047",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 2380,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_attrs_against_modification"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Reads attribute header into cli_ref and uses cli_ref.size to compute len without proving header+size <= end."
      ],
      "code_excerpts": [
        "TEE_MemMove(&cli_ref, cur, sizeof(cli_ref)); len = sizeof(cli_ref) + cli_ref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(cli_ref),src_sz=end - cur,dst_sz=sizeof(cli_ref)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0048",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 2456,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding of callee params from caller: &key_length and &size passed; key length attribute originates from caller-constructed attrs.",
        "Call-site binding: 'head' parameter aliases *head (template-derived attributes) which may originate from REE-supplied data",
        "Call-site binding: 'attr' parameter (&key_length) is TA-local destination for retrieved size",
        "Call-site binding: 'attr_size' parameter (&size) is TA-local and used for bounds reporting/checking"
      ],
      "code_excerpts": [
        "rc = get_attribute(*head, PKCS11_CKA_VALUE_LEN, &key_length, &size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=sizeof(key_length)",
          "size_triplet:copy_len=sizeof(struct obj_attrs *),src_sz=head->attrs_size,dst_sz=unknown",
          "flow_dir:TA->TEE-private",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(key_length),src_sz=unknown,dst_sz=size",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0049",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/check_attrs_against_modification (callsite)",
      "line": 2414,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of head (attributes list) passed into get_bool; head was derived from template which originally came from caller-supplied memref (REE-visible)"
      ],
      "code_excerpts": [
        "if (cli_ref.id == PKCS11_CKA_TOKEN && get_bool(head, PKCS11_CKA_TOKEN)) {"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(bbool),src_sz=head->attrs_size,dst_sz=sizeof(bbool)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0050",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/check_attrs_against_modification (callsite)",
      "line": 2423,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of obj->attributes passed into get_bool at parent_priv check; obj is TA-managed but derived from earlier handle lookup"
      ],
      "code_excerpts": [
        "bool parent_priv = get_bool(obj->attributes, cli_ref.id);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(bbool),src_sz=unknown,dst_sz=sizeof(bbool)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0051",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/check_attrs_against_modification (callsite)",
      "line": 2424,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of head passed into get_bool to obtain obj_priv; head originated from template derived from REE-provided data"
      ],
      "code_excerpts": [
        "bool obj_priv = get_bool(head, cli_ref.id);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(bbool),src_sz=head->attrs_size,dst_sz=sizeof(bbool)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0052",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/check_so_pin_callsite:1164",
      "line": 1164,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db",
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed originates from session->token (derived earlier from REE-controlled session handle); origin influences persisted DB content.",
        "Call-site binding: 'token' argument originates from session->token earlier (influenced by REE-derived session handle); origin influences DB filename resolution.",
        "Call-site binding: 'out_hdl' argument is &db_hdl (local handle); callee will populate a TEE object handle (TEE-private)."
      ],
      "code_excerpts": [
        "update_persistent_db(token);",
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=sizeof(*token->db_main),src_sz=unknown,dst_sz=sizeof(*token->db_main)",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=sizeof(TEE_ObjectHandle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0053",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/check_so_pin_callsite:1175",
      "line": 1175,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed originates from session->token (derived earlier from REE-controlled session handle); origin influences persisted DB content."
      ],
      "code_excerpts": [
        "update_persistent_db(token);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=sizeof(*token->db_main),src_sz=unknown,dst_sz=sizeof(*token->db_main)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0054",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/check_so_pin_callsite:1183",
      "line": 1183,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed originates from session->token (derived earlier from REE-controlled session handle); origin influences persisted DB content."
      ],
      "code_excerpts": [
        "update_persistent_db(token);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=sizeof(*token->db_main),src_sz=unknown,dst_sz=sizeof(*token->db_main)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0055",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/check_so_pin_callsite:1223",
      "line": 1223,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed originates from session->token (derived earlier from REE-controlled session handle); origin influences persisted DB content."
      ],
      "code_excerpts": [
        "update_persistent_db(token);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=sizeof(*token->db_main),src_sz=unknown,dst_sz=sizeof(*token->db_main)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0056",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/check_so_pin_callsite:1234",
      "line": 1234,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed originates from session->token (derived earlier from REE-controlled session handle); origin influences persisted DB content."
      ],
      "code_excerpts": [
        "update_persistent_db(token);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=sizeof(*token->db_main),src_sz=unknown,dst_sz=sizeof(*token->db_main)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0057",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/check_so_pin_callsite:1242",
      "line": 1242,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed originates from session->token (derived earlier from REE-controlled session handle); origin influences persisted DB content."
      ],
      "code_excerpts": [
        "update_persistent_db(token);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=sizeof(*token->db_main),src_sz=unknown,dst_sz=sizeof(*token->db_main)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0058",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/close_ck_session (call site)",
      "line": 693,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "destroy_object"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "obj pointer from session->object_list (TA-private) is passed into destroy_object; alias of internal object into helper."
      ],
      "code_excerpts": [
        "destroy_object(session, LIST_FIRST(&session->object_list), true);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0059",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/close_ck_session (call site)",
      "line": 1372,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "destroy_object"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "obj iterator-derived pointer from sess->object_list (TA-private) passed into destroy_object; binding of iterator element into helper."
      ],
      "code_excerpts": [
        "destroy_object(sess, obj, true);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0060",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/destroy_object (call site)",
      "line": 156,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "unregister_persistent_object"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "session->token (TA-private) passed as 'token' parameter into unregister_persistent_object; alias of internal token structure into helper.",
        "obj->uuid (object-internal UUID, TA-private) passed as 'uuid' parameter into unregister_persistent_object; alias of internal UUID pointer."
      ],
      "code_excerpts": [
        "if (unregister_persistent_object(session->token, obj->uuid) &&"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=0,src_sz=sizeof(TEE_UUID),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0061",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 59,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed into open_db_file is alias of caller's token (originates from TA state possibly influenced by REE-derived token_id)."
      ],
      "code_excerpts": [
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:credential",
          "size_triplet:copy_len=?,src_sz=sizeof(*token),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0062",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 72,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_ping",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies TA-local version array into caller-provided out->memref.buffer (REE-visible); bounds checked against out->memref.size",
        "Binding: callee dest parameter aliases caller-provided out->memref.buffer (shared/REE-visible)",
        "Binding: callee src parameter aliases local ver array (TEE-private)"
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, ver, sizeof(ver));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(ver),src_sz=sizeof(ver),dst_sz=out->memref.size",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=out->memref.size",
          "flow_dir:unknown",
          "dst_region:TEE-private",
          "size_triplet:copy_len=sizeof(ver),src_sz=sizeof(ver),dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0063",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 115,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'args' parameter aliases ctrlargs derived from ctrl->memref.buffer (caller-provided shared buffer)."
      ],
      "code_excerpts": [
        "rc = serialargs_get(args, &head, sizeof(head));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0064",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 136,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'args' parameter aliases ctrlargs derived from ctrl->memref.buffer (caller-provided shared buffer)."
      ],
      "code_excerpts": [
        "rc = serialargs_get(args, &attr, sizeof(attr));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0065",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 158,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptrs"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of head passed from caller into callee; head may reference buffers originating from REE/shared memory",
        "alias of attr (attr_ptr) argument from caller passed for writing; callee writes pointers into this buffer",
        "alias of attr_size argument from caller passed for writing sizes; callee writes pkcs11_ref.size into it",
        "alias of count pointer passed from caller; callee updates count with number of matches"
      ],
      "code_excerpts": [
        "get_attribute_ptrs(head, attribute, attr_ptr, attr_size, &count);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs),src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=pointer_writes,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(size_t),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0066",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 163,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'args' parameter aliases ctrlargs derived from ctrl->memref.buffer (caller-provided shared buffer).",
        "alias of caller-provided serialargs passed into serialargs_get at another callsite (session_handle read); args originates from REE-visible buffer",
        "Alias of caller-provided serialargs 'args' (derived from REE memref buffer) passed into serialargs_get; reads src pointer from it (untrusted input).",
        "Binding callee 'out' to caller-&session_handle (TA-local) at call-site; callee writes to caller-provided out buffer."
      ],
      "code_excerpts": [
        "rv = serialargs_get(args, &session_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown",
          "dst_region:TEE-private",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=0,src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=sizeof(uint32_t),dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0067",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 277,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_created_attrs_against_processing"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller-provided 'head' (obj_attrs built from REE-supplied template) passed into this function; origin is REE-visible serialargs buffer"
      ],
      "code_excerpts": [
        "rc = check_created_attrs_against_processing(proc_params->id, head);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=template->attrs_size,dst_sz=sizeof(*head)+template->attrs_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0068",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 281,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_created_attrs_against_token"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding of caller 'session' pointer into callee parameter; origin not proven TEE-private (could be influenced by REE path).",
        "Binding of caller 'head' (attributes) into callee parameter; head may originate from REE-parsed template or TA-created attrs—origin ambiguous."
      ],
      "code_excerpts": [
        "rc = check_created_attrs_against_token(session, head);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "flow_dir:REE->TA",
          "dst_region:TEE-private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=sizeof(*head)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0069",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 327,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle",
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'args' parameter aliases a serialargs built over ctrl->memref.buffer which is REE-provided/shared buffer.",
        "Call-site binding: callee 'client' parameter is alias of caller 'client' (origin unclear from call-site).",
        "Call-site binding: callee 'sess' parameter aliases caller's local &session (TA-private output pointer).",
        "Call-site binding: callee 'args' parameter aliases a serialargs built over ctrl->memref.buffer (REE-provided/shared).",
        "Call-site binding: callee 'out' parameter aliases caller local (&session_handle), a TA-private destination."
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session);",
        "rv = serialargs_get(args, &session_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=ctrl->memref.size,dst_sz=sizeof(struct serialargs)",
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=0,src_sz=sizeof(struct pkcs11_session *),dst_sz=sizeof(struct pkcs11_session *)",
          "size_triplet:copy_len=0,src_sz=sizeof(uint32_t),dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0070",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 364,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_created_attrs_against_token",
        "check_attrs_misc_integrity",
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'session' parameter is alias of caller-provided session pointer from entry_create_object; origin region not explicit at call-site.",
        "Call-site binding: callee 'head' parameter aliases attributes built earlier (origin: parsed from REE template then converted) — record as TEE-private alias of processed REE input.",
        "Call-site binding: callee 'head' parameter aliases attributes constructed from REE-provided template earlier; record origin as TEE-private converted from REE input.",
        "Call-site binding: callee 'head' parameter aliases caller's 'head' (attributes built from parsed template); origin is processed from REE input, recorded as TEE-private alias of REE-derived data."
      ],
      "code_excerpts": [
        "rc = check_created_attrs_against_token(session, head);",
        "rc = check_attrs_misc_integrity(head);",
        "rc = check_created_attrs_against_token(session, head); // -> get_bool(head, ...)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "flow_dir:REE->TA",
          "src_region:TEE-private"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0071",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 366,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TA_InvokeCommandEntryPoint",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies local enum rc into caller-provided memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though rc is non-sensitive.",
        "Copies local rc into caller-provided memref.buffer (REE-visible); structural information-flow to REE observed on different line.",
        "Local return code rc is copied into params[0].memref.buffer (REE-visible); verify that no sensitive TA-private data is later written to REE here.",
        "Copies local rc into caller memref (REE-visible); destination is shared but rc is non-sensitive.",
        "Copies local rc into caller-provided memref.buffer (REE-visible); destination is shared/REE-visible though rc is non-sensitive.",
        "Copies local rc into caller-provided params[0].memref.buffer (REE-visible); structural info flow to REE (rc is public/non-sensitive).",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); destination is shared/REE-visible though rc is non-sensitive",
        "Copies local rc value into caller-provided params[0].memref.buffer (REE-visible); rc is non-sensitive but destination is shared.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); destination is shared/REE-visible though rc is non-sensitive.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); rc is non-sensitive but operation writes into shared memory.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); destination is shared though rc is non-sensitive.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible) via TEE_MemMove; destination is shared though rc is non-sensitive.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); structural REE-facing write recorded though rc appears non-sensitive.",
        "Copies local rc into caller-provided memref.buffer (REE-visible); destination is shared but data is non-sensitive status code.",
        "Copies local rc into caller memref output buffer; destination is REE-visible but data is non-sensitive status code.",
        "Copying local rc into caller-provided memref.buffer (REE-visible) — destination is shared though data appears non-sensitive.",
        "Copies local rc into caller-provided memref.buffer (REE-visible); structural output to REE though rc is non-sensitive.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); structural information-flow to REE-visible memory.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); destination is shared/REE-visible though rc appears non-sensitive.",
        "Copies local enum rc into caller-provided params[0].memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though rc is non-sensitive.",
        "Copies local rc into caller-provided memref.buffer (REE-visible); destination is shared even though rc is not sensitive.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); destination is shared even though rc is non-sensitive.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible) at end of command handling.",
        "Copies local rc into caller-provided REE-visible memref.buffer; destination is shared/REE-visible though data appears non-sensitive.",
        "Copies local enum rc into caller-provided REE-visible buffer; destination is shared/REE-visible which is a data-leak channel though rc is non-sensitive.",
        "Copies rc into caller-provided memref.buffer (REE-visible); destination is shared but rc is non-sensitive.",
        "Copies local rc into caller-provided memref.buffer (REE-visible); destination is shared even though rc is non-sensitive.",
        "Copies local rc value into caller-provided REE-visible memref.buffer; structural link to REE output channel (non-sensitive here).",
        "Copies local rc into caller-provided memref.buffer (REE-visible); destination is shared/REE-visible though rc is non-sensitive",
        "Copies local rc into caller-provided params[0].memref.buffer (REE-visible); size checked earlier but destination is shared memory.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though rc is non-sensitive",
        "Copies enum rc into caller-provided params[0].memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible.",
        "Binding: callee dest parameter aliases caller-provided params[0].memref.buffer (shared/REE-visible)",
        "Binding: callee src parameter aliases address of local rc (TEE-private)",
        "Copies local rc into caller-provided params[0].memref.buffer; bounds not provably checked against sizeof(rc) at this call site in the same function path (params[0].memref.size was checked earlier but different call paths may reach here).",
        "Copies local rc into caller-provided params[0].memref.buffer (REE-visible).",
        "Copies local rc into caller-provided params[0].memref.buffer (shared/REE-visible destination).",
        "Copies local rc into caller-provided params[0].memref.buffer (REE-visible); destination is shared though rc is non-sensitive.",
        "Copies local rc into caller-provided REE-visible memref.buffer via TEE_MemMove; destination is shared/REE-visible.",
        "Copies TA-local rc into caller-provided REE-visible memref.buffer via TEE_MemMove; destination is shared.",
        "Copies local rc into caller-provided REE-visible buffer; structurally exposes TA state to REE (rc is non-sensitive here).",
        "Copies local rc into caller-provided memref.buffer (REE-visible); structural risk recorded though rc is non-sensitive.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); destination is shared though rc is non-sensitive",
        "Copies rc into caller-provided memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though rc is non-sensitive.",
        "Copies local rc into caller-provided memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though rc is non-sensitive.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); structural risk of leaking status to REE.",
        "Copies local return code into caller-provided params[0].memref.buffer (REE-visible); structural risk since destination is shared memory.",
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); structural risk of exposing TA state to REE if semantics change.",
        "Copies rc into caller-provided params[0].memref.buffer (REE-visible); structural binding from TA to REE.",
        "Copies local rc into caller-provided memref.buffer (REE-visible); rc is non-sensitive but this is a structural REE write."
      ],
      "code_excerpts": [
        "TEE_MemMove(params[0].memref.buffer, &rc, sizeof(rc));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(rc),src_sz=sizeof(rc),dst_sz=params[0].memref.size",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=params[0].memref.size",
          "flow_dir:unknown",
          "dst_region:TEE-private",
          "size_triplet:copy_len=sizeof(rc),src_sz=sizeof(rc),dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0072",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 368,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_access_attrs_against_token"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'session' parameter aliases caller's session pointer; session is a TA-side session object (TA-private).",
        "Call-site binding: callee 'head' parameter aliases caller-provided attributes pointer; origin may be REE-provided template or TA-owned object attributes (ambiguous)."
      ],
      "code_excerpts": [
        "rc = check_access_attrs_against_token(session, head);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "flow_dir:REE->TA",
          "src_region:unknown",
          "sensitivity_label:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0073",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 377,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' parameter is alias of caller's token (TA-managed) passed into open_db_file.",
        "Call-site binding: '&db_hdl' is caller-local TEE_ObjectHandle passed to receive object handle."
      ],
      "code_excerpts": [
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(TEE_ObjectHandle),src_sz=sizeof(TEE_ObjectHandle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0074",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 417,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle",
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of shared ctrlargs (backed by ctrl->memref.buffer from REE) passed as 'args' into function",
        "client pointer passed through from caller into callee; origin not validated here",
        "caller supplies address of local session pointer as output parameter (&session) bound into callee 'sess'",
        "alias of caller-provided serialargs structure (backed by REE memref buffer) passed as 'args' into serialargs_get",
        "caller passes address of local session_handle as 'out' parameter into serialargs_get"
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session);",
        "rv = serialargs_get(args, &session_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct serialargs*),src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(struct pkcs11_client*),src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(struct pkcs11_session*),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=sizeof(session_handle)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0075",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 422,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding callee parameter 'args' to caller-controlled serialargs backed by ctrl->memref.buffer (shared/REE-visible); origin is shared buffer passed into helper.",
        "Binding callee parameter 'client' to caller-provided client (originated from tee_session2client); provenance not proven TEE-private.",
        "Binding callee parameter 'sess' to caller's &session (callee writes back a pointer to TA-private session), origin is TEE-private local in caller."
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=0,src_sz=ctrl->memref.size,dst_sz=unknown",
          "src_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0076",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 425,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_alloc_get_attributes",
        "serialargs_get",
        "alloc_and_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller's serialargs object (ctrlargs) originating from REE memref buffer passed into callee as args",
        "alias of caller's serialargs object (&ctrlargs) passed into serialargs_get; origin is REE-provided memref buffer from TA entry path",
        "alias of serialargs object (ctrlargs) originating from REE memref buffer passed as args into alloc_and_get",
        "orig_next (pointer into REE-controlled args->next) passed into alloc_and_get as orig_next alias",
        "buf0 points to attr read from REE-controlled serialargs and is forwarded into alloc_and_get (copied into heap)"
      ],
      "code_excerpts": [
        "rc = serialargs_alloc_get_attributes(&ctrlargs, &pub_template);",
        "rc = serialargs_get(&ctrlargs, &attr, sizeof(attr));",
        "rc = alloc_and_get(args, orig_next, &attr, sizeof(attr), &p, attr.attrs_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct serialargs),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(char*),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=buf0_sz,src_sz=buf0_sz,dst_sz=sz"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0077",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 429,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_alloc_get_attributes"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller-local pointer (&priv_template) passed as out parameter into callee"
      ],
      "code_excerpts": [
        "rc = serialargs_alloc_get_attributes(&ctrlargs, &priv_template);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct pkcs11_object_head*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0078",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 441,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' parameter is alias of TA-managed token from caller at this site.",
        "Call-site binding: '&db_hdl' is caller-local handle passed for output."
      ],
      "code_excerpts": [
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(TEE_ObjectHandle),src_sz=sizeof(TEE_ObjectHandle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0079",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 447,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_access_attrs_against_token"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding callee 'session' parameter to caller session (derived in TA); origin is TA-internal but provenance from caller; treated as TEE-private.",
        "Binding callee 'head' parameter to caller object->attributes; attributes are TA-owned object metadata (treated as TEE-private)."
      ],
      "code_excerpts": [
        "rc = check_access_attrs_against_token(session, object->attributes);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "sensitivity_label:private"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0080",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 476,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "add_missing_attribute_id"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of pub_head pointer from caller passed into callee; origin is TA-created but ultimately derived from templates that may include REE-originated data",
        "alias of priv_head pointer from caller passed into callee; origin is TA-created but may reference attributes sourced from REE buffers"
      ],
      "code_excerpts": [
        "rc = add_missing_attribute_id(&pub_head, &priv_head);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0081",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 485,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_created_attrs_against_processing"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller-provided 'pub_head' (from parsed template) passed into function; underlying bytes originate from REE serialargs"
      ],
      "code_excerpts": [
        "rc = check_created_attrs_against_processing(proc_params->id, pub_head);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0082",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 489,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_created_attrs_against_processing"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller-provided 'priv_head' passed into function; originates from REE-provided template data"
      ],
      "code_excerpts": [
        "rc = check_created_attrs_against_processing(proc_params->id, priv_head);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0083",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 515,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site passes ctrlargs initialized from caller memref.buffer (shared/REE-visible) into serialargs_get as args — alias of shared buffer passed into helper",
        "Call-site binds callee out pointer to caller stack variable (destination is TA-private)"
      ],
      "code_excerpts": [
        "rc = serialargs_get(&ctrlargs, &token_id, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=alias,src_sz=ctrl->memref.size,dst_sz=sizeof(struct serialargs)",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0084",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 598,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' argument originates from caller context (TA-managed).",
        "Call-site binding: '&db_hdl' passed to receive opened object handle (caller-local)."
      ],
      "code_excerpts": [
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(TEE_ObjectHandle),src_sz=sizeof(TEE_ObjectHandle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0085",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 727,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "serialargs_get_session_from_handle"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Alias of shared REE-provided serialargs buffer passed into helper; serialargs_get reads a uint32_t handle from it (untrusted input).",
        "Binding callee parameter 'client' from caller; origin (tee_session2client-derived) is unclear at this call-site.",
        "Output binding: caller passes &session (TA-local) as sess parameter; callee writes *sess = session."
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctrl->memref.size,dst_sz=sizeof(uint32_t)",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=0,src_sz=0,dst_sz=0",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(void*),src_sz=sizeof(void*),dst_sz=sizeof(void*)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0086",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 798,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle",
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "callee 'args' parameter aliases caller's serialargs pointing into ctrl->memref.buffer (REE-visible), allowing REE-originated bytes to drive session_handle",
        "callee 'client' parameter is bound from caller-provided client (origin from tee_session2client); client may be REE-derived/tainted",
        "callee 'sess' out-parameter binds to caller's &session (TEE-private), receiving TA-selected session pointer",
        "callee 'args' aliases caller serialargs pointing into ctrl->memref.buffer (REE-visible); src is derived from REE-origin bytes.",
        "callee 'out' parameter binds to caller's &session_handle (TA-private stack) receiving bytes from serialargs_get.",
        "callee 'size' argument is caller-supplied (sizeof(uint32_t)) driving copy length; size originates from call-site constant but relates to REE-provided buffer length."
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session);",
        "rc = serialargs_get(args, &session_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctrl->memref.size,dst_sz=sizeof(uint32_t)",
          "src_region:unknown",
          "sensitivity_label:session",
          "size_triplet:copy_len=ptr,src_sz=unknown,dst_sz=sizeof(struct pkcs11_client *)",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=ptr,src_sz=sizeof(struct pkcs11_session *),dst_sz=sizeof(struct pkcs11_session *)",
          "size_triplet:copy_len=ptr,src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:unknown",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0087",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 840,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: args (ctrlargs) originates from caller memref buffer (shared REE-visible) passed into serialargs_get."
      ],
      "code_excerpts": [
        "rc = serialargs_get(&ctrlargs, &token_id, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:credential",
          "size_triplet:copy_len=?,src_sz=ctrl->memref.size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0088",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 908,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee parameter 'token' is alias of caller's token (originates from TA but influenced by REE-derived token_id)."
      ],
      "code_excerpts": [
        "update_persistent_db(token);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:credential",
          "size_triplet:copy_len=?,src_sz=sizeof(*token->db_main),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0089",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 946,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_get_object_size"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of callee parameter 'args' bound to caller '&ctrlargs' which was initialized from ctrl->memref.buffer (REE-provided shared buffer)",
        "alias of callee parameter 'out' bound to caller '&object_handle' (TA-local stack variable)"
      ],
      "code_excerpts": [
        "rc = serialargs_get(&ctrlargs, &object_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=sizeof(struct serialargs)",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=sizeof(uint32_t),dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0090",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 955,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_created_attrs_against_processing"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller-provided 'head' passed into function at another call-site; origin from REE-constructed attrs"
      ],
      "code_excerpts": [
        "rc = check_created_attrs_against_processing(proc_params->id, head);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0091",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 960,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "unregister_persistent_object"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' argument is alias of TA-managed token structure passed into callee."
      ],
      "code_excerpts": [
        "if (unregister_persistent_object(token, obj->uuid) &&"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0092",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 961,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "unregister_persistent_object"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'uuid' argument is alias of obj->uuid from token object list (TA-owned)."
      ],
      "code_excerpts": [
        "unregister_persistent_object(token, obj->uuid))"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=sizeof(TEE_UUID),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0093",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 998,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get (call-site)",
        "entry_set_attribute_value"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller passes &object_handle as out parameter (TEE-private) to serialargs_get; binding records origin",
        "caller-provided args (&ctrlargs) originated from ctrl->memref.buffer (REE-visible); binding records shared buffer passed into serialargs_get",
        "binding: caller-provided args (&ctrlargs) originated from ctrl->memref.buffer (REE-visible); shared buffer passed into serialargs_get"
      ],
      "code_excerpts": [
        "rc = serialargs_get(&ctrlargs, &object_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=sizeof(uint32_t)",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=ctrl->memref.size,src_sz=ctrl->memref.size,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctrl->memref.size,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0094",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1002,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_alloc_get_attributes",
        "serialargs_get",
        "alloc_and_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller-provided serialargs (ctrlargs derived from params->memref.buffer) passed into callee; origin is REE-visible shared memory",
        "alias of callee out-parameter bound to &template (TEE-private) at call-site",
        "caller-provided 'args' (ctrlargs derived from params->memref.buffer) is passed as serialargs pointer; origin is REE-visible shared memory",
        "out parameter is &attr (callee stack) bound to caller local; destination is TEE-private",
        "caller-provided serialargs pointer (args) originates from REE-visible memref buffer and is passed into alloc_and_get"
      ],
      "code_excerpts": [
        "rc = serialargs_alloc_get_attributes(&ctrlargs, &template);",
        "rc = serialargs_get(args, &attr, sizeof(attr));",
        "rc = alloc_and_get(args, orig_next, &attr, sizeof(attr), &p, attr.attrs_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=NA,src_sz=ctrl->memref.size,dst_sz=NA",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA",
          "size_triplet:copy_len=sizeof(attr),src_sz=NA,dst_sz=NA"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0095",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1028,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_access_attrs_against_token"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller-provided session pointer passed into callee; session provenance includes REE-derived handle earlier in call chain",
        "alias of caller-provided obj->attributes passed into callee; attributes originate from TA object but ultimately from earlier REE inputs"
      ],
      "code_excerpts": [
        "rc = check_access_attrs_against_token(session, obj->attributes);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA",
          "sensitivity_label:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0096",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1050,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "hash_pin"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'pin' argument originates from caller-provided buffer (REE-visible PIN).",
        "Call-site binding: 'salt' argument is a pointer into TA-private token DB (destination for salt).",
        "Call-site binding: 'hash' buffer argument is TA-private storage for PIN hash."
      ],
      "code_excerpts": [
        "rc = hash_pin(user_type, new_pin, new_pin_size, &token->db_main->so_pin_salt, token->db_main->so_pin_hash);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=pin_size,src_sz=pin_size,dst_sz=pin_size",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "sensitivity_label:random",
          "size_triplet:copy_len=sizeof(s),src_sz=unknown,dst_sz=sizeof(*salt)",
          "size_triplet:copy_len=TEE_MAX_HASH_SIZE,src_sz=TEE_MAX_HASH_SIZE,dst_sz=TEE_MAX_HASH_SIZE"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0097",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1055,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_attrs_against_modification",
        "attribute_is_modifiable"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller session pointer passed into callee; session origin is upstream and may be tainted/unknown",
        "alias of caller-provided head (attributes list) passed into callee; head was created from template derived from REE memory",
        "alias of callee obj pointer passed in; obj is a TA-managed object (TEE-private) but originated from handle derived earlier",
        "alias of obj pointer passed into callee; obj is TA-managed but originated from handle resolution upstream"
      ],
      "code_excerpts": [
        "rc = check_attrs_against_modification(session, head, obj, function);",
        "if (!attribute_is_modifiable(session, &cli_ref, obj, class, function))"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=head->attrs_size,src_sz=head->attrs_size,dst_sz=unknown",
          "src_region:TEE-private"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0098",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1062,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "hash_pin"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'pin' argument originates from caller-provided buffer (REE-visible PIN).",
        "Call-site binding: 'salt' argument is a pointer into TA-private token DB (destination for salt).",
        "Call-site binding: 'hash' buffer argument is TA-private storage for PIN hash."
      ],
      "code_excerpts": [
        "rc = hash_pin(user_type, new_pin, new_pin_size, &token->db_main->user_pin_salt, token->db_main->user_pin_hash);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=pin_size,src_sz=pin_size,dst_sz=pin_size",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "sensitivity_label:random",
          "size_triplet:copy_len=sizeof(s),src_sz=unknown,dst_sz=sizeof(*salt)",
          "size_triplet:copy_len=TEE_MAX_HASH_SIZE,src_sz=TEE_MAX_HASH_SIZE,dst_sz=TEE_MAX_HASH_SIZE"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0099",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1083,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "args (serialargs*) is alias of caller-controlled memref buffer initialized from REE-visible params; shared buffer passed into helper.",
        "client pointer (from tee_session2client) is forwarded into callee; origin is TA-internal but tainted by caller context.",
        "sess (output pointer) is caller-provided stack pointer &session; callee writes *sess = session which binds TA-private session into caller context."
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=ctrl->memref.size,src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(struct pkcs11_client*),src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "sensitivity_label:session",
          "size_triplet:copy_len=sizeof(struct pkcs11_session*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0100",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1106,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "serialargs struct (args) originates from caller memref buffer (REE-shared) and is forwarded into this helper; record alias binding.",
        "client pointer provided by caller is forwarded into helper; origin uncertain (derived from TA entry), record binding.",
        "address of caller-local session variable (&session) is passed for output; callee writes TEE-private session pointer back to caller."
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=0,src_sz=0,dst_sz=0",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "sensitivity_label:session",
          "size_triplet:copy_len=sizeof(void*),src_sz=0,dst_sz=0"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0101",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1110,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle",
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'args' parameter aliases ctrlargs initialized from caller ctrl->memref.buffer (caller REE-provided memref), so callee reads REE-visible bytes.",
        "Call-site binding: 'client' parameter is caller's client (origin from tee_session2client) with unclear region/provenance.",
        "Call-site binding: 'sess' parameter is address of caller-local 'session' (TEE-private); callee writes back a session pointer into caller space.",
        "Call-site binding: callee 'args' parameter aliases ctrlargs initialized from ctrl->memref.buffer (caller REE-provided memref), so callee reads from REE-visible buffer.",
        "Call-site binding: callee 'out' parameter is address of local session_handle (TEE-private) so callee writes parsed value into caller-local storage."
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session);",
        "serialargs_get(&ctrlargs, &session_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:unknown",
          "sensitivity_label:session",
          "size_triplet:copy_len=sizeof(struct pkcs11_client *),src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(struct pkcs11_session *),src_sz=unknown,dst_sz=sizeof(struct pkcs11_session *)",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctrl->memref.size,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0102",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1114,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'args' parameter receives address of ctrlargs initialized from ctrl->memref.buffer (caller-controlled REE buffer)",
        "Call-site binding: callee 'out' parameter aliases caller stack variable '&object_handle' (TA-private destination for data parsed from REE-provided buffer)"
      ],
      "code_excerpts": [
        "rc = serialargs_get(&ctrlargs, &object_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=sizeof(struct serialargs)",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctrl->memref.size,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0103",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1128,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "set_pin"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Caller-provided params.memref.buffer (pin) is forwarded into set_pin as new_pin; alias of REE-visible buffer recorded."
      ],
      "code_excerpts": [
        "return set_pin(session, pin, pin_size, PKCS11_CKU_USER);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=new_pin_size,src_sz=ctrl->memref.size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0104",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1134,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "object_is_token",
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'head' aliases obj->attributes from caller (TA-private object attributes passed into helper).",
        "Call-site binding: callee parameter 'head' aliases obj->attributes from caller (TA-private object attributes passed into get_bool)."
      ],
      "code_excerpts": [
        "if (object_is_token(obj->attributes) && !pkcs11_session_is_read_write(session)) {",
        "return get_bool(head, PKCS11_CKA_TOKEN);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=sizeof(uint8_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0105",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1137,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle",
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'args' parameter aliases ctrlargs initialized from ctrl->memref (caller-provided REE buffer).",
        "Call-site binding: callee 'client' parameter is alias of caller 'client' (origin derived from tee_session); provenance uncertain.",
        "Call-site binding: callee 'sess' parameter receives address of local session (TA-private destination).",
        "Call-site binding: 'args' parameter aliases ctrlargs initialized from ctrl->memref (caller-provided REE buffer).",
        "Call-site binding: 'out' parameter is address of local session_handle (TA-private destination)."
      ],
      "code_excerpts": [
        "serialargs_get_session_from_handle(&ctrlargs, client, &session);",
        "rv = serialargs_get(args, &session_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "dst_region:TEE-private",
          "size_triplet:copy_len=sizeof(void *),src_sz=unknown,dst_sz=sizeof(void *)",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=4"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0106",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1141,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'args' parameter receives address of ctrlargs (TA struct that references REE-provided buffer).",
        "Call-site binding: 'out' parameter is &wrapping_key_handle (TA-private destination for data copied from args buffer).",
        "Call-site binding: 'size' parameter is sizeof(uint32_t) (caller-provided scalar)."
      ],
      "code_excerpts": [
        "rc = serialargs_get(&ctrlargs, &wrapping_key_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=sizeof(uint32_t)",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=4,src_sz=4,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0107",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1144,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_access_attrs_against_token"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'session' parameter aliases a session derived from ctrl buffer (which originates from REE), so session is REE-influenced.",
        "Call-site binding: 'head' parameter aliases obj->attributes which is TA-private attributes storage."
      ],
      "code_excerpts": [
        "rc = check_access_attrs_against_token(session, obj->attributes);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:session",
          "size_triplet:copy_len=sizeof(struct pkcs11_session *),src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct obj_attrs),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0108",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1149,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_alloc_get_one_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'args' parameter aliases ctrlargs derived from ctrl->memref.buffer (caller-provided shared buffer).",
        "Call-site binding: callee 'out' parameter is &proc_params (TA-private pointer out on stack) passed by caller."
      ],
      "code_excerpts": [
        "rc = serialargs_alloc_get_one_attribute(&ctrlargs, &proc_params);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=sizeof(void*)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0109",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1151,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "object_is_copyable"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'head' parameter aliases obj->attributes (TA-private object attributes) passed from entry_copy_object."
      ],
      "code_excerpts": [
        "if (!object_is_copyable(obj->attributes)) {"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct obj_attrs *),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0110",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1171,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_attrs_against_modification",
        "attribute_is_modifiable"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'session' parameter aliases session derived from caller (originates from ctrl buffer -> possible REE influence)",
        "Call-site binding: 'head' parameter aliases attributes built from template that originated from REE-supplied ctrl buffer",
        "Call-site binding: 'obj' parameter is TA object pointer from handle lookup (TA-private)",
        "Call-site binding: 'session' parameter aliases session derived earlier (origin traces to ctrl buffer/session lookup)",
        "Call-site binding: 'req_attr' (&cli_ref) aliases parsed attribute header coming from REE-supplied head buffer"
      ],
      "code_excerpts": [
        "rc = check_attrs_against_modification(session, head, obj, function);",
        "if (!attribute_is_modifiable(session, &cli_ref, obj, class, function))"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:session",
          "size_triplet:copy_len=sizeof(struct pkcs11_session *),src_sz=unknown,dst_sz=unknown",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=head->attrs_size,src_sz=ctrl->memref.size,dst_sz=head->attrs_size",
          "src_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct pkcs11_object *),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(struct pkcs11_attribute_head),src_sz=head->attrs_size,dst_sz=sizeof(struct pkcs11_attribute_head)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0111",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1200,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_parent_attrs_against_processing"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: proc_params->id (proc_id) passed from caller; origin derived from parsed ctrl args (caller-controlled).",
        "Call-site binding: 'function' argument forwarded from upstream (processing_func) — caller-controlled enum.",
        "Call-site binding: wrapping_key->attributes passed as 'head' — alias of object attributes (TA-held) but contents originate from object state; origin considered TEE-private."
      ],
      "code_excerpts": [
        "rc = check_parent_attrs_against_processing(proc_params->id, function, wrapping_key->attributes);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:public",
          "size_triplet:copy_len=4,src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=4,src_sz=4,dst_sz=unknown",
          "src_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0112",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1223,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed to update_persistent_db is alias of TA-internal token (origin TA-private) from check_user_pin."
      ],
      "code_excerpts": [
        "update_persistent_db(token);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=?,src_sz=sizeof(*token->db_main),dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0113",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1234,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed to update_persistent_db is alias of TA-internal token (origin TA-private) from check_user_pin."
      ],
      "code_excerpts": [
        "update_persistent_db(token);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=?,src_sz=sizeof(*token->db_main),dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0114",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1242,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed to update_persistent_db is alias of TA-internal token (origin TA-private) from check_user_pin."
      ],
      "code_excerpts": [
        "update_persistent_db(token);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=?,src_sz=sizeof(*token->db_main),dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0115",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1247,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptr"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'head' parameter aliases wrapping_key->attributes (object attributes) from caller; origin is TA object storage (TA-private).",
        "Call-site binding: 'attribute' parameter is a compile-time constant (PKCS11_CKA_WRAP_TEMPLATE) from caller; non-sensitive scalar.",
        "Call-site binding: 'attr_ptr' parameter is &req_attrs (caller local); callee may store pointer into caller variable (alias of TA-private stack/heap).",
        "Call-site binding: 'attr_size' parameter is &size (caller local uint32_t); callee writes size back to caller-controlled variable."
      ],
      "code_excerpts": [
        "rc = get_attribute_ptr(wrapping_key->attributes, PKCS11_CKA_WRAP_TEMPLATE, &req_attrs, &size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "sensitivity_label:public",
          "size_triplet:copy_len=4,src_sz=4,dst_sz=unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(void*),src_sz=sizeof(void*),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0116",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1250,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "attributes_match_reference"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'candidate' parameter aliases key->attributes (TA-private) passed from caller.",
        "Call-site binding: 'ref' parameter aliases req_attrs (origin from wrapping key attribute retrieval); origin considered TEE-private."
      ],
      "code_excerpts": [
        "if (!attributes_match_reference(key->attributes, req_attrs)) {"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=unknown,src_sz=ref->attrs_count_bytes,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0117",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1256,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "alloc_key_data_to_wrap"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'head' parameter aliases key->attributes from TA object (origin TA-private attributes).",
        "Call-site binding: callee 'data' parameter is &key_data (TA-private out pointer) passed by caller.",
        "Call-site binding: callee 'sz' parameter is &key_sz (TA-private size out parameter) from caller."
      ],
      "code_excerpts": [
        "rc = alloc_key_data_to_wrap(key->attributes, &key_data, &key_sz);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:secret",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "dst_region:TEE-private",
          "size_triplet:copy_len=key_sz,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=4,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0118",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1266,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "wrap_data_by_symm_enc"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'session' passed from caller; origin tied to TA session (unknown region here).",
        "Call-site binding: 'key_data' passed from caller; originates from TA-private key material (sensitive).",
        "Call-site binding: 'key_sz' scalar provided by caller-path; size influences copies.",
        "Call-site binding: 'out_buf' aliases caller-provided params[2].memref.buffer (REE-visible shared).",
        "Call-site binding: '&out_size' aliases params[2].memref.size (REE-tainted) allowing callee to read/modify REE-provided length."
      ],
      "code_excerpts": [
        "rc = wrap_data_by_symm_enc(session, key_data, key_sz, out_buf, &out_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "sensitivity_label:secret",
          "size_triplet:copy_len=key_sz,src_sz=key_sz,dst_sz=unknown",
          "flow_dir:REE->TA",
          "sensitivity_label:public",
          "size_triplet:copy_len=4,src_sz=4,dst_sz=unknown",
          "flow_dir:TA->REE",
          "src_region:REE-visible",
          "dst_region:REE-visible",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0119",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1269,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'args' parameter aliases caller memref buffer (shared/REE-visible serialargs state).",
        "Call-site binding: 'client' parameter originates from caller (tee_session-derived); provenance is from entry and thus unclear.",
        "Call-site binding: 'sess' out-parameter is caller stack pointer receiving session alias; origin inside TA (callee writes *sess)."
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctrl->memref.size,dst_sz=sizeof(uint32_t)",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "size_triplet:copy_len=sizeof(void*),src_sz=sizeof(struct pkcs11_session*),dst_sz=sizeof(struct pkcs11_session*)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0120",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1300,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_so_pin"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'session' argument is alias of session obtained earlier in entry_ck_set_pin (TA-private origin from session store).",
        "Call-site binding: 'old_pin' argument aliases data parsed from caller-provided memref (shared/REE-visible buffer).",
        "Call-site binding: 'old_pin_size' is derived from REE-provided fields and influences internal checks."
      ],
      "code_excerpts": [
        "rc = check_so_pin(session, old_pin, old_pin_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "src_region:REE-visible",
          "sensitivity_label:credential",
          "size_triplet:copy_len=old_pin_size,src_sz=ctrl->memref.size,dst_sz=old_pin_size",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctrl->memref.size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0121",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1306,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "set_pin"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Caller-provided pin pointer passed to set_pin for SO; origin is REE memref buffer so binding is recorded.",
        "Call-site binding: 'session' argument aliases TA session object derived in caller; origin is TA-private session structure.",
        "Call-site binding: 'pin' argument aliases buffer read from caller params (shared/REE-visible), so new_pin originates from REE."
      ],
      "code_excerpts": [
        "return set_pin(session, pin, pin_size, PKCS11_CKU_SO);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=new_pin_size,src_sz=ctrl->memref.size,dst_sz=unknown",
          "src_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=new_pin_size,src_sz=params[0].memref.size,dst_sz=new_pin_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0122",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1319,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "set_pin"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Caller-provided pin pointer passed to set_pin for USER; alias of shared buffer recorded.",
        "Call-site binding: 'session' argument aliases TA session object derived in caller; origin is TA-private session structure.",
        "Call-site binding: 'pin' argument aliases buffer read from caller params (shared/REE-visible), so new_pin originates from REE."
      ],
      "code_excerpts": [
        "return set_pin(session, pin, pin_size, PKCS11_CKU_USER);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=new_pin_size,src_sz=ctrl->memref.size,dst_sz=unknown",
          "src_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=new_pin_size,src_sz=params[0].memref.size,dst_sz=new_pin_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0123",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1468,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "check_so_pin"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'session' argument (from entry path) passed to check_so_pin again; same aliasing risk noted earlier.",
        "Call-site binding: 'pin' argument aliases caller-provided buffer (shared/REE-visible) containing new PIN.",
        "Call-site binding: 'session' argument is alias of session handle derived earlier from REE-supplied serial args; origin region unclear but influences token DB access.",
        "Call-site binding: 'pin' is alias of REE-provided buffer extracted earlier (pin_size-controlled); pin is a credential and used directly in verify_pin.",
        "Call-site binding: 'pin_size' is REE-controlled and drives verify_pin length; insufficient additional validation of range/limits here."
      ],
      "code_excerpts": [
        "rc = check_so_pin(session, pin, pin_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "src_region:REE-visible",
          "sensitivity_label:credential",
          "size_triplet:copy_len=pin_size,src_sz=ctrl->memref.size,dst_sz=pin_size",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(pin_size),src_sz=ctrl->memref.size,dst_sz=pin_size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0124",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1487,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_user_pin"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'session' argument is alias of TA-internal session object created earlier (TA-private origin).",
        "Call-site binding: 'pin' argument is alias of buffer extracted from caller-provided memref (shared/REE-visible origin)."
      ],
      "code_excerpts": [
        "rc = check_user_pin(session, pin, pin_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown",
          "src_region:REE-visible",
          "sensitivity_label:credential",
          "size_triplet:copy_len=?,src_sz=ctrl->memref.size,dst_sz=pin_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0125",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1505,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding of caller 'head' pointer into get_bool parameter; origin may be REE-derived template or TA-created attrs, origin ambiguous."
      ],
      "code_excerpts": [
        "rc = get_attribute(head, attribute, &bbool, &size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=sizeof(*head)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0126",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1560,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "object_is_private"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'head' parameter aliases obj->attributes (TA-private attributes), so callee reads TA-private data."
      ],
      "code_excerpts": [
        "private = object_is_private(head);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0127",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1584,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_attrs_misc_integrity"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding of caller 'head' pointer into callee parameter; origin ambiguous (could be derived from REE template), so attribute integrity depends on upstream parsing."
      ],
      "code_excerpts": [
        "rc = check_attrs_misc_integrity(head);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=sizeof(*head)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0128",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 1635,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding of callee 'args' to ctrlargs which was initialized from caller-provided ctrl->memref.buffer (shared/REE-visible); alias of shared buffer passed into helper.",
        "Binding of callee 'client' to caller 'client' whose provenance is from tee_session2client (tainted/uncertain); records aliasing origin.",
        "Binding of callee 'sess' to address of caller-local session variable (TA-private); callee will write session pointer back into caller storage."
      ],
      "code_excerpts": [
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session); // args binding",
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session); // client binding",
        "rc = serialargs_get_session_from_handle(&ctrlargs, client, &session); // sess binding"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=sizeof(struct serialargs)",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=sizeof(struct pkcs11_client *)",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(void *),src_sz=sizeof(struct pkcs11_session *),dst_sz=sizeof(struct pkcs11_session *)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0129",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 2102,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "parent_key_complies_allowed_processings"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: proc_id argument originates from proc_params->id parsed from REE-provided ctrl buffer (caller-controlled).",
        "Call-site binding: 'head' argument is wrapping_key->attributes (object attributes) — alias of TA-held attributes; origin considered TEE-private."
      ],
      "code_excerpts": [
        "if (!parent_key_complies_allowed_processings(proc_id, head)) {"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:public",
          "size_triplet:copy_len=4,src_sz=unknown,dst_sz=4",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0130",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 2327,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of obj->attributes passed into get_bool; obj is TA-managed (origin from handle resolution) but origin provenance upstream is unknown"
      ],
      "code_excerpts": [
        "return get_bool(obj->attributes, req_attr->id);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0131",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 2340,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "attr_is_modifiable_secret_key"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'attr' parameter (&cli_ref) aliases parsed attribute header coming from REE-supplied head buffer",
        "Call-site binding: 'session' parameter aliases session derived earlier (origin traces to ctrl/session lookup)",
        "Call-site binding: 'obj' parameter is TA object pointer from handle lookup (TA-private)"
      ],
      "code_excerpts": [
        "attr_is_modifiable_secret_key(req_attr, session, obj)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct pkcs11_attribute_head),src_sz=head->attrs_size,dst_sz=sizeof(struct pkcs11_attribute_head)",
          "flow_dir:unknown",
          "src_region:unknown",
          "sensitivity_label:session",
          "size_triplet:copy_len=sizeof(struct pkcs11_session *),src_sz=unknown,dst_sz=unknown",
          "src_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct pkcs11_object *),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0132",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 2346,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "attr_is_modifiable_private_key"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller-provided req_attr pointer passed into callee; req_attr originates from head derived from REE-supplied buffer",
        "alias of caller session pointer passed into callee; session was obtained earlier from serialargs and may be tainted/unknown",
        "alias of obj pointer passed into callee; obj is TA-managed but originates from handle resolution upstream",
        "Call-site binding: 'attr' parameter (&cli_ref) aliases parsed attribute header derived from REE-supplied head buffer",
        "Call-site binding: 'sess' parameter aliases session established earlier (origin traces to ctrl/session lookup)",
        "Call-site binding: 'obj' parameter is TA object pointer from handle lookup (TA-private)"
      ],
      "code_excerpts": [
        "attr_is_modifiable_private_key(req_attr, session, obj)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct pkcs11_attribute_head),src_sz=head->attrs_size,dst_sz=sizeof(struct pkcs11_attribute_head)",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA",
          "src_region:TEE-private",
          "sensitivity_label:session",
          "size_triplet:copy_len=sizeof(struct pkcs11_session *),src_sz=unknown,dst_sz=unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct pkcs11_object *),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0133",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 2414,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'head' parameter aliases 'head' constructed from client-supplied template (originates from ctrl buffer), so callee sees data derived from REE."
      ],
      "code_excerpts": [
        "get_bool(head, PKCS11_CKA_TOKEN)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs *),src_sz=ctrl->memref.size,dst_sz=head->attrs_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0134",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 2423,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'head' argument in get_bool(obj->attributes, ...) is TA-private attributes pointer derived from object"
      ],
      "code_excerpts": [
        "get_bool(obj->attributes, cli_ref.id)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(obj->attributes),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0135",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 2424,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'head' parameter aliases template-derived head (from REE) when checking PKCS11_CKA_PRIVATE"
      ],
      "code_excerpts": [
        "get_bool(head, cli_ref.id)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs *),src_sz=ctrl->memref.size,dst_sz=head->attrs_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0136",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 2798,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptr"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of *pub_head passed from caller into get_attribute_ptr; origin from templates that may contain REE-derived data",
        "attr_ptr (address of id1) from caller passed for writing; callee may populate pointer to data possibly backed by shared buffers"
      ],
      "code_excerpts": [
        "rc = get_attribute_ptr(*pub_head, PKCS11_CKA_ID, &id1, &id1_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs),src_sz=unknown,dst_sz=unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=pointer_write,src_sz=unknown,dst_sz=sizeof(void*)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0137",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/entry.c",
      "line": 2807,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptr"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of *priv_head passed from caller into get_attribute_ptr; origin from templates that may contain REE-derived data"
      ],
      "code_excerpts": [
        "rc = get_attribute_ptr(*priv_head, PKCS11_CKA_ID, &id2, &id2_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0138",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/handle.c",
      "line": 47,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "handle_get"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Writes ptr into db->ptrs[n] (array write); if db->ptrs region is attacker-controlled origin this could overwrite shared memory."
      ],
      "code_excerpts": [
        "if (!db->ptrs[n]) { db->ptrs[n] = ptr; return n; }"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TEE->TEE",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(void *),src_sz=unknown,dst_sz=db->max_ptrs * sizeof(void *)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0139",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/handle.c",
      "line": 49,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "handle_get"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "assignment db->ptrs[n] = ptr writes caller pointer into DB array (possible aliasing of caller memory into handle table)",
        "Assignment db->ptrs[n] = ptr inserts caller pointer into handle table (aliasing) which is a structural risk of in-memory aliasing/ownership but does not reach REE here."
      ],
      "code_excerpts": [
        "if (!db->ptrs[n]) { db->ptrs[n] = ptr; return n; }"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(void *),src_sz=unknown,dst_sz=db->max_ptrs * sizeof(void *)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0140",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/handle.c",
      "line": 64,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemFill"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Zeroing memory at db->ptrs + db->max_ptrs which is derived from realloc'd db->ptrs; destination is TA heap (private) but origin of db may be uncertain.",
        "destination pointer is db->ptrs + db->max_ptrs (caller-managed buffer) being passed to MemFill; origin is reallocated DB array in TA memory",
        "fill byte value (0) passed as argument; constant but included for binding completeness",
        "size expression derived from db->max_ptrs and new_max_ptrs (caller-controlled); arithmetic influences amount of memory written"
      ],
      "code_excerpts": [
        "TEE_MemFill(db->ptrs + db->max_ptrs, 0, (new_max_ptrs - db->max_ptrs) * sizeof(void *));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TEE->TEE",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=(new_max_ptrs - db->max_ptrs) * sizeof(void *),src_sz=unknown,dst_sz=new_max_ptrs * sizeof(void *)",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=(new_max_ptrs - db->max_ptrs) * sizeof(void *),src_sz=1,dst_sz=new_max_ptrs * sizeof(void *)",
          "sensitivity_label:public",
          "size_triplet:copy_len=1,src_sz=1,dst_sz=(new_max_ptrs - db->max_ptrs) * sizeof(void *)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0141",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 136,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'out' parameter (&attr) is caller-local TA storage provided to receive bytes"
      ],
      "code_excerpts": [
        "rc = serialargs_get(args, &attr, sizeof(attr));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(attr),src_sz=unknown,dst_sz=sizeof(attr)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0142",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 163,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'out' parameter is &session_handle (TA-local stack) at caller site; destination is TEE-private local storage.",
        "caller-provided 'args' passed from upstream call-site (second call) is REE-origin serialargs buffer",
        "Call-site binding: 'out' parameter (&session_handle) is caller-local TA variable to receive data",
        "Binding: callee 'args' parameter receives &ctrlargs which was initialized from REE memref buffer -> indirect REE-originated data.",
        "Binding: callee 'out' parameter is &session_handle (caller stack) — destination for decoded value is TA-local but originates from caller-provided buffer."
      ],
      "code_excerpts": [
        "rv = serialargs_get(args, &session_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=sizeof(uint32_t)",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=NA,src_sz=ctrl->memref.size,dst_sz=NA",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "sensitivity_label:session",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=sizeof(uint32_t)",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=sizeof(struct serialargs)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0143",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 206,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_create_object"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: params array from REE passed into entry_create_object; origin is REE-visible memref"
      ],
      "code_excerpts": [
        "rc = entry_create_object(client, ptypes, params);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0144",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 209,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_destroy_object"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding caller-provided 'client' into callee; provenance not proven TEE-private."
      ],
      "code_excerpts": [
        "rc = entry_destroy_object(client, ptypes, params);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0145",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 257,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "create_object",
        "TEE_CreatePersistentObject"
      ],
      "sink_functions": [
        "TEE_CreatePersistentObject",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Persistent object created from obj->attributes which may include untrusted/REE-derived attribute bytes (template); writing to storage using TEE_CreatePersistentObject",
        "Creates persistent object from obj->attributes which may include REE-derived attribute bytes",
        "obj->uuid (UUID) pointer from TA object passed into storage API; origin is TA-managed but provenance may include earlier REE-derived data",
        "obj->attributes buffer (derived from template/head) passed to persistent-create; may contain REE-derived attribute bytes copied into TA storage",
        "address of obj->attribs_hdl passed to API to receive handle; callee will write TA object handle into this location (caller stack/obj)",
        "Persistent object creation copies obj->attributes into secure storage; if attributes contain attacker-controlled bytes (from earlier deserialization) this could persist attacker data.",
        "Binding of callee parameter for UUID to obj->uuid which was produced in-TA by create_object_uuid (server-side origin); ensure provenance accounted for.",
        "Binding of callee parameter for initial object data to obj->attributes; attributes originate from templates parsed earlier (REE-derived then processed), so provenance is mixed/uncertain.",
        "Binding of callee out-parameter attribs handle to &obj->attribs_hdl (TA-private storage) so kernel will write back into TA-owned field."
      ],
      "code_excerpts": [
        "TEE_CreatePersistentObject(TEE_STORAGE_PRIVATE, obj->uuid, sizeof(TEE_UUID), tee_obj_flags, TEE_HANDLE_NULL, obj->attributes, size, &obj->attribs_hdl);",
        "TEE_CreatePersistentObject(..., obj->attributes, size, &obj->attribs_hdl);",
        "..., obj->attributes, size, ...",
        "&obj->attribs_hdl",
        "res = TEE_CreatePersistentObject(..., obj->uuid, sizeof(TEE_UUID), ..., obj->attributes, size, &obj->attribs_hdl);",
        "res = TEE_CreatePersistentObject(..., obj->attributes, size, &obj->attribs_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TEE",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=storage",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=sizeof(TEE_UUID),dst_sz=storage",
          "flow_dir:REE->TEE",
          "flow_dir:TEE->TA",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(TEE_ObjectHandle),src_sz=unknown,dst_sz=sizeof(TEE_ObjectHandle)",
          "flow_dir:unknown",
          "dst_region:unknown",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=unknown,dst_sz=sizeof(TEE_UUID)",
          "flow_dir:REE->TA",
          "src_region:unknown",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=size",
          "size_triplet:copy_len=sizeof(TEE_ObjectHandle),src_sz=unknown,dst_sz=sizeof(obj->attribs_hdl)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0146",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 285,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "create_object"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Assigns generated object handle into caller-provided out_handle."
      ],
      "code_excerpts": [
        "*out_handle = obj_handle;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=sizeof(uint32_t),dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0147",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 301,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_get_attribute_value"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Caller passes params (REE memrefs) into entry_get_attribute_value; these are the origin of tainted data used later."
      ],
      "code_excerpts": [
        "rc = entry_get_attribute_value(client, ptypes, params);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0148",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 366,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TA_InvokeCommandEntryPoint"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies local rc to caller-provided params[0].memref.buffer (REE-visible); destination is shared but data is non-sensitive.",
        "Copies local rc into REE-visible params[0].memref.buffer; destination is shared with REE (caller)."
      ],
      "code_excerpts": [
        "TEE_MemMove(params[0].memref.buffer, &rc, sizeof(rc));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(rc),src_sz=sizeof(rc),dst_sz=params[0].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0149",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 390,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_create_object",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies local obj_handle into out->memref.buffer (caller-provided REE-visible memref) via TEE_MemMove; destination is shared/REE-visible.",
        "Copies obj_handle (non-sensitive) into caller-provided out->memref.buffer (REE-visible); structural info flow to REE but not promoted to unencrypted_output.",
        "Copies obj_handle into caller-provided out->memref.buffer (MEMREF_OUTPUT) — structural risk of writing into shared buffer.",
        "Copies obj_handle into caller-provided REE-visible out->memref.buffer; structural risk of writing to shared buffer (but obj_handle is non-sensitive)",
        "Copies local obj_handle into caller-provided out->memref.buffer (REE-visible); destination is shared but value is non-sensitive.",
        "Copies obj_handle (TA-private) into caller-provided out->memref.buffer (REE-visible), exposing TA-created handle to REE.",
        "Copies a TA-private obj_handle into caller-provided REE-visible memref (MEMREF_OUTPUT); structural risk but not part of evaluated sink line.",
        "Copies local obj_handle into caller-provided REE-visible out->memref.buffer via TEE_MemMove; structural binding of shared output.",
        "Binding: destination parameter aliases caller-provided out->memref.buffer (REE-visible) at this call-site.",
        "Binding: source parameter is address of local obj_handle (TEE-private) at this call-site."
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &obj_handle, sizeof(obj_handle));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(obj_handle),src_sz=sizeof(obj_handle),dst_sz=out->memref.size",
          "src_region:unknown",
          "sensitivity_label:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0150",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 508,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "entry_find_objects_init"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "ptypes must equal exp_pt (MEMREF_INOUT); caller may pass MEMREF_OUTPUT leading to type mismatch and potential misuse of params as input."
      ],
      "code_excerpts": [
        "if (!client || ptypes != exp_pt)\n    return PKCS11_CKR_ARGUMENTS_BAD;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=params[0].memref.size,dst_sz=sizeof(expected_memref)"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0151",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 693,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_find_objects",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies TA-side object handles into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove; writes are bounded by out_count computed from REE size.",
        "Copies TA-side object handles into caller-provided out->memref.buffer; writes are bounded by out_count computed from REE-provided size but remain a structural risk.",
        "Binding: destination parameter aliases out_handles + count*sizeof(uint32_t); origin unclear at call-site.",
        "Binding: source parameter aliases ctx->handles + ctx->next; origin unclear (could be TEE-private or derived from REE).",
        "Binding: destination pointer argument aliases caller-provided out_handles (REE-visible memref) allowing TA->REE writes.",
        "Binding: source pointer argument references TA-private ctx->handles (internal), aliased into memcpy source."
      ],
      "code_excerpts": [
        "TEE_MemMove(out_handles + count * sizeof(uint32_t), ctx->handles + ctx->next, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctx->count*sizeof(uint32_t),dst_sz=out->memref.size",
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=sizeof(uint32_t),dst_sz=unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=unknown",
          "src_region:REE-visible",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=out->memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0152",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 823,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_get_attribute_value"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Construction of 'template' from REE-controlled serialargs; any inconsistency in declared attrs_size vs actual data can make subsequent TEE_MemMove calls unsafe."
      ],
      "code_excerpts": [
        "cur = (char *)template + sizeof(struct pkcs11_object_head); end = cur + template->attrs_size;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=template->attrs_size,src_sz=ctrl->memref.size,dst_sz=template->attrs_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0153",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 832,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "some_helper"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: destination parameter is &cli_head (local stack variable, TEE-private) at this call-site.",
        "Binding: source parameter is cli_ref which likely points into caller-provided serialized attributes (REE-visible); treated as shared.",
        "TEE_MemMove reads client-supplied attribute header into TA-local cli_head; ctrl data is untrusted and must be validated.",
        "Binding: destination &cli_head (TA-private) is written from cli_ref which points into parsed template (origin from REE-controlled params -> template); origin ambiguity."
      ],
      "code_excerpts": [
        "TEE_MemMove(&cli_head, cli_ref, sizeof(cli_head));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=unknown,dst_sz=sizeof(cli_head)",
          "src_region:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0154",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 839,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: destination parameter is &cli_ref->size which aliases caller-provided attribute area (REE-visible).",
        "Binding: source parameter is &cli_head.size (TEE-private local), copied into potentially REE-visible storage."
      ],
      "code_excerpts": [
        "TEE_MemMove(&cli_ref->size, &cli_head.size, sizeof(cli_head.size));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:unknown",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(cli_head.size),src_sz=sizeof(cli_head.size),dst_sz=unknown",
          "src_region:TEE-private"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0155",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 854,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: destination parameter is &cli_ref->size (attribute in caller area, REE-visible).",
        "Binding: source parameter is &cli_head.size (TEE-private) at this call-site."
      ],
      "code_excerpts": [
        "TEE_MemMove(&cli_ref->size, &cli_head.size, sizeof(cli_head.size));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:unknown",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(cli_head.size),src_sz=sizeof(cli_head.size),dst_sz=unknown",
          "src_region:TEE-private"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0156",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 886,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: destination parameter is &cli_ref->size (REE-visible attribute area) at this call-site.",
        "Binding: source is &cli_head.size (TEE-private) copied into caller-visible attr field.",
        "Binding: writes cli_head.size back into cli_ref->size within template (template may originate from REE data parsed earlier)."
      ],
      "code_excerpts": [
        "TEE_MemMove(&cli_ref->size, &cli_head.size, sizeof(cli_head.size));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:unknown",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(cli_head.size),src_sz=sizeof(cli_head.size),dst_sz=unknown",
          "src_region:TEE-private",
          "flow_dir:TA->unknown",
          "dst_region:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0157",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 910,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_get_attribute_value",
        "TEE_MemMove",
        "entry_create_object"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies 'template' (TA-side object describing attributes, may include sensitive attributes flagged earlier) into out->memref.buffer (REE-visible), potentially exposing attributes.",
        "Final copy of template into out->memref.buffer (REE-visible) may expose attribute data if template contains sensitive attributes not filtered earlier.",
        "Copies template (attributes) into REE-visible out buffer; may expose sensitive attributes if attr_sensitive was set earlier.",
        "Later copies template to REE-visible out->memref.buffer; if template contains sensitive attributes or malformed sizes, there is a structural risk of exposing data or truncation.",
        "Template (populated earlier via get_attribute/TEE_MemMove into cli_ref->data) is copied wholesale to REE-visible out->memref.buffer, potentially exposing attributes flagged sensitive.",
        "Copies template (attributes) into out->memref.buffer (REE-visible); attributes may include sensitive flags/values if export gating fails.",
        "Copies TA-constructed template (which may contain attribute values) into REE-visible out->memref.buffer; this is the actual REE-facing copy that could leak attributes if they are sensitive.",
        "Copies TA-owned 'template' (which may include attributes marked sensitive earlier) into REE-visible out->memref.buffer, potentially exposing attribute data.",
        "Copies TA-side attribute template into REE-visible out buffer; may expose attributes (some earlier logic attempts to mark sensitive/unavailable, but residual risk remains).",
        "Copies TA-side 'template' (attributes) into REE-visible out->memref.buffer; may expose sensitive attributes flagged earlier.",
        "Binding: destination parameter aliases out->memref.buffer (REE-visible) for attribute copy.",
        "Binding: source parameter is template which was allocated/filled earlier (likely TEE-private).",
        "TEE_MemMove copies template (TA-private) into caller-provided out->memref.buffer; need to ensure attributes are allowed to be exported.",
        "Binding: copies TA-side 'template' into out->memref.buffer (REE-visible), potentially exposing attributes assembled in TA."
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, template, out->memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=out->memref.size,src_sz=template->attrs_size+sizeof(struct pkcs11_object_head),dst_sz=out->memref.size",
          "size_triplet:copy_len=out->memref.size,src_sz=template?unknown:dynamically_computed,dst_sz=out->memref.size",
          "size_triplet:copy_len=out->memref.size,src_sz=template_size,dst_sz=out->memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0158",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 966,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_get_object_size",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies computed obj_size into out->memref.buffer (caller-provided REE-visible memref) via TEE_MemMove; destination is shared/REE-visible though obj_size is non-sensitive.",
        "Copies computed obj_size into REE-visible out->memref.buffer; destination is shared but obj_size is non-sensitive.",
        "Copies computed obj_size into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though obj_size is non-sensitive.",
        "Copies computed obj_size into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove; destination is shared even though obj_size appears non-sensitive.",
        "Binding: destination parameter aliases out->memref.buffer (REE-visible) receiving obj_size.",
        "Binding: source parameter is &obj_size (TEE-private local), copied to caller-visible buffer.",
        "Binding: writes obj_size (TA-calculated) into out->memref.buffer (REE-visible) — REE-visible destination receives TA data.",
        "Binding callee dest to out->memref.buffer which is caller-provided REE-visible memref",
        "Binding callee src to &obj_size (TA-local value) passed as source",
        "Binding callee len to sizeof(obj_size) immediate value"
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &obj_size, sizeof(obj_size));",
        "call-site: TEE_MemMove(out->memref.buffer, &obj_size, sizeof(obj_size));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(obj_size),src_sz=sizeof(obj_size),dst_sz=out->memref.size",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "dst_region:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0159",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 1209,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_copy_object",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies object attributes from TA-private obj->attributes into freshly allocated TA-private head_new via TEE_MemMove",
        "Copies obj->attributes into freshly allocated head_new (TA-private) before modification; risk: attribute handling may later be exposed if not sanitized.",
        "Copies object attributes from obj->attributes into newly allocated head_new; ensure template_size computed from attrs_size is correct to avoid overflow.",
        "Binding: destination parameter is head_new which is likely TEE-allocated (uncertain), origin ambiguous.",
        "Binding: source parameter is obj->attributes (object-internal storage, TEE-private) at this call-site.",
        "Binding: copies obj->attributes into head_new (allocation in TA) — src is TA object storage, dst is TA allocation; origin linkage to REE-controlled attributes earlier is possible.",
        "Binding callee dest to head_new (allocator-returned buffer) origin unclear",
        "Binding callee src to obj->attributes (object-owned attributes, TA-private)",
        "Binding callee len to template_size (caller-provided size)",
        "Call-site binding: destination 'head_new' is TA-allocated (TEE-private) receiving data from TA-private obj->attributes via TEE_MemMove",
        "Call-site binding: source 'obj->attributes' is TA-private buffer passed into TEE_MemMove"
      ],
      "code_excerpts": [
        "TEE_MemMove(head_new, obj->attributes, template_size);",
        "call-site: TEE_MemMove(head_new, obj->attributes, template_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TEE-private",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=template_size,src_sz=template_size,dst_sz=template_size",
          "flow_dir:unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=template_size,src_sz=template_size,dst_sz=unknown",
          "size_triplet:copy_len=template_size,src_sz=unknown,dst_sz=template_size",
          "src_region:unknown",
          "flow_dir:TA->TA",
          "flow_dir:TEE-private->TA"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0160",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 1237,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_copy_object",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies obj_handle (local, non-sensitive handle) into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove",
        "Copies obj_handle into caller-provided out->memref.buffer (REE-visible); not sensitive but structural channel to REE.",
        "obj_handle (TA-local) is copied into caller-provided out->memref.buffer (REE-visible); check callers for sensitive data exposure.",
        "Copies obj_handle into caller-provided out->memref.buffer (REE-visible); param was checked for size but structural risk of exposing TA-private handles to REE exists.",
        "Copies obj_handle into caller-provided out buffer (MEMREF_OUTPUT) — structural output exposure but not promoted to unencrypted_output.",
        "Copies obj_handle into caller-provided out buffer (REE-visible); obj_handle is non-sensitive but is a structural REE-visible write.",
        "Copies obj_handle into caller-provided out->memref.buffer (REE-visible); confirmed size check earlier ensures out->memref.size == sizeof(obj_handle) but REE-visible destination remains.",
        "Copies obj_handle to caller-provided out buffer; checked earlier that out->memref.size == sizeof(obj_handle).",
        "Writes obj_handle into caller-provided out->memref.buffer (MEMREF_OUTPUT); not promoted to unencrypted_output since data is non-sensitive.",
        "Copies obj_handle into caller-provided out->memref.buffer (REE-visible); needs correct ptypes/size checks (which are present) to avoid misuse.",
        "Copies obj_handle into caller-provided out->memref.buffer (REE-visible); potential information flow to REE though obj_handle is non-sensitive.",
        "Copies obj_handle into caller-provided out buffer (REE-visible); out->memref.size was validated earlier to equal sizeof(obj_handle).",
        "Copies obj_handle into caller-provided out memref; out is REE-visible but obj_handle is non-sensitive.",
        "Copies obj_handle into caller-provided out buffer (REE-visible); currently obj_handle is non-sensitive but this is a REE-facing copy.",
        "Copies obj_handle into caller-provided out->memref.buffer (REE-visible); noted as structural risk though not promoted to unencrypted_output here.",
        "Copies obj_handle into caller-provided out->memref.buffer (REE-visible); structurally notable but not promoted to unencrypted_output.",
        "Binding: destination parameter aliases out->memref.buffer (REE-visible) for returning obj_handle.",
        "Binding: source parameter is &obj_handle (TEE-private local) copied into REE-visible buffer.",
        "Binding: writes obj_handle into out->memref.buffer (REE-visible) — returns TA handle to REE.",
        "Binding callee dest to out->memref.buffer which is caller-provided REE-visible memref",
        "Binding callee src to &obj_handle (TA-local handle) passed as source",
        "Binding callee len to sizeof(obj_handle) immediate value",
        "Call-site binding: destination 'out->memref.buffer' aliases caller-provided REE-visible buffer passed as params[2].memref.buffer",
        "Call-site binding: source '&obj_handle' is TA-local value copied into caller's REE-visible buffer"
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &obj_handle, sizeof(obj_handle));",
        "call-site: TEE_MemMove(out->memref.buffer, &obj_handle, sizeof(obj_handle));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(obj_handle),src_sz=sizeof(obj_handle),dst_sz=out->memref.size",
          "sensitivity_label:unknown",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0161",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 1528,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'head' parameter aliases caller's attributes pointer; origin (REE-shared template vs TA-owned attributes) is ambiguous.",
        "Binding: caller passes obj attrs pointer into get_bool; origin of attributes is TA object storage (TEE-private) though ultimately influenced by REE-driven operations."
      ],
      "code_excerpts": [
        "return get_bool(head, PKCS11_CKA_PRIVATE);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0162",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 1538,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "callee 'head' parameter aliases obj->attributes from caller (TA-private); provenance affects authorization checks that use returned boolean"
      ],
      "code_excerpts": [
        "return get_bool(head, PKCS11_CKA_MODIFIABLE);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0163",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 1588,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "get_attribute reads into bbool using size from caller-derived data; caller-provided template/head may come from REE without strong validation"
      ],
      "code_excerpts": [
        "if (get_bool(head, PKCS11_CKA_TRUSTED) &&"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(bbool),src_sz=ctrl->memref.size,dst_sz=sizeof(bbool)"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0164",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 2179,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: head parameter is obj->attributes (TA-private attributes structure) passed from caller"
      ],
      "code_excerpts": [
        "return get_bool(obj->attributes, attr->id);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct obj_attrs *),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0165",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 2414,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: head parameter aliases 'head' built from client-supplied template (originates from REE-provided ctrl buffer)",
        "Call-site binding: first arg 'head' here aliases head built from template that originated from REE-supplied ctrl buffer"
      ],
      "code_excerpts": [
        "if (cli_ref.id == PKCS11_CKA_TOKEN && get_bool(head, PKCS11_CKA_TOKEN))",
        "if (cli_ref.id == PKCS11_CKA_TOKEN && get_bool(head, PKCS11_CKA_TOKEN)) {"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs *),src_sz=head->attrs_size,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(uint8_t),src_sz=head->attrs_size,dst_sz=sizeof(uint8_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0166",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 2423,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: first call reads parent_priv from obj->attributes (TA-private)"
      ],
      "code_excerpts": [
        "bool parent_priv = get_bool(obj->attributes, cli_ref.id);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(uint8_t),src_sz=unknown,dst_sz=sizeof(uint8_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0167",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/object.c",
      "line": 2424,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_bool"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: second call reads obj_priv from head (attributes derived from REE template)"
      ],
      "code_excerpts": [
        "bool obj_priv = get_bool(head, cli_ref.id);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint8_t),src_sz=head->attrs_size,dst_sz=sizeof(uint8_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0168",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 48,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "TEE_OpenPersistentObject"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Uses file name derived from token to open persistent object (TEE_OpenPersistentObject); persistent destination protection and filename contents not proven.",
        "Uses filename derived from token to open persistent object; persistent destination protection and filename contents not fully proven.",
        "Uses token-derived filename buffer to open a persistent object; filename may be influenced by token state which can reflect REE-controlled inputs.",
        "Opens persistent object using filename buffer; if filename is attacker-influenced, this affects which persistent object is accessed/created.",
        "Opens/creates persistent object using TA-derived file name; structural interaction with persistent storage.",
        "TEE_OpenPersistentObject may write persistent-object handle into caller-provided out_hdl which aliases caller storage (db_hdl)",
        "TEE_OpenPersistentObject is invoked with local 'file' buffer produced from token; filename derives from token and is used to open persistent storage.",
        "Filename computed by snprintf is used to open a persistent object; filename provenance is influenced by token/session originating from REE-derived handle."
      ],
      "code_excerpts": [
        "return TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE, file, sizeof(file), TEE_DATA_FLAG_ACCESS_READ | TEE_DATA_FLAG_ACCESS_WRITE, out_hdl);",
        "return TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE, file, sizeof(file), ..., out_hdl);",
        "TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE, file, sizeof(file), ..., out_hdl);",
        "return TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE, file, sizeof(file), ... , out_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:credential",
          "size_triplet:copy_len=sizeof(file),src_sz=sizeof(file),dst_sz=unknown",
          "flow_dir:unknown",
          "dst_region:TEE-private",
          "flow_dir:TA->TEE-private",
          "size_triplet:copy_len=sizeof(file),src_sz=PERSISTENT_OBJECT_ID_LEN,dst_sz=unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=PERSISTENT_OBJECT_ID_LEN,src_sz=PERSISTENT_OBJECT_ID_LEN,dst_sz=unknown",
          "flow_dir:TA->TEE|unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(TEE_ObjectHandle),src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->REE"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0169",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 64,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db",
        "TEE_WriteObjectData"
      ],
      "sink_functions": [
        "TEE_WriteObjectData",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Writes TA-held token->db_main into persistent storage via TEE_WriteObjectData; persistent destination region and protection are not proven here.",
        "Writes TA-held token->db_main into persistent storage via TEE_WriteObjectData; persistent destination protection is not proven here.",
        "TEE_WriteObjectData writes token->db_main (which may include REE-derived credential hashes) to persistent storage; recorded as TEE-private persistent write of sensitive data.",
        "Writes token->db_main (contains PIN hashes/flags) to persistent storage via TEE_WriteObjectData; sensitive credential material persisted.",
        "Writes token->db_main (contains PIN hashes/flags) to persistent storage; sensitive credential material is persisted.",
        "Writes token->db_main (contains PIN-related fields) to persistent storage via TEE_WriteObjectData; sensitive credential material may be persisted.",
        "Writes token->db_main (contains PIN-related fields) to persistent storage; sensitive credential material may be persisted.",
        "Writes the token->db_main structure to persistent storage via TEE_WriteObjectData; persisted data contains credential-related fields (PIN counters/hashes).",
        "Writes TA-private persistent DB (may include credential-related fields) to persistent storage handle.",
        "Writes TA-private token->db_main structure into a persistent TEE object via TEE_WriteObjectData; data includes sensitive token state.",
        "Writes TA-private token state into persistent TEE object; structural sensitive persistence.",
        "Call-site binding: db_hdl is an object handle created locally (open_db_file) passed into TEE_WriteObjectData; origin is TA-managed handle.",
        "Call-site binding: buf argument token->db_main is TA memory (but influenced by earlier REE-derived token_id); alias of TA structure passed to write API.",
        "Writes TA-held token database structure to persistent storage via TEE_WriteObjectData; destination protection/visibility not proven here.",
        "Buffer argument token->db_main (may include credential hashes derived from REE PIN) is passed into write API; binding of caller-owned data recorded.",
        "TEE_WriteObjectData persists token->db_main which contains credential hashes derived from REE PIN; recorded as TEE-private persistent write of sensitive data.",
        "Call-site binding: 'db_hdl' is produced by open_db_file and passed into TEE_WriteObjectData; origin is TEE object handle used for persistent storage.",
        "Writes token->db_main (contains PIN hashes/flags) from TA memory into persistent object via TEE_WriteObjectData; sensitive credential material persisted.",
        "Persists token->db_main (contains PIN hashes and flags) to persistent storage; sensitive credential material is being written.",
        "Persists token->db_main (contains PIN/hash/counters) to storage via TEE_WriteObjectData; sensitive credential material is written to persistent storage.",
        "Call-site binding: data pointer 'token->db_main' originates from TA token state (contains PIN-related fields) passed into writer.",
        "Persists token->db_main (contains PIN/hash/counters) to persistent storage; sensitive credential material is written within TEE.",
        "Call-site binding: data buffer argument originates from token->db_main (credential-related structure) and is written to persistent storage.",
        "Call-site binding: db_hdl originates from open_db_file(token,&db_hdl) and is used as destination handle for write; origin tied to token persistent storage.",
        "Write operation persists credential-related fields (PIN counters/hashes); persisting sensitive state to storage.",
        "Writes credential-related token->db_main to persistent storage; sensitive TA state persisted even though not exposed to REE here.",
        "Call-site binding: buffer 'token->db_main' (TA-private persistent DB state, may contain credential fields) passed into TEE_WriteObjectData for persistence.",
        "Call-site binding: 'db_hdl' is handle returned by open_db_file (TEE object handle, TA-private origin).",
        "Call-site binding: 'token->db_main' buffer (TA-private) written into persistent object; contains sensitive token state.",
        "Writes TA-private token->db_main into persistent TEE object; contains sensitive token state but remains in TEE storage."
      ],
      "code_excerpts": [
        "res = TEE_WriteObjectData(db_hdl, token->db_main, sizeof(*token->db_main));",
        "TEE_WriteObjectData(db_hdl, token->db_main, sizeof(*token->db_main));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:credential",
          "size_triplet:copy_len=sizeof(*token->db_main),src_sz=sizeof(*token->db_main),dst_sz=unknown",
          "flow_dir:TA->TA",
          "dst_region:TEE-private",
          "flow_dir:TA->REE",
          "flow_dir:unknown",
          "flow_dir:TEE-private->TEE-private",
          "sensitivity_label:private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "flow_dir:REE->TA",
          "size_triplet:copy_len=sizeof(*token->db_main),src_sz=unknown,dst_sz=unknown",
          "src_region:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0170",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 105,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_GenerateRandom"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: local variable 's' (TA-private) passed as buffer to TEE_GenerateRandom; RNG output written into TA storage.",
        "Address of local s (TEE-private stack) is passed as destination to TEE_GenerateRandom; random written into TEE-private variable.",
        "Call-site binding: destination &s is TA-local storage (TEE-private) receiving generated randomness (random considered non-sensitive by default)."
      ],
      "code_excerpts": [
        "TEE_GenerateRandom(&s, sizeof(s));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:random",
          "size_triplet:copy_len=sizeof(s),src_sz=unknown,dst_sz=sizeof(s)",
          "flow_dir:TA->TA",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(s),src_sz=0,dst_sz=sizeof(s)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0171",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 314,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "create_object_uuid"
      ],
      "sink_functions": [
        "TEE_GenerateRandom"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Allocates obj->uuid via TEE_Malloc and fills with TEE_GenerateRandom; randomness treated public by default but uuid uniqueness loop queries persistent store."
      ],
      "code_excerpts": [
        "TEE_GenerateRandom(obj->uuid, sizeof(TEE_UUID));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA-internal",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:random",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=sizeof(TEE_UUID),dst_sz=sizeof(TEE_UUID)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0172",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 322,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_GenerateRandom"
      ],
      "sink_functions": [
        "=",
        "TEE_GenerateRandom"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: obj->uuid (persistent object field, TA-private) passed as buffer to TEE_GenerateRandom; RNG fills UUID in-place.",
        "obj->uuid (TEE-private object field) is used as destination for random bytes to generate a UUID; binding of destination recorded.",
        "Call-site binding: destination obj->uuid is TA-managed persistent object field (TEE-private) filled with randomness for UUID; origin is TA-private.",
        "Fills obj->uuid (TEE_Malloc'd) with random bytes; randomness treated non-sensitive by default though used as persistent object identifier.",
        "Binding: obj->uuid (allocated in TA) passed as buffer argument to TEE_GenerateRandom; origin is TEE_Malloc'd memory in TA.",
        "Generates random bytes directly into obj->uuid (TA-allocated buffer); buffer originates from TEE_Malloc and is TA-private but derived object may be later persisted or exposed."
      ],
      "code_excerpts": [
        "TEE_GenerateRandom(obj->uuid, sizeof(TEE_UUID));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=unknown,dst_sz=sizeof(TEE_UUID)",
          "flow_dir:TA->TA",
          "src_region:unknown",
          "sensitivity_label:public",
          "sensitivity_label:random",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=0,dst_sz=sizeof(TEE_UUID)",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=sizeof(TEE_UUID),dst_sz=sizeof(TEE_UUID)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0173",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 371,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "unregister_persistent_object"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Allocation size for ptr derived from token->db_objs->count; if count is inconsistent this may lead to incorrect sizing for subsequent copies."
      ],
      "code_excerpts": [
        "ptr = TEE_Malloc(sizeof(struct token_persistent_objs) + ((token->db_objs->count - 1) * sizeof(TEE_UUID)), ...);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs)+((token->db_objs->count - 1)*sizeof(TEE_UUID)),src_sz=unknown,dst_sz=sizeof(struct token_persistent_objs)+((token->db_objs->count - 1)*sizeof(TEE_UUID))"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0174",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 388,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "unregister_persistent_object",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Uses idx (from get_persistent_obj_idx) to compute copy lengths and offsets for TEE_MemMove/array shifts; if idx arithmetic is wrong it may miscompute sizes.",
        "Uses idx from get_persistent_obj_idx to compute copy lengths and offsets for TEE_MemMove; incorrect idx arithmetic could miscompute sizes.",
        "Copies persistent DB header and first part of UUID array into a freshly allocated buffer using a size derived from idx; idx is validated but buffer arithmetic should be reviewed",
        "Copies token->db_objs into locally allocated ptr based on idx-derived length; index and sizes depend on token->db_objs contents.",
        "Copies token->db_objs into local ptr using idx-derived length; sizes depend on token->db_objs contents.",
        "TEE_MemMove copies token->db_objs into newly allocated ptr using idx derived from get_persistent_obj_idx(token, uuid); idx influenced by uuid which originated from earlier REE-driven handle parsing.",
        "Copies DB metadata influenced by idx derived from uuid parsed earlier (provenance from REE-derived handle).",
        "Binding: destination argument 'ptr' is TA-allocated buffer (TEE_Malloc) passed as dest.",
        "Binding: source argument 'token->db_objs' is TA-owned database structure passed as src.",
        "Length depends on idx (from get_persistent_obj_idx) and token->db_objs->count; arithmetic may miscompute copy length if counts/idx inconsistent.",
        "Initial TEE_MemMove uses idx-derived length; arithmetic assumptions on counts may be incorrect without explicit bounds at the call.",
        "Copies from token->db_objs (persistent DB) into freshly allocated ptr using idx-derived length; source is TA-managed persistent data but index and size depend on token->db_objs->count",
        "Allocation and copy lengths depend on token->db_objs->count and idx; if metadata is corrupted elsewhere this could lead to incorrect sizing.",
        "Copies token->db_objs into newly allocated ptr using idx-derived length; sizes depend on token->db_objs contents.",
        "Copy from token->db_objs into freshly allocated ptr using idx-derived length; source and destination are TA-managed persistent structures.",
        "Destination 'ptr' is allocated from TEE_Malloc and then written from token->db_objs; copy length depends on idx derived from uuid (REE-influenced handle).",
        "Binding dst parameter 'ptr' to caller allocation (TEE_Malloc) at call-site; origin is TEE-private.",
        "Binding src parameter 'token->db_objs' (TEE-private) to callee src; contains persistent DB entries.",
        "TEE_MemMove copies DB entries into newly allocated ptr using idx derived from uuid parsed earlier; provenance of uuid is REE-influenced upstream."
      ],
      "code_excerpts": [
        "TEE_MemMove(ptr, token->db_objs, sizeof(struct token_persistent_objs) + idx * sizeof(TEE_UUID));",
        "TEE_MemMove(ptr, token->db_objs, ...);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:TA->TEE-private",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs)+idx*sizeof(TEE_UUID),src_sz=sizeof(struct token_persistent_objs)+token->db_objs->count*sizeof(TEE_UUID),dst_sz=sizeof(struct token_persistent_objs)+((token->db_objs->count - 1) * sizeof(TEE_UUID))",
          "flow_dir:TEE->TEE",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs)+idx*sizeof(TEE_UUID),src_sz=unknown,dst_sz=sizeof(ptr)",
          "flow_dir:unknown",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs) + idx * sizeof(TEE_UUID),src_sz=sizeof(struct token_persistent_objs) + token->db_objs->count * sizeof(TEE_UUID),dst_sz=sizeof(struct token_persistent_objs) + ((token->db_objs->count - 1) * sizeof(TEE_UUID))",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs) + idx * sizeof(TEE_UUID),src_sz=sizeof(struct token_persistent_objs) + token->db_objs->count * sizeof(TEE_UUID),dst_sz=sizeof(struct token_persistent_objs) + (token->db_objs->count - 1) * sizeof(TEE_UUID)",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs)+idx*sizeof(TEE_UUID),src_sz=unknown,dst_sz=sizeof(struct token_persistent_objs)+((token->db_objs->count - 1)*sizeof(TEE_UUID))",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs) + idx * sizeof(TEE_UUID),src_sz=unknown,dst_sz=sizeof(struct token_persistent_objs) + ((token->db_objs->count - 1) * sizeof(TEE_UUID))",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs) + idx * sizeof(TEE_UUID),src_sz=sizeof(struct token_persistent_objs) + token->db_objs->count * sizeof(TEE_UUID),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0175",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 395,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "unregister_persistent_object",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Shifts UUID array tail into new buffer based on computed count; index-derived sizes are data-dependent.",
        "TEE_MemMove shifts trailing UUIDs using count derived from ptr->count - idx; count is computed from ptr->count which depends on token->db_objs->count read earlier.",
        "Shifts trailing UUIDs based on computed count; sizes depend on token->db_objs->count.",
        "Binding: destination &ptr->uuids[idx] is region inside TA-allocated 'ptr'.",
        "Binding: source &token->db_objs->uuids[idx + 1] is TA-owned array element used as src.",
        "Copy length 'count * sizeof(TEE_UUID)' derived from ptr->count - idx; if arithmetic under/overflows, copy may be out-of-bounds.",
        "Shift-copy of UUID array uses 'count' derived from ptr->count - idx; missing explicit bounds check at call site.",
        "Shifts tail UUIDs within ptr using count computed from ptr->count - idx; length depends on ptr->count and idx validated earlier",
        "Moves tail UUIDs within persistent lists using count-derived length; count depends on ptr->count and idx.",
        "Copy length computed from ptr->count and idx; while upstream checks make it safe, absence of an immediate explicit count>=0 check is a structural risk.",
        "Shifts trailing UUIDs within ptr from token->db_objs; indices and count drive the copy length (derived from TA data).",
        "Shifts trailing UUIDs using count computed from ptr->count and idx; count derived from token->db_objs->count read earlier.",
        "Binding dst parameter '&ptr->uuids[idx]' to allocated ptr region; destination is TEE-private and index idx is REE-influenced.",
        "Binding src parameter '&token->db_objs->uuids[idx + 1]' to token DB region; source is TEE-private."
      ],
      "code_excerpts": [
        "TEE_MemMove(&ptr->uuids[idx], &token->db_objs->uuids[idx + 1], count * sizeof(TEE_UUID));",
        "TEE_MemMove(&ptr->uuids[idx], &token->db_objs->uuids[idx + 1], ...);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=count * sizeof(TEE_UUID),src_sz=token->db_objs->count*sizeof(TEE_UUID),dst_sz=ptr->count*sizeof(TEE_UUID)",
          "sensitivity_label:private",
          "size_triplet:copy_len=count * sizeof(TEE_UUID),src_sz=(token->db_objs->count - (idx+1)) * sizeof(TEE_UUID),dst_sz=(ptr->count - idx) * sizeof(TEE_UUID)",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=count*sizeof(TEE_UUID),src_sz=(token->db_objs->count - (idx + 1)) * sizeof(TEE_UUID),dst_sz=ptr->count * sizeof(TEE_UUID)",
          "flow_dir:TEE->TEE",
          "size_triplet:copy_len=count * sizeof(TEE_UUID),src_sz=(token->db_objs->count - idx - 1) * sizeof(TEE_UUID),dst_sz=(ptr->count - idx) * sizeof(TEE_UUID)",
          "sensitivity_label:public",
          "size_triplet:copy_len=count * sizeof(TEE_UUID),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=count * sizeof(TEE_UUID),src_sz=unknown,dst_sz=(ptr->count - idx) * sizeof(TEE_UUID)",
          "size_triplet:copy_len=count * sizeof(TEE_UUID),src_sz=(token->db_objs->count - (idx+1)) * sizeof(TEE_UUID),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0176",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 399,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "unregister_persistent_object",
        "TEE_WriteObjectData"
      ],
      "sink_functions": [
        "TEE_WriteObjectData",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_WriteObjectData writes updated ptr to persistent storage; data derived from token->db_objs with sizes computed from ptr->count.",
        "Writes updated DB contents to persistent storage; data derived from token->db_objs and influenced by earlier REE-provided handle selection.",
        "Pointer 'ptr' passed as buffer to write API; origin may include persistent object list derived from TA data, binding recorded.",
        "Persists object list structure (ptr) to storage; written blob size depends on ptr->count which may reflect TA state influenced by REE inputs.",
        "Call-site binding: 'ptr' data pointer aliases TA-managed persistent objects structure passed into writer.",
        "Call-site binding: buffer 'ptr' (token persistent objects blob) passed to TEE_WriteObjectData to store objects metadata persistently.",
        "Call-site binding: 'db_hdl' is TEE object handle used for write (TEE-private origin).",
        "Call-site binding: 'ptr' buffer (TA-private persistent objs) is written to storage; size derived from ptr->count."
      ],
      "code_excerpts": [
        "res = TEE_WriteObjectData(db_hdl, ptr, sizeof(struct token_persistent_objs) + ptr->count * sizeof(TEE_UUID));",
        "TEE_WriteObjectData(db_hdl, ptr, sizeof(struct token_persistent_objs) + ptr->count * sizeof(TEE_UUID));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TEE->REE",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs) + ptr->count * sizeof(TEE_UUID),src_sz=sizeof(struct token_persistent_objs) + ptr->count * sizeof(TEE_UUID),dst_sz=unknown",
          "flow_dir:TA->TA",
          "dst_region:TEE-private",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs) + ptr->count * sizeof(TEE_UUID),src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0177",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 435,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "register_persistent_object",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies provided uuid into token->db_objs (persistent index) via TEE_MemMove; source uuid provenance uncertain (may be REE-derived)",
        "Copies uuid into token persistent index; uuid provenance may be REE-influenced",
        "Copies UUID into token->db_objs array via TEE_MemMove/implicit move; destination is token-managed storage grown by TEE_Realloc",
        "Copies UUID into token->db_objs array via TEE_MemMove/implicit move; destination is token-managed storage grown by TEE_Realloc.",
        "Binding: destination token->db_objs->uuids + count is TA-managed array location used as dest.",
        "Binding: source 'uuid' is local/stack or caller-supplied UUID used as src.",
        "Inserts uuid into token->db_objs by copying caller-provided uuid into db array; destination is TA-managed persistent array and source may be external/internal uuid",
        "Copies uuid into token->db_objs array slot; origin of uuid may be internal but binding persists into persistent array.",
        "Copies provided uuid into token->db_objs->uuids area; destination is TA-managed persistent DB memory updated from local uuid.",
        "Inserts uuid into token->db_objs; destination is token->db_objs and source is uuid local buffer.",
        "Binding dst parameter 'token->db_objs->uuids + count' to token DB storage (TEE-private).",
        "Binding src parameter 'uuid' (local buffer) to callee; uuid may be populated from disk earlier and used to create objects.",
        "Destination buffer token->db_objs->uuids+count is TEE-managed memory (realloc result) receiving copied uuid; destination provenance is TEE-private but allocation was recent",
        "Source uuid passed into TEE_MemMove may originate from obj->uuid (potentially derived from REE-supplied attributes), provenance uncertain",
        "The move call writes potentially untrusted uuid bytes into the token index before persisting; persisting later may store REE-derived data",
        "Copies uuid (provenance uncertain, may be derived from REE-supplied template) into token->db_objs index prior to persistence; this persists potentially untrusted data.",
        "Binding call-site dest parameter to token->db_objs->uuids + count (storage just realloc'd); dest originates from TA-managed token storage",
        "Binding call-site src parameter to 'uuid' (caller-provided/generated UUID)",
        "Copies UUID into token->db_objs array; growth and indexing depend on count derived from persistent state — bounds should be validated."
      ],
      "code_excerpts": [
        "TEE_MemMove(token->db_objs->uuids + count, uuid, sizeof(TEE_UUID));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=sizeof(TEE_UUID),dst_sz=sizeof(TEE_UUID)",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=sizeof(TEE_UUID),dst_sz=sizeof(struct token_persistent_objs)+((count+1)*sizeof(TEE_UUID))",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=sizeof(TEE_UUID),dst_sz=(token->db_objs->count - 1 - idx) * sizeof(TEE_UUID)",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=sizeof(TEE_UUID),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0178",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 445,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_TruncateObjectData"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "db handle returned by open_db_file is passed to TEE_TruncateObjectData; handle provenance is TA-private but call truncates persistent storage making provenance a structural risk",
        "Binding of callee handle parameter to caller-local db_hdl obtained from open_db_file; handle is TA-managed object handle",
        "Binding of callee length parameter to computed size expression derived from token structures (caller-controlled counts); length influences truncate extent"
      ],
      "code_excerpts": [
        "res = TEE_TruncateObjectData(db_hdl, size + sizeof(TEE_UUID));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TEE",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size+sizeof(TEE_UUID),src_sz=size,dst_sz=storage_size",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=undefined,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=size+sizeof(TEE_UUID),src_sz=sizeof(struct token_persistent_main)+sizeof(struct token_persistent_objs)+count*sizeof(TEE_UUID),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0179",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 456,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "register_persistent_object",
        "TEE_WriteObjectData"
      ],
      "sink_functions": [
        "TEE_WriteObjectData",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Writes token->db_objs (including uuids array) to persistent storage via TEE_WriteObjectData; this persists data that may have originated outside TEE",
        "Persists token->db_objs (including uuids) to storage; data may originate outside TEE",
        "token->db_objs passed into write API (contains object UUIDs); binding of TA-private structure recorded.",
        "Writes token->db_objs (object listing with UUIDs) to persistent storage; TA-private metadata persisted.",
        "Call-site binding: 'token->db_objs' pointer passed to writer aliases TA-managed structure.",
        "Call-site binding: buffer 'token->db_objs' (TA-private object list including UUIDs) written persistently via TEE_WriteObjectData.",
        "Call-site binding: 'db_hdl' object handle used for write (TEE-private origin).",
        "Call-site binding: 'token->db_objs' buffer (TA-private) written; size depends on token->db_objs->count.",
        "Persists token->db_objs (including uuids array) to storage; persisted data may include bytes originating from untrusted input.",
        "Writes token->db_objs (including uuids array) to persistent storage; this persists data that may have originated outside TEE"
      ],
      "code_excerpts": [
        "res = TEE_WriteObjectData(db_hdl, token->db_objs, sizeof(struct token_persistent_objs) + token->db_objs->count * sizeof(TEE_UUID));",
        "TEE_WriteObjectData(db_hdl, token->db_objs, sizeof(struct token_persistent_objs) + token->db_objs->count * sizeof(TEE_UUID));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TEE",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs)+token->db_objs->count*sizeof(TEE_UUID),src_sz=that,size=disk",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs)+token->db_objs->count*sizeof(TEE_UUID),src_sz=that,dst_sz=storage",
          "flow_dir:TA->TA",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs) + token->db_objs->count * sizeof(TEE_UUID),src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs) + token->db_objs->count * sizeof(TEE_UUID),src_sz=sizeof(struct token_persistent_objs) + token->db_objs->count * sizeof(TEE_UUID),dst_sz=unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(struct token_persistent_objs)+token->db_objs->count*sizeof(TEE_UUID),src_sz=that,dst_sz=disk"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0180",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 561,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "update_persistent_object_attributes"
      ],
      "sink_functions": [
        "TEE_WriteObjectData"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "size computed from obj->attributes->attrs_size (potentially attacker-controlled) is used to write/truncate persistent storage without further validation"
      ],
      "code_excerpts": [
        "size = sizeof(struct obj_attrs) + obj->attributes->attrs_size; res = TEE_WriteObjectData(hdl, obj->attributes, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=obj->attributes->attrs_size,dst_sz=size"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0181",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 563,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_WriteObjectData",
        "update_persistent_object_attributes"
      ],
      "sink_functions": [
        "=",
        "TEE_WriteObjectData"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "obj->attributes (attributes blob) passed into write API; may include sensitive attributes derived from REE PINs, binding recorded.",
        "Writes object attributes (obj->attributes) of size based on attrs_size to storage; persisted attribute blobs may contain sensitive metadata.",
        "Call-site binding: 'obj->attributes' pointer passed to writer aliases TA object attributes memory.",
        "Call-site binding: buffer 'obj->attributes' (object attributes, may include sensitive attributes) written to storage via TEE_WriteObjectData.",
        "Call-site binding: 'hdl' is a TEE object handle (TEE-private) used for write.",
        "Call-site binding: 'obj->attributes' buffer (TA-private) written to object; size from obj->attributes->attrs_size.",
        "Writes obj->attributes to persistent storage using size computed from obj->attributes->attrs_size which may be influenced by earlier REE-derived template; size not strongly validated before write",
        "size computed from obj->attributes->attrs_size (potentially attacker-controlled) is used to write persistent storage without further validation"
      ],
      "code_excerpts": [
        "res = TEE_WriteObjectData(hdl, obj->attributes, size);",
        "TEE_WriteObjectData(hdl, obj->attributes, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=unknown",
          "flow_dir:unknown",
          "size_triplet:copy_len=size,src_sz=sizeof(struct obj_attrs) + obj->attributes->attrs_size,dst_sz=unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TEE-private",
          "src_region:unknown",
          "size_triplet:copy_len=size,src_sz=obj->attributes->attrs_size,dst_sz=size",
          "flow_dir:REE->TA"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0182",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 567,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_TruncateObjectData"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "size derived from obj->attributes->attrs_size (potentially attacker-influenced) is passed to TEE_TruncateObjectData without additional validation"
      ],
      "code_excerpts": [
        "res = TEE_TruncateObjectData(hdl, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=obj->attributes->attrs_size,dst_sz=size"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0183",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 640,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: destination 'uuid' is local variable receiving data read from db_objs.",
        "Copies sizeof(*uuid) from &db_objs->uuids[idx] with idx validated earlier but without redundant bounds check at this call site.",
        "Copies UUID from db_objs into local uuid buffer for object creation; destination uuid buffer provenance depends on caller and is used to create object",
        "Copies UUID from db_objs into local uuid buffer; reads persistent array into caller-provided uuid pointer.",
        "Reads UUID from persistent DB into local uuid buffer; source is token DB object area (TA-private).",
        "Reads uuid from db_objs into uuid local variable; copy length sizeof(*uuid).",
        "Binding dst parameter 'uuid' (local output buffer) to callee; used subsequently to create token object.",
        "Binding src parameter '&db_objs->uuids[idx]' to callee; source is token DB region read from disk earlier.",
        "Binding call-site dest parameter to local 'uuid' buffer (target for read from persistent list)",
        "Binding call-site src parameter to &db_objs->uuids[idx] (persistent array element)"
      ],
      "code_excerpts": [
        "TEE_MemMove(uuid, &db_objs->uuids[idx], sizeof(*uuid));"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(*uuid),src_sz=ptr->count * sizeof(TEE_UUID),dst_sz=sizeof(*uuid)",
          "size_triplet:copy_len=sizeof(*uuid),src_sz=token->db_objs->count * sizeof(TEE_UUID),dst_sz=sizeof(*uuid)",
          "flow_dir:TEE->TEE",
          "sensitivity_label:unknown",
          "flow_dir:TEE->TA",
          "size_triplet:copy_len=sizeof(*uuid),src_sz=sizeof(TEE_UUID),dst_sz=sizeof(*uuid)",
          "flow_dir:unknown",
          "size_triplet:copy_len=sizeof(*uuid),src_sz=unknown,dst_sz=sizeof(*uuid)",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(*uuid),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(*uuid),src_sz=sizeof(TEE_UUID),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0184",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 682,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_TruncateObjectData"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "computed size (sizeof(*db_main)+sizeof(*db_objs)) used to truncate persistent DB object; size provenance should be validated"
      ],
      "code_excerpts": [
        "res = TEE_TruncateObjectData(db_hdl, sizeof(*db_main) + sizeof(*db_objs));"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(*db_main)+sizeof(*db_objs),src_sz=NA,dst_sz=sizeof(*db_main)+sizeof(*db_objs)"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0185",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c",
      "line": 693,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_WriteObjectData"
      ],
      "sink_functions": [
        "=",
        "TEE_WriteObjectData"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "db_objs structure passed into write API to persist empty list; binding recorded for persistent update.",
        "Writes db_objs (possibly empty) to persistent storage; finalizing persistent state via writer.",
        "Call-site binding: 'db_objs' pointer passed to writer aliases TA-managed persistent object header.",
        "Call-site binding: buffer 'db_objs' (empty/reset object list) persisted via TEE_WriteObjectData after initialization.",
        "Call-site binding: 'db_hdl' handle used for final write (TEE-private origin).",
        "Call-site binding: 'db_objs' buffer (TA-private) written to persistent storage; contains persistent object metadata.",
        "Writes db_objs (TA-local DB structure) to persistent storage; binding of db_objs pointer passed into write"
      ],
      "code_excerpts": [
        "res = TEE_WriteObjectData(db_hdl, db_objs, sizeof(*db_objs));",
        "TEE_WriteObjectData(db_hdl, db_objs, sizeof(*db_objs));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(*db_objs),src_sz=sizeof(*db_objs),dst_sz=unknown",
          "flow_dir:unknown",
          "size_triplet:copy_len=sizeof(*db_objs),src_sz=unknown,dst_sz=unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TEE-private",
          "size_triplet:copy_len=sizeof(*db_objs),src_sz=sizeof(*db_objs),dst_sz=sizeof(*db_objs)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0186",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c (call site)",
      "line": 30,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "snprintf"
      ],
      "sink_functions": [
        "=",
        "snprintf"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "name buffer (caller-provided stack array) is passed as destination to snprintf; alias of caller buffer into formatting function.",
        "Formatting output via snprintf writes into caller buffer 'name'; output size depends on get_token_id(token) formatting and size parameter."
      ],
      "code_excerpts": [
        "int n = snprintf(name, size, \"token.db.%u\", get_token_id(token));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=n,src_sz=unknown,dst_sz=size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0187",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c (call site)",
      "line": 44,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_db_file_name"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "token (caller-provided) passed into get_db_file_name; alias of caller token structure into helper.",
        "file buffer (caller stack array) passed as 'name' into get_db_file_name; alias of local buffer into helper."
      ],
      "code_excerpts": [
        "res = get_db_file_name(token, file, sizeof(file));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=n,src_sz=unknown,dst_sz=size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0188",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c (call site)",
      "line": 377,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "token (caller-provided) passed into open_db_file; alias of caller token structure into helper.",
        "&db_hdl (address of local handle) passed as out_hdl into open_db_file; binding of caller stack slot into helper."
      ],
      "code_excerpts": [
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=0,src_sz=sizeof(TEE_ObjectHandle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0189",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c (call site)",
      "line": 441,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "token (caller-provided) passed into open_db_file; alias of caller token structure into helper.",
        "&db_hdl (address of local handle) passed as out_hdl into open_db_file; binding of caller stack slot into helper."
      ],
      "code_excerpts": [
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=0,src_sz=sizeof(TEE_ObjectHandle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0190",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c (call site)",
      "line": 598,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "token (caller-provided) passed into open_db_file; alias of caller token structure into helper.",
        "&db_hdl (address of local handle) passed as out_hdl into open_db_file; binding of caller stack slot into helper."
      ],
      "code_excerpts": [
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=0,src_sz=sizeof(TEE_ObjectHandle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0191",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/persistent_token.c (call site)",
      "line": 662,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_db_file_name"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "token (caller-provided) passed into get_db_file_name; alias of caller token structure into helper.",
        "file buffer (caller stack array) passed as 'name' into get_db_file_name; alias of local buffer into helper."
      ],
      "code_excerpts": [
        "res = get_db_file_name(token, file, sizeof(file));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=n,src_sz=unknown,dst_sz=size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0192",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 220,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_attrs_against_modification"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Reads attribute header from untrusted cur and uses cli_head.size to advance parsing loop without stronger validation."
      ],
      "code_excerpts": [
        "TEE_MemMove(&cli_head, cur, sizeof(cli_head));"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(cli_head),src_sz=end - cur,dst_sz=sizeof(cli_head)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0193",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 352,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_attrs_against_modification"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies data from cur using pkcs11_ref.size (untrusted) even though bounded by MIN(), reliance on parsed size may be risky."
      ],
      "code_excerpts": [
        "TEE_MemMove(&data[0], cur + sizeof(pkcs11_ref), MIN(pkcs11_ref.size, sizeof(data)));"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=MIN(pkcs11_ref.size,sizeof(data)),src_sz=pkcs11_ref.size,dst_sz=sizeof(data)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0194",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 1554,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "check_access_attrs_against_token"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Uses get_class(head) and object_is_private(head) on provided head without explicit null/structure integrity checks beyond switch default"
      ],
      "code_excerpts": [
        "switch (get_class(head)) { ... private = object_is_private(head); }"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=NA,src_sz=NA,dst_sz=NA"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0195",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 1566,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "check_access_attrs_against_token"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Access decision uses session predicates where session is influenced by REE-provided data; untrusted session provenance may affect auth checks."
      ],
      "code_excerpts": [
        "if (private && (pkcs11_session_is_public(session) || pkcs11_session_is_so(session)))"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0196",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 1669,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "check_created_attrs_against_processing"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Asserts that key type matches expected value using get_key_type(head) where head is derived from untrusted templates; malformed attrs could lead to incorrect behavior",
        "Asserts key-type via get_key_type(head) where head is derived from untrusted templates; malformed attrs could disrupt processing."
      ],
      "code_excerpts": [
        "assert(get_key_type(head) == PKCS11_CKK_EC);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0197",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 1885,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "parent_key_complies_allowed_processings"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Parses allowed mechanism list from attributes and compares entries to proc_id (caller-controlled) using TEE_MemMove; relies on attribute contents and size from get_attribute_ptr without strong validation."
      ],
      "code_excerpts": [
        "for (count = size / sizeof(uint32_t); count; count--) { TEE_MemMove(&proc, attr, sizeof(uint32_t)); attr += sizeof(uint32_t); if (proc == proc_id) return true; }"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=size,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0198",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 1886,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "parent_key_complies_allowed_processings"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies 4-byte words from attr buffer (attribute blob) into local proc using length derived from attribute size; relies on attribute contents and size with limited validation.",
        "Copies 4-byte words from attribute buffer into local variable using size-derived loop count; relies on attribute blob size/content correctness."
      ],
      "code_excerpts": [
        "TEE_MemMove(&proc, attr, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=size,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0199",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2178,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "attr_is_modifiable_secret_key"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "uses obj->attributes and attr->id to decide modifiability (get_bool), relying on object state without additional validation of attr contents",
        "Uses attr->id (from untrusted input) to index into obj->attributes via get_bool without validating that id maps to a valid stored attribute"
      ],
      "code_excerpts": [
        "return get_bool(obj->attributes, attr->id);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=NA,src_sz=sizeof(obj->attributes),dst_sz=NA",
          "size_triplet:copy_len=sizeof(attr->id),src_sz=head->attrs_size,dst_sz=sizeof(attr->id)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0200",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2236,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "attr_is_modifiable_private_key"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "uses attr->id (from REE-derived req_attr) to index get_bool(obj->attributes, attr->id) without additional bounds checks on id",
        "Uses untrusted attr->id (from parsed REE data) to decide modifiability and may call get_bool with that id without additional validation"
      ],
      "code_excerpts": [
        "case PKCS11_CKA_EXTRACTABLE: return get_bool(obj->attributes, attr->id);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=NA,src_sz=head->attrs_size,dst_sz=NA",
          "size_triplet:copy_len=sizeof(attr->id),src_sz=head->attrs_size,dst_sz=sizeof(attr->id)"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0201",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2311,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "attribute_is_modifiable"
      ],
      "sink_functions": [
        "=",
        "unknown"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of caller-provided req_attr (derived from REE-supplied head) used directly to switch on id",
        "Decision logic uses req_attr->id (from untrusted parsed data) to control allowances; id-driven branches may allow changes without validating attribute payload/size",
        "Decision logic branches directly on req_attr->id from untrusted parsed data; attribute payload/size not re-validated before allowing modifications."
      ],
      "code_excerpts": [
        "switch (req_attr->id) {",
        "switch (req_attr->id) { ... }"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct pkcs11_attribute_head),src_sz=head->attrs_size,dst_sz=sizeof(struct pkcs11_attribute_head)",
          "size_triplet:copy_len=sizeof(req_attr->id),src_sz=head->attrs_size,dst_sz=sizeof(req_attr->id)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0202",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2380,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "check_attrs_against_modification",
        "TEE_MemMove",
        "TEE_MemMove (callsite)"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "reads attribute header from cur (derived from head which is REE-supplied) and uses cli_ref.size to advance len without fully validating that sizeof(cli_ref)+cli_ref.size stays within end",
        "Parses client-supplied attribute entries from 'head' (derived from caller) with len computed from untrusted cli_ref.size; loop uses cur < end but cli_ref.size not validated against remaining bytes",
        "Parses client-supplied attribute entries into cli_ref using TEE_MemMove without validating cli_ref.size against remaining bytes.",
        "Parses client-supplied attribute entries and copies header without validating cli_ref.size against remaining buffer before using it as a bound.",
        "Reads attribute header from cur (derived from head which is REE-supplied) and uses cli_ref.size to advance len without fully validating that sizeof(cli_ref)+cli_ref.size stays within end",
        "Parses client-supplied attribute headers using cli_ref.size from untrusted buffer without validating that cli_ref.size fits remaining bytes.",
        "reads attribute header from REE-derived blob and uses cli_ref.size to advance parsing without fully validating total length",
        "Parses client-supplied attribute entries using cli_ref.size without validating it against remaining bytes before using it to advance the cursor.",
        "reads attribute header from cur (derived from head which is REE-supplied) and uses cli_ref.size to advance len without fully validating bounds against end",
        "Parses client-supplied attribute headers from head buffer using cli_ref.size without explicit validation against remaining bytes before using cli_ref.size-controlled lengths.",
        "Copies a cli_ref struct from 'cur' pointer into local structure without explicit bounds on cur's provenance/remaining buffer length.",
        "Copies a cli_ref struct from buffer without explicit provenance/remaining-length validation of source.",
        "destination is &cli_ref (local TA stack/TEE-private) bound to callee dst parameter",
        "source pointer 'cur' is derived from head (attributes list) which originates from REE-visible memory",
        "reads header via TEE_MemMove from cur (derived from REE) and then uses cli_ref.size to compute len without proving sizeof(cli_ref)+cli_ref.size <= end",
        "Call-site binding: destination '&cli_ref' is a TA-local stack object (TEE-private)",
        "Source 'cur' points into attributes built from caller data; copying sizeof(cli_ref) before validating cli_ref.size may allow parsing of malformed/short input"
      ],
      "code_excerpts": [
        "TEE_MemMove(&cli_ref, cur, sizeof(cli_ref)); len = sizeof(cli_ref) + cli_ref.size;",
        "TEE_MemMove(&cli_ref, cur, sizeof(cli_ref));"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(cli_ref),src_sz=end - cur,dst_sz=sizeof(cli_ref)",
          "size_triplet:copy_len=sizeof(cli_ref),src_sz=head->attrs_size,dst_sz=sizeof(cli_ref)",
          "flow_dir:unknown",
          "src_region:unknown",
          "size_triplet:copy_len=sizeof(cli_ref),src_sz=unknown,dst_sz=sizeof(cli_ref)",
          "src_region:TEE-private",
          "flow_dir:TA->TEE-private"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0203",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2381,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "check_attrs_against_modification"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "len computed from cli_ref.size (tainted) is used to advance cur; if cli_ref.size is large or causes overflow, loop arithmetic may go out-of-bounds.",
        "cli_ref.size (from untrusted buffer) is used to compute len for advancing cur without validation against remaining bytes, enabling parsing errors or out-of-bounds advances."
      ],
      "code_excerpts": [
        "len = sizeof(cli_ref) + cli_ref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(cli_ref)+cli_ref.size,src_sz=end - cur,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(cli_ref)+cli_ref.size,src_sz=head->attrs_size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0204",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2662,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "alloc_copy_attribute_value",
        "TEE_MemMove",
        "TEE_MemMove (callsite)"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies attribute value (likely TA-private secret) into freshly TEE_Malloc'd buffer using *sz; source sensitivity is secret and buffer is TA-private.",
        "Copies attribute VALUE into allocated buffer using size from get_attribute_ptr without additional validation; upstream header corruption could influence size.",
        "Copies *sz bytes from value into buffer; origin/provenance of value and buffer sizes unclear, risk of overwriting shared memory if buffer is REE-visible.",
        "Copies *sz bytes from value into buffer; provenance and sizes unclear, potential overwrite if buffer is REE-visible.",
        "destination 'buffer' passed to callee; buffer likely TA-allocated (TEE-private) but origin uncertain here",
        "source 'value' passed into callee; origin not clear in this snippet (could be REE or TA)",
        "Call-site binding: destination 'buffer' is TA-allocated (likely TEE_Malloc) and thus TA-private",
        "Call-site binding: source 'value' provenance unclear (could be REE-provided or TA-owned); origin not validated here",
        "Call-site binding: callee first parameter (dest) is buffer allocated by TEE_Malloc in this function (TA-private).",
        "Call-site binding: callee second parameter (src) aliases attribute value from head (TA-private secret).",
        "Call-site binding: callee third parameter (size) is *sz derived from attribute length (TA-controlled).",
        "Copies attribute value (likely secret) into newly allocated TEE-private buffer using *sz; sensitive data flows within TA and is later used for wrapping."
      ],
      "code_excerpts": [
        "TEE_MemMove(buffer, value, *sz);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:secret",
          "size_triplet:copy_len=*sz,src_sz=*sz,dst_sz=*sz",
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=*sz,src_sz=unknown,dst_sz=*sz",
          "size_triplet:copy_len=*sz,src_sz=*sz,dst_sz=unknown",
          "flow_dir:TA->TEE-private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=*sz,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0205",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2736,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "encode_rsa_private_key_der"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Allocates buffer with TEE_Malloc to hold sensitive private-key DER; returns it via *data/*sz making TA-private secret available to caller."
      ],
      "code_excerpts": [
        "buffer = TEE_Malloc(der_size, ...); *data = buffer; *sz = mbedtls_rc;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:secret",
          "size_triplet:copy_len=mbedtls_rc,src_sz=der_size,dst_sz=der_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0206",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2737,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "encode_rsa_private_key_der"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Allocates TA-private buffer to hold sensitive private-key DER and returns it via out parameters; sensitive data becomes available to caller context."
      ],
      "code_excerpts": [
        "buffer = TEE_Malloc(der_size, ...); *data = buffer; *sz = mbedtls_rc;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:secret",
          "size_triplet:copy_len=mbedtls_rc,src_sz=der_size,dst_sz=der_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0207",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2743,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "mbedtls_pk_write_key_der"
      ],
      "sink_functions": [
        "=",
        "mbedtls_pk_write_key_der"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee 'pk' parameter is local mbedtls_pk_context (TA-private) used to produce DER key bytes.",
        "Call-site binding: callee 'buffer' parameter is TA-allocated buffer (TEE_Malloc) and will receive private-key DER bytes.",
        "Call-site binding: callee 'der_size' parameter is caller-provided allocation size (der_size) controlling how many bytes may be written.",
        "Writes private-key DER into TA-private buffer; sensitive data produced and returned to caller via *data/*sz in caller."
      ],
      "code_excerpts": [
        "mbedtls_rc = mbedtls_pk_write_key_der(&pk, buffer, der_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:secret",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=der_size",
          "size_triplet:copy_len=mbedtls_rc,src_sz=unknown,dst_sz=der_size",
          "size_triplet:copy_len=mbedtls_rc,src_sz=der_size,dst_sz=der_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0208",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2750,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "encode_rsa_private_key_der"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Per-byte in-place copy loop moves DER bytes to front of buffer and zeroes tail; operates on TA-private buffer containing secret—ensure loop bounds match mbedtls_rc.",
        "Per-byte in-place copy moves DER bytes to front of buffer and zeroes tail; ensure loop bounds match mbedtls_rc to avoid buffer issues.",
        "Per-byte loop moves DER bytes to buffer front and zeroes tail; requires correct bounds (mbedtls_rc vs der_size)."
      ],
      "code_excerpts": [
        "for (i = 0; i < mbedtls_rc; i++) { buffer[i] = buffer[i + start]; buffer[i + start] = 0; }"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:secret",
          "size_triplet:copy_len=mbedtls_rc,src_sz=der_size,dst_sz=der_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0209",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2772,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "alloc_key_data_to_wrap"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Produces key_data/key_sz from key attributes (secret material) which will later be used for wrapping; sensitive TA-private data is allocated/encoded here."
      ],
      "code_excerpts": [
        "rc = alloc_copy_attribute_value(head, data, sz) / rc = encode_rsa_private_key_der(head, data, sz);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:secret",
          "size_triplet:copy_len=key_sz,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0210",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_attributes.c",
      "line": 2825,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "add_missing_attribute_id"
      ],
      "sink_functions": [
        "set_attribute"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "set_attribute called with id pointer and id_size obtained from get_attribute_ptr without additional validation of provenance or size limits",
        "set_attribute invoked with id pointer and id_size from get_attribute_ptr without stronger validation",
        "set_attribute called with id pointer and id_size obtained from get_attribute_ptr without additional validation of provenance or size limits.",
        "set_attribute called with id pointer/size from get_attribute_ptr without validating provenance or reasonable size limits"
      ],
      "code_excerpts": [
        "return set_attribute(priv_head, PKCS11_CKA_ID, id1, id1_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=id1_size,src_sz=id1_size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0211",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 59,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'out_hdl' (caller-provided address) is written by open_db_file via TEE_OpenPersistentObject; origin is caller-local handle."
      ],
      "code_excerpts": [
        "res = TEE_OpenPersistentObject(TEE_STORAGE_PRIVATE, file, sizeof(file), TEE_DATA_FLAG_ACCESS_READ | TEE_DATA_FLAG_ACCESS_WRITE, out_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(TEE_ObjectHandle),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0212",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 64,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "update_persistent_db"
      ],
      "sink_functions": [
        "TEE_WriteObjectData"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_WriteObjectData persists token->db_main (may include hashes derived from REE-supplied PIN) to persistent storage."
      ],
      "code_excerpts": [
        "res = TEE_WriteObjectData(db_hdl, token->db_main, sizeof(*token->db_main));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=sizeof(*token->db_main),src_sz=sizeof(*token->db_main),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0213",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 170,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_ck_token_mecha_ids"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: callee params pointer aliases caller-provided params (REE-visible) allowing REE-controlled memrefs into the function.",
        "Call-site binding: callee params pointer aliases caller-provided params (REE-visible)."
      ],
      "code_excerpts": [
        "rc = entry_ck_token_mecha_ids(ptypes, params);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0214",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 190,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_ck_token_initialize"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: params (caller-provided memref buffer) aliased into callee parameter (ctrl) — shared REE buffer passed to TA."
      ],
      "code_excerpts": [
        "rc = entry_ck_token_initialize(ptypes, params);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:credential",
          "size_triplet:copy_len=?,src_sz=params[0].memref.size,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0215",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 283,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemFill",
        "pad_str"
      ],
      "sink_functions": [
        "=",
        "TEE_MemFill"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: callee will write into buffer derived from caller-provided pointer 'str' (alias of info field in caller).",
        "Per-byte fill into buffer at offset n; n derived from str content but bounded by size via strnlen.",
        "Destination pointer is caller-derived (str + n); TEE_MemFill writes len bytes at that alias of caller buffer.",
        "fills bytes at str + n for length (size - n) using TEE_MemFill; write target depends on caller-provided pointer/size",
        "alias of caller-provided buffer (str) passed derived (str + n) into TEE_MemFill; write target originates from caller",
        "fills len bytes at destination (dst) using caller-controlled size - n; write depends on caller pointer/size"
      ],
      "code_excerpts": [
        "TEE_MemFill(str + n, ' ', size - n);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size - n,src_sz=unknown,dst_sz=size - n",
          "sensitivity_label:public",
          "size_triplet:copy_len=size - n,src_sz=1,dst_sz=size - n",
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "size_triplet:copy_len=size - n,src_sz=size,dst_sz=size",
          "size_triplet:copy_len=size - n,src_sz=size,dst_sz=unknown",
          "size_triplet:copy_len=size - n,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0216",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 293,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_GetPropertyAsUUID"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Caller passes address of local dev_id into TEE_GetPropertyAsUUID (alias of TA-private buffer bound to callee parameter).",
        "Property name string literal passed to TEE API (binding of callee parameter to a TA-resident const string)."
      ],
      "code_excerpts": [
        "res = TEE_GetPropertyAsUUID(TEE_PROPSET_TEE_IMPLEMENTATION, \"gpd.tee.deviceID\", &dev_id);",
        "\"gpd.tee.deviceID\""
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TEE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(TEE_UUID),src_sz=unknown,dst_sz=sizeof(dev_id)",
          "flow_dir:unknown",
          "dst_region:unknown",
          "sensitivity_label:public",
          "size_triplet:copy_len=unknown,src_sz=sizeof(\"gpd.tee.deviceID\"),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0217",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 305,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "set_token_description",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies formatted desc into info->slot_description via TEE_MemMove; dest and src are TA-private but ultimately flow to caller buffer later.",
        "Copies formatted desc into info->slot_description; although TA-private, this flows later to caller buffer.",
        "Copies local formatted desc into info->slot_description (both TA-private) via TEE_MemMove."
      ],
      "code_excerpts": [
        "TEE_MemMove(info->slot_description, desc, n);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=n,src_sz=sizeof(desc),dst_sz=sizeof(info->slot_description)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0218",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 353,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_ck_slot_info",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies local struct info into caller-provided out->memref.buffer (shared/REE-visible destination).",
        "Copies local struct info into caller-provided out->memref.buffer (REE-visible destination).",
        "Copies local info struct into caller-provided out->memref.buffer (shared/REE-visible destination).",
        "Copies local info struct into caller-provided out->memref.buffer (shared/REE-visible); this is a potential information-disclosure sink to the REE.",
        "Destination out->memref.buffer is caller-provided (REE-visible) and is bound to TEE_MemMove dst parameter (alias of shared buffer).",
        "Local non-sensitive struct info copied into caller-provided REE-visible buffer (shared buffer alias)."
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &info, out->memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=out->memref.size,src_sz=sizeof(info),dst_sz=out->memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0219",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 366,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TA_InvokeCommandEntryPoint"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies local enum rc into caller-provided memref.buffer (REE-visible); destination is shared/REE-visible though rc is non-sensitive."
      ],
      "code_excerpts": [
        "TEE_MemMove(params[0].memref.buffer, &rc, sizeof(rc));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(rc),src_sz=sizeof(rc),dst_sz=params[0].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0220",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 377,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' originates from session->token (path earlier) and is passed to open_db_file; influences persistent DB access.",
        "Call-site binding: out_hdl is &db_hdl (local) and will receive a persistent object handle from callee.",
        "Binding token into open_db_file parameter; token is TA-managed structure."
      ],
      "code_excerpts": [
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=sizeof(TEE_ObjectHandle),dst_sz=unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0221",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 406,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "snprintf"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Destination buffer 'sn' is a TA-local stack buffer (TEE-private) passed to snprintf which writes formatted data there; subsequent memmove copies it into info.serial_number.",
        "Format string argument is a constant (TA-private) passed into snprintf; binding noted for pointer argument provenance."
      ],
      "code_excerpts": [
        "n = snprintf(sn, sizeof(sn), \"%0*\"PRIu32, (int)sizeof(info.serial_number), token_id);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=n,src_sz=unknown,dst_sz=sizeof(sn)",
          "dst_region:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=sizeof(sn)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0222",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 411,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "entry_ck_token_info"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies sn into info.serial_number (TA-private fields) via TEE_MemMove.",
        "Copies into local info.serial_number from sn; src is caller-influenced but destination is TA-private struct field.",
        "TA-local serial string 'sn' (filled by snprintf) is copied into caller-provided out->memref.buffer; destination is REE-visible though data appears non-sensitive.",
        "Copies from local sn into info.serial_number (both TA-local buffers); binding shows both src/dst are TEE-private, so no REE boundary but still a data movement site."
      ],
      "code_excerpts": [
        "TEE_MemMove(info.serial_number, sn, sizeof(info.serial_number));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(info.serial_number),src_sz=sizeof(sn),dst_sz=sizeof(info.serial_number)",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(info.serial_number),src_sz=sizeof(info.serial_number),dst_sz=sizeof(info.serial_number)",
          "flow_dir:TA->REE",
          "dst_region:REE-visible",
          "size_triplet:copy_len=sizeof(info.serial_number),src_sz=sizeof(info.serial_number),dst_sz=out->memref.size",
          "flow_dir:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0223",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 414,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies token label into info.label (both TA-private) via TEE_MemMove.",
        "Copies token label from token DB (TEE-private) into TA-private info.label field; binding of src to callee src parameter."
      ],
      "code_excerpts": [
        "TEE_MemMove(info.label, token->db_main->label, sizeof(info.label));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(info.label),src_sz=PKCS11_TOKEN_LABEL_SIZE,dst_sz=sizeof(info.label)",
          "flow_dir:TEE->TA",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(info.label),src_sz=sizeof(info.label),dst_sz=sizeof(info.label)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0224",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 420,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_ck_token_info",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies TA-local struct info into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove; destination is shared though info appears non-sensitive.",
        "Copies TA-local struct info into caller-provided out->memref.buffer (REE-visible); destination is shared though info appears non-sensitive.",
        "Copies local info into caller out->memref.buffer (shared/REE-visible destination).",
        "Copies local info into caller-provided out->memref.buffer (alias of shared buffer passed as dst).",
        "Copies TA-local struct info into caller-provided out->memref.buffer (REE-visible); binding records shared destination originating from REE params."
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &info, sizeof(info));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(info),src_sz=sizeof(info),dst_sz=out->memref.size",
          "size_triplet:copy_len=sizeof(info),src_sz=sizeof(info),dst_sz=sizeof(info)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0225",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 441,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "open_db_file"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: 'token' passed may be influenced by earlier REE-provided session state; used to compute DB filename.",
        "Call-site binding: out_hdl (&db_hdl) receives object handle; callee controls persistent object access."
      ],
      "code_excerpts": [
        "res = open_db_file(token, &db_hdl);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:credential",
          "size_triplet:copy_len=?,src_sz=unknown,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=sizeof(TEE_ObjectHandle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0226",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 488,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "entry_ck_token_mecha_ids",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_MemMove copies TA-allocated mechanism list into REE-provided out->memref.buffer; out->memref.size earlier used to derive allocation count (attacker-controlled), risking size/alloc validation issues.",
        "Copies array (TA-allocated) into caller out->memref.buffer (REE-visible); caller size set just prior.",
        "Copies array into caller-provided out->memref.buffer; dst aliases REE-visible buffer passed from caller.",
        "Call-site binding: destination parameter aliases caller's out->memref.buffer (REE-visible).",
        "Call-site binding: source parameter aliases TA-allocated 'array' (TEE-private)."
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, array, out->memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=out->memref.size,src_sz=count*sizeof(*array),dst_sz=out->memref.size",
          "size_triplet:copy_len=out->memref.size,src_sz=count * sizeof(*array),dst_sz=out->memref.size",
          "sensitivity_label:unknown",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "size_triplet:copy_len=out->memref.size,src_sz=unknown,dst_sz=out->memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0227",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 501,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_ck_token_mecha_info"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Local aliases ctrl and out point into caller params (shared/REE-visible buffers)"
      ],
      "code_excerpts": [
        "TEE_Param *ctrl = params; TEE_Param *out = params + 2;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=alias,src_sz=ctrl->memref.size,dst_sz=out->memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0228",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 538,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_ck_token_mecha_info",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies TA-constructed info into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove",
        "Copies TA-constructed mechanism info into caller-provided out->memref.buffer (REE-visible).",
        "Copies local info into caller out buffer (REE-visible) via TEE_MemMove.",
        "Copies local info into caller-provided out->memref.buffer (binding dst to shared buffer).",
        "Call-site binding: destination parameter aliases caller's out->memref.buffer (REE-visible).",
        "Call-site binding: source parameter is address of TA-local 'info' (TEE-private).",
        "Call-site binds callee dest to caller-provided out->memref.buffer (shared/REE-visible) and src to TA-local &info — alias of shared buffer passed into helper",
        "Copies TA-constructed info into caller-provided out->memref.buffer (shared/REE-visible); size check enforced but structural aliasing to shared buffer remains a risk if semantics change."
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &info, sizeof(info));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(info),src_sz=sizeof(info),dst_sz=out->memref.size",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0229",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 678,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies session handle into caller out buffer (REE-visible destination).",
        "Copies session handle into caller-provided out buffer (dst is REE-visible from caller).",
        "Call-site binding: destination parameter aliases caller's out->memref.buffer (REE-visible) at session handle return.",
        "Call-site binding: source parameter is TA-local session->handle (TEE-private).",
        "Call-site binds dest to caller-provided out->memref.buffer (shared/REE-visible) and src to TA session handle — alias of shared buffer passed into helper",
        "Copies session->handle (TEE-private) into caller-provided out->memref.buffer (REE-visible), binding callee dest/src to shared/TEE origins."
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &session->handle, sizeof(session->handle));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(session->handle),src_sz=sizeof(session->handle),dst_sz=out->memref.size",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:private",
          "sensitivity_label:public"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0230",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 810,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "entry_ck_session_info"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies info into caller out buffer (REE-visible) via TEE_MemMove.",
        "Copies local info into caller-provided out->memref.buffer; dst is alias of shared buffer.",
        "Call-site binding: destination parameter aliases caller's out->memref.buffer (REE-visible) when returning info.",
        "Call-site binding: source parameter is TA-local 'info' struct (TEE-private).",
        "Call-site binds dest to caller-provided out->memref.buffer (shared/REE-visible) and src to TA-local info structure",
        "Copies local info (TEE-private) into caller-provided out->memref.buffer (REE-visible), binding callee params to shared/TEE origins.",
        "Destination is caller-provided memref buffer (REE-visible) while source is TA-private struct 'info'; binding shows TA writing into REE-shared memory.",
        "Source '&info' is TA-private and is copied into a REE-visible buffer (out->memref.buffer); records binding of callee src parameter to TA-private origin.",
        "TA-local session info is copied into a REE-visible memref; structurally this is TA->REE data flow which would be sensitive if 'info' contained secrets."
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &info, sizeof(info));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(info),src_sz=sizeof(info),dst_sz=out->memref.size",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "sensitivity_label:session"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0231",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 943,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "entry_ck_token_initialize"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies label into token->db_main->label (TA-private destination) via TEE_MemMove.",
        "Copies caller-provided label into token DB field (dst is TA-private but src is REE-visible); binding src to callee src parameter.",
        "Call-site binding: destination parameter aliases TA-local token DB label buffer (TEE-private) being written to by caller before move.",
        "Call-site binding: source parameter 'label' originates from REE (caller-provided).",
        "Call-site copies label into token->db_main->label; dest is TA-private while source 'label' provenance is unclear (likely REE-origin), so alias binding recorded",
        "Copies from 'label' into token->db_main->label; source provenance unclear (could be REE), destination is TEE-private—binding observed.",
        "TEE_MemMove copies label into token DB; source provenance unclear (could be REE), so structural risk flagged.",
        "Destination token label field is TA-internal (TEE-private); binding records callee dst param aliasing TA storage.",
        "Source 'label' origin is unclear (could be REE-provided); binding records callee src param origin uncertainty.",
        "Binding dest parameter to token->db_main->label (TA-private destination) at call-site; destination is TA storage.",
        "Binding src parameter to 'label' which was populated from caller-controlled serialargs (REE-origin); input may be attacker-controlled."
      ],
      "code_excerpts": [
        "TEE_MemMove(token->db_main->label, label, PKCS11_TOKEN_LABEL_SIZE);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=PKCS11_TOKEN_LABEL_SIZE,src_sz=PKCS11_TOKEN_LABEL_SIZE,dst_sz=PKCS11_TOKEN_LABEL_SIZE",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "src_region:unknown",
          "flow_dir:unknown",
          "size_triplet:copy_len=PKCS11_TOKEN_LABEL_SIZE,src_sz=unknown,dst_sz=PKCS11_TOKEN_LABEL_SIZE",
          "sensitivity_label:credential"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0232",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 1659,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_ck_generate_random",
        "TEE_GenerateRandom"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Generates random into TA-private buffer then copies into caller-provided out->memref.buffer (REE-visible); random is public by default.",
        "Binding of callee buffer parameter to a TA-allocated buffer (TEE_Malloc) at call-site; records origin and that generated bytes (random) are written into this buffer."
      ],
      "code_excerpts": [
        "TEE_GenerateRandom(buffer, count); TEE_MemMove(data, buffer, count);",
        "TEE_GenerateRandom(buffer, count);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:random",
          "size_triplet:copy_len=count,src_sz=buffer_size,dst_sz=out->memref.size",
          "flow_dir:unknown",
          "dst_region:TEE-private",
          "size_triplet:copy_len=count,src_sz=buffer_size,dst_sz=buffer_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0233",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/pkcs11_token.c",
      "line": 1660,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "entry_ck_generate_random"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies random bytes from TA-generated buffer into data (destination region depends on caller); source is TEE-generated random (non-sensitive by default).",
        "Moves random bytes (generated by TEE_GenerateRandom) from buffer into data; src is TEE-private random, dst region unclear (binding shown).",
        "Copies from buffer filled by TEE_GenerateRandom into data; origins ambiguous across call-sites (buffer is TA-generated random, data's region unclear).",
        "Call-site binding: destination parameter 'data' (TA buffer being filled) is TA-managed (unknown allocation provenance).",
        "Call-site binding: source parameter 'buffer' was filled by TEE_GenerateRandom (non-sensitive random by default) before the move.",
        "Call-site moves random bytes from buffer (generated by TEE_GenerateRandom) into data; both source and dest are TA-private — internal copy recorded",
        "Copies random bytes from buffer (produced by TEE_GenerateRandom, TEE-private) into 'data' whose provenance is unclear; binding observed and labeled as random.",
        "Source 'buffer' is filled by TEE_GenerateRandom (TA-private random) then moved; binding records src as TA-private random.",
        "Destination 'data' region is unclear at this site (could be TA-private or REE-visible); binding records uncertainty which is a structural risk.",
        "Binding dest parameter to 'data' at call-site; destination region unclear in this context.",
        "Binding src parameter to 'buffer' filled by TEE_GenerateRandom (TEE-private random source).",
        "Copies generated random from TA-private buffer into caller-provided out->memref.buffer (REE-visible); random is public by default but this is a structural disclosure path.",
        "Binding of callee dest parameter to caller-provided out->memref.buffer (shared/REE-visible); alias of shared buffer passed into helper.",
        "Binding of callee src parameter to TA-allocated buffer (TEE_Malloc) which is TA-private; records origin.",
        "Copies TA-generated random bytes from TA-private buffer into caller-provided (REE-visible) buffer via TEE_MemMove."
      ],
      "code_excerpts": [
        "TEE_MemMove(data, buffer, count);",
        "TEE_MemMove(data, buffer, count); // dest = data (out->memref.buffer)",
        "TEE_MemMove(data, buffer, count); // src = buffer (TEE_Malloc)",
        "TEE_GenerateRandom(buffer, count); TEE_MemMove(data, buffer, count);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->unknown",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:random",
          "size_triplet:copy_len=count,src_sz=count,dst_sz=unknown",
          "flow_dir:TEE->unknown",
          "flow_dir:unknown",
          "flow_dir:TA->TA",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "flow_dir:TEE->TA",
          "flow_dir:TA->REE",
          "dst_region:REE-visible",
          "size_triplet:copy_len=count,src_sz=buffer_size,dst_sz=out->memref.size",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=out->memref.size",
          "size_triplet:copy_len=count,src_sz=buffer_size,dst_sz=buffer_size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0234",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 49,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "serialize"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "data pointer (a_ptr) from TEE alloc_get_tee_attribute_data is copied by length 'size' into realloc'd buffer without upstream semantic validation of 'size' vs expected attr capacity"
      ],
      "code_excerpts": [
        "rc = serialize(bstart, &buf_len, data, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:secret",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=nlen"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0235",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 119,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "alloc_and_get",
        "serialargs_alloc_get_one_attribute"
      ],
      "sink_functions": [
        "=",
        "alloc_and_get"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "binds callee 'args' to caller ctrlargs (derived from REE-provided memref buffer)",
        "binds callee 'orig_next' to caller orig_next (cursor into REE buffer)",
        "binds callee 'buf0' to caller &head (TA-local source header)",
        "binds callee 'out' to caller &p (TA-local recipient pointer)",
        "Propagates head.size (from reader-controlled args) into alloc_and_get which uses it for allocation/copy without an explicit semantic upper bound."
      ],
      "code_excerpts": [
        "rc = alloc_and_get(args, orig_next, &head, sizeof(head), &p, head.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct serialargs),src_sz=ctrl->memref.size,dst_sz=unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=buf0_sz,src_sz=sizeof(head),dst_sz=sz",
          "size_triplet:copy_len=sizeof(void*),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=head.size,src_sz=orig_remaining_bytes,dst_sz=head.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0236",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 136,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller passes &attr (stack) as out; function reads src from args (which originates from REE-visible buffer) and copies size bytes into caller stack object"
      ],
      "code_excerpts": [
        "rc = serialargs_get(args, &attr, sizeof(attr));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=sizeof(attr)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0237",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 140,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "alloc_and_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "binds callee 'args' to caller ctrlargs (REE-derived) at second call site",
        "binds callee 'orig_next' to caller orig_next (REE cursor) at second call site",
        "binds callee 'buf0' to caller &attr (TA-local header) at second call site",
        "binds callee 'out' to caller &p (TA-local) at second call site"
      ],
      "code_excerpts": [
        "rc = alloc_and_get(args, orig_next, &attr, sizeof(attr), &p, attr.attrs_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct serialargs),src_sz=ctrl->memref.size,dst_sz=unknown",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=buf0_sz,src_sz=sizeof(attr),dst_sz=sz",
          "size_triplet:copy_len=sizeof(void*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0238",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 163,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller passes &session_handle as out; function copies size bytes from args-derived src (potentially REE memory) into caller stack variable",
        "alias of serialargs structure (initialized from caller ctrl->memref.buffer) is passed as 'args' (originates from REE-visible memref)",
        "caller-provided output pointer (&session_handle) passed as 'out' to callee; callee writes into caller stack/TA-private memory"
      ],
      "code_excerpts": [
        "rv = serialargs_get(args, &session_handle, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=sizeof(uint32_t)",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=unknown",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0239",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 176,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute_ptr"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller passes head (attributes structure built from templates ultimately derived from REE input) into get_attribute_ptr; alias of possibly untrusted-origin attributes",
        "attr_ptr out-parameter is bound to storage inside attribute structures (may alias into template-derived memory)",
        "attr_size out-parameter is written with attribute size returned from get_attribute_ptrs; size may originate from untrusted attribute metadata"
      ],
      "code_excerpts": [
        "rc = get_attribute_ptr(head, attribute, &attr_ptr, &size);",
        "get_attribute_ptrs(head, attribute, attr_ptr, attr_size, &count);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->REE",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=unknown,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0240",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 184,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: src 'data' originates from attribute buffer (serialargs/template) likely originating from REE; copied into local value_len (stack) via TEE_MemMove."
      ],
      "code_excerpts": [
        "TEE_MemMove(&value_len, data, data_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=data_size,src_sz=data_size,dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0241",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 191,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "generate_random_key_value"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "value_len derived from attribute (originating from template/serialargs) is used to TEE_Malloc without an explicit upper bound check",
        "Allocates value using value_len derived from template attribute without an explicit upper bound check.",
        "value_len is taken from an attribute and used to TEE_Malloc without an explicit upper bound, allowing large allocations or resource exhaustion.",
        "value_len derived from attribute (caller-controlled template) is used to allocate without an application-level upper bound",
        "value_len derived from caller-provided attribute is used to allocate memory without an explicit upper bound check",
        "value_len derived from a caller-controlled attribute is used as allocation size without an explicit upper bound check"
      ],
      "code_excerpts": [
        "value = TEE_Malloc(value_len, TEE_USER_MEM_HINT_NO_FILL_ZERO);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=value_len,src_sz=data_size,dst_sz=value_len"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0242",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 195,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_GenerateRandom"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "callee buffer parameter is an alias of a TEE_Malloc'd buffer (TEE-private) passed into TEE_GenerateRandom"
      ],
      "code_excerpts": [
        "TEE_GenerateRandom(value, value_len);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:random",
          "size_triplet:copy_len=value_len,src_sz=value_len,dst_sz=value_len"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0243",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 289,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_generate_secret"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller-provided client pointer (from tee_session) is passed through as callee 'client' parameter; origin not proven TEE-private",
        "alias of shared params array (caller-provided TEE_Param memrefs) passed into helper; memref buffers are REE-visible"
      ],
      "code_excerpts": [
        "rc = entry_generate_secret(client, ptypes, params);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=unknown,src_sz=ctrl->memref.size,dst_sz=out->memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0244",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 322,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "entry_generate_secret"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: destination out->memref.buffer is caller-provided REE-visible buffer; obj_handle (TEE-private) copied into it.",
        "obj_handle (TA-private) is copied into caller-provided out memref (REE-visible); rc already validated out->memref.size == sizeof(obj_handle)",
        "Destination is caller-provided out->memref.buffer (REE-visible) bound to TEE_MemMove dest parameter.",
        "Source is &obj_handle (TA-local) bound to TEE_MemMove src parameter.",
        "Writes TA-local object handle into REE-visible out->memref.buffer; bounds checked but structurally exposes TA-managed handle to REE.",
        "Writes generated object handle into caller-provided output memref (REE-visible)"
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &obj_handle, sizeof(obj_handle));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(obj_handle),src_sz=sizeof(obj_handle),dst_sz=out->memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0245",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 344,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_GetObjectBufferAttribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "tee_obj handle (TEE object) passed into TEE_GetObjectBufferAttribute; handle is TEE-private",
        "size out-parameter (&sz) bound by TEE_GetObjectBufferAttribute on first probe call",
        "tee_obj handle originates from caller (TEE-private) and selects which attribute is queried; taint of handle affects returned size/data",
        "attribute selector (attribute) influences returned data and its sensitivity (can select private key material)",
        "tee_obj handle (TEE-private) passed into TEE_GetObjectBufferAttribute probe call; callee reads object metadata",
        "address of local sz passed so callee writes required size back to caller"
      ],
      "code_excerpts": [
        "res = TEE_GetObjectBufferAttribute(tee_obj, attribute, NULL, &sz);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=sizeof(TEE_ObjectHandle),src_sz=unknown,dst_sz=unknown",
          "flow_dir:TEE->TA",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(size_t),src_sz=unknown,dst_sz=sizeof(size_t)",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=4,dst_sz=4",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=sizeof(size_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0246",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 348,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_GetObjectBufferAttribute",
        "alloc_get_tee_attribute_data"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "queried size (sz) is used to allocate memory without explicit upper bound check; large sizes could lead to excessive allocation",
        "Queried size sz is used to allocate memory without an explicit upper bound check; large or malformed sizes could lead to excessive allocation (resource exhaustion)."
      ],
      "code_excerpts": [
        "ptr = TEE_Malloc(sz, TEE_USER_MEM_HINT_NO_FILL_ZERO);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sz,src_sz=sz,dst_sz=sz"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0247",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 352,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "alloc_get_tee_attribute_data",
        "TEE_GetObjectBufferAttribute"
      ],
      "sink_functions": [
        "TEE_GetObjectBufferAttribute",
        "=",
        "unknown"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies object attribute into allocated buffer via TEE_GetObjectBufferAttribute; provenance is TEE object attribute (TEE-private)",
        "destination buffer ptr provided by caller is filled with object attribute bytes; buffer was allocated locally via TEE_Malloc",
        "TEE_GetObjectBufferAttribute copies attribute data (sz bytes) from TEE object into ptr; provenance is TEE object attribute (TEE-private)",
        "allocated ptr receives attribute data from TEE (may contain secret key bytes); caller later copies this into TA structures",
        "Allocated buffer ptr receives attribute data which may contain secret key bytes; downstream code copies these attributes into TA-managed structures and may eventually export them to REE.",
        "Copies TEE object attribute into allocated buffer via TEE_GetObjectBufferAttribute; buffer is TEE_Malloc'ed and later returned to caller",
        "buffer ptr (TEE_Malloc'ed) passed as destination for attribute data; callee writes attribute bytes into this TA-allocated buffer",
        "address of sz passed so callee may update actual size written into ptr"
      ],
      "code_excerpts": [
        "res = TEE_GetObjectBufferAttribute(tee_obj, attribute, ptr, &sz);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TEE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sz,src_sz=sz,dst_sz=sz",
          "flow_dir:TA->TA",
          "sensitivity_label:secret",
          "size_triplet:copy_len=sz,src_sz=sz,dst_sz=allocated_sz",
          "size_triplet:copy_len=sizeof(size_t),src_sz=unknown,dst_sz=sizeof(size_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0248",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 553,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_generate_key_pair"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies key handles into caller-provided out buffer; structural risk but not promoted to unencrypted_output here.",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); structural risk: REE-visible destination but values are non-sensitive handles",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); destination is shared even though handles are non-sensitive.",
        "alias of caller-provided out->memref.buffer bound to hdl_ptr (shared buffer passed into helper)",
        "params (caller-provided memrefs) alias into local pointers (ctrl/out/hld_ptr); shared buffer provenance is REE-visible which is a structural risk to track.",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); while handles are non-sensitive, this is an alias of shared buffer passed from REE."
      ],
      "code_excerpts": [
        "TEE_MemMove(hdl_ptr, &pubkey_handle, sizeof(pubkey_handle));",
        "hdl_ptr = (uint32_t *)out->memref.buffer;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(pubkey_handle),src_sz=sizeof(pubkey_handle),dst_sz=out->memref.size",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(TEE_Param*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0249",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 555,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "entry_generate_key_pair",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though handles are non-sensitive",
        "Writes generated key handles into caller-provided out buffer (REE-visible); potential information flow to REE occurs at this different sink line.",
        "Copies generated handles into caller-provided out buffer; structural risk recorded.",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); handles are non-sensitive but destination is REE-visible",
        "Copies generated key handles into caller-provided out->memref.buffer (shared/REE-visible); handles are non-sensitive but destination is shared.",
        "Copies generated key handles into caller-provided out buffer (shared); structural risk of exposing handles though not classified as sensitive here.",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); handles are non-sensitive but writing into shared memory is structural risk to track.",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though handles are non-sensitive in context",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); handles are non-sensitive but the copy is to shared memory.",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); handles are not treated as sensitive here but destination is shared.",
        "Copies key handles into caller-provided out buffer (REE-visible); ensure no TA-private secret is placed into this buffer.",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); structural risk of exposing handles to REE",
        "Binding: hdl_ptr aliases out->memref.buffer (REE-visible); pubkey_handle (TEE-private) copied into that shared buffer.",
        "Destination hdl_ptr is alias of out->memref.buffer (caller-provided REE-visible) bound to dest.",
        "Source &pubkey_handle is TA-local bound to src parameter.",
        "Writes generated key handles into caller-provided out->memref.buffer (REE-visible).",
        "alias of caller-provided out->memref.buffer passed as dest (shared/REE-visible) into TEE_MemMove at key-pair creation site",
        "alias of TA-local pubkey_handle passed as src into TEE_MemMove",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though handles are considered non-sensitive",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible) via TEE_MemMove; destination is shared/REE-visible though handles are non-sensitive.",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); structural risk since destination is shared memory.",
        "Copies created key handles into caller-provided out buffer (REE-visible); potential information flow to REE depending on handle semantics.",
        "Copies generated key handles into caller-provided out->memref.buffer (REE-visible); structural risk of exposing handles to REE."
      ],
      "code_excerpts": [
        "TEE_MemMove(hdl_ptr, &pubkey_handle, sizeof(pubkey_handle));",
        "&pubkey_handle"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(pubkey_handle),src_sz=sizeof(pubkey_handle),dst_sz=out->memref.size",
          "flow_dir:unknown",
          "dst_region:TEE-private",
          "size_triplet:copy_len=sizeof(pubkey_handle),src_sz=sizeof(pubkey_handle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0250",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 556,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "entry_generate_key_pair"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: hdl_ptr+1 aliases out->memref.buffer (REE-visible); privkey_handle (TEE-private) copied into that shared buffer.",
        "Destination hdl_ptr + 1 writes into caller-provided buffer (REE-visible) via dest parameter.",
        "Source &privkey_handle is TA-local bound to src parameter.",
        "Writes generated private key handle into caller-provided out->memref.buffer (REE-visible).",
        "alias of caller-provided out->memref.buffer+1 passed as dest (shared/REE-visible) into TEE_MemMove for priv key handle",
        "alias of TA-local privkey_handle passed as src into TEE_MemMove",
        "Copies generated private key handle into caller-provided out->memref.buffer (REE-visible); structural risk due to shared buffer write."
      ],
      "code_excerpts": [
        "TEE_MemMove(hdl_ptr + 1, &privkey_handle, sizeof(privkey_handle));",
        "&privkey_handle"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(privkey_handle),src_sz=sizeof(privkey_handle),dst_sz=out->memref.size",
          "flow_dir:unknown",
          "dst_region:TEE-private",
          "size_triplet:copy_len=sizeof(privkey_handle),src_sz=sizeof(privkey_handle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0251",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 605,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "remove_empty_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of pub_head pointer (caller-controlled template) passed into helper; head originates from REE-derived templates"
      ],
      "code_excerpts": [
        "if (remove_empty_attribute(pub_head, PKCS11_CKA_EC_POINT) ||"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0252",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 607,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "remove_empty_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of priv_head pointer (caller template) passed into helper; head originates from REE-derived templates"
      ],
      "code_excerpts": [
        "remove_empty_attribute(priv_head, PKCS11_CKA_EC_PARAMS)) {"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0253",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 628,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "handle_get"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding of callee 'db' parameter to caller 'object_db' at alternative call site; db is TA-managed",
        "Binding of callee 'ptr' parameter to caller 'obj' at alternative call site; ptr is object pointer (TEE-managed)"
      ],
      "code_excerpts": [
        "handle = handle_get(object_db, obj);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct handle_db*),src_sz=unknown,dst_sz=unknown",
          "flow_dir:REE->TA",
          "size_triplet:copy_len=sizeof(void*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0254",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 649,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "add_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of priv_head (callee 'head') passed from generate_ec_keys; origin is TA-managed structures built from REE-provided templates",
        "alias of a_ptr (callee 'data') passed from generate_ec_keys; a_ptr derived from REE-provided EC_PARAMS"
      ],
      "code_excerpts": [
        "rc = add_attribute(priv_head, PKCS11_CKA_EC_PARAMS, a_ptr, a_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=a_size,src_sz=a_size,dst_sz=buf_len"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0255",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 653,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "tee2pkcs_ec_attributes"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of pub_head pointer (originating from caller templates that may be REE-derived) passed into tee2pkcs_ec_attributes",
        "alias of priv_head pointer (may contain attributes from REE templates) passed into tee2pkcs_ec_attributes",
        "alias of tee_obj handle (TEE-allocated key object) passed into tee2pkcs_ec_attributes; tee_obj is TEE-private"
      ],
      "code_excerpts": [
        "rc = tee2pkcs_ec_attributes(pub_head, priv_head, tee_obj, tee_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown",
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(TEE_ObjectHandle),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0256",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 739,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "remove_empty_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of pub_head pointer (caller-controlled template) passed into helper at alternate call-site"
      ],
      "code_excerpts": [
        "if (remove_empty_attribute(pub_head, PKCS11_CKA_EC_POINT) ||"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0257",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 740,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "remove_empty_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of priv_head pointer (caller template) passed into helper at alternate call-site"
      ],
      "code_excerpts": [
        "remove_empty_attribute(priv_head, PKCS11_CKA_VALUE) ||"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0258",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 741,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "remove_empty_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of priv_head pointer (caller template) passed into helper at alternate call-site"
      ],
      "code_excerpts": [
        "remove_empty_attribute(priv_head, PKCS11_CKA_EC_POINT) ||"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0259",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 779,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "add_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of priv_head (callee 'head') passed from generate_ec_keys at second call-site; same origin as above",
        "alias of a_ptr (callee 'data') passed from generate_ec_keys at second call-site; a_ptr derived from REE-provided EC_PARAMS"
      ],
      "code_excerpts": [
        "rc = add_attribute(priv_head, PKCS11_CKA_EC_PARAMS, a_ptr, a_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(struct obj_attrs*),src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=a_size,src_sz=a_size,dst_sz=buf_len"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0260",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 1046,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Binding: out->memref.buffer (REE-visible) receives obj_handle copied from TEE-private storage via TEE_MemMove.",
        "Destination out->memref.buffer (caller-provided REE-visible) bound to dest parameter.",
        "Source &obj_handle is TA-local bound to src parameter.",
        "alias of caller-provided out->memref.buffer passed as dest into TEE_MemMove at object creation site",
        "alias of TA-local obj_handle passed as src into TEE_MemMove"
      ],
      "code_excerpts": [
        "TEE_MemMove(out->memref.buffer, &obj_handle, sizeof(obj_handle));",
        "&obj_handle"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:public",
          "size_triplet:copy_len=sizeof(obj_handle),src_sz=sizeof(obj_handle),dst_sz=out->memref.size",
          "flow_dir:unknown",
          "dst_region:TEE-private",
          "size_triplet:copy_len=sizeof(obj_handle),src_sz=sizeof(obj_handle),dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0261",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 1624,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller passes &bbool/&sz (TEE-private locals) as attr/attr_size to get_attribute; head originates from templates derived from REE input"
      ],
      "code_excerpts": [
        "if (!get_attribute(head, attribute, &bbool, &sz) && !!bbool == val)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(bbool),src_sz=unknown,dst_sz=sizeof(bbool)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0262",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 2134,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller passes &boolval/&boolsize (possibly from object attributes derived from REE) into get_attribute"
      ],
      "code_excerpts": [
        "rc = get_attribute(obj->attributes, PKCS11_CKA_EXTRACTABLE, &boolval, &boolsize);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(boolval),src_sz=unknown,dst_sz=sizeof(boolval)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0263",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 2140,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller passes &boolval/&boolsize (object attrs) into get_attribute; attributes ultimately originate from templates"
      ],
      "code_excerpts": [
        "rc = get_attribute(obj->attributes, PKCS11_CKA_SENSITIVE, &boolval, &boolsize);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(boolval),src_sz=unknown,dst_sz=sizeof(boolval)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0264",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 2259,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller passes &boolval/&boolsize (object attrs) into get_attribute; values are checked for trust flags"
      ],
      "code_excerpts": [
        "rc = get_attribute(obj->attributes, PKCS11_CKA_TRUSTED, &boolval, &boolsize);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(boolval),src_sz=unknown,dst_sz=sizeof(boolval)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0265",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 2456,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "get_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "caller requests PKCS11_CKA_VALUE_LEN into &key_length/&size where attribute storage may originate from REE-provided templates"
      ],
      "code_excerpts": [
        "rc = get_attribute(*head, PKCS11_CKA_VALUE_LEN, &key_length, &size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(key_length),src_sz=unknown,dst_sz=sizeof(key_length)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0266",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing_ec.c",
      "line": 559,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "tee2pkcs_ec_attributes",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies TEE-managed public coordinate x into an allocated ecpoint buffer via TEE_MemMove; ecpoint later stored into attr structures",
        "Copies public X coordinate from TEE attribute into constructed ecpoint buffer.",
        "binding: destination pointer is an ecpoint buffer allocated via TEE_Malloc (TEE-private) passed as dest",
        "binding: source pointer x_ptr originates from alloc_get_tee_attribute_data (TEE-private)",
        "binding: length argument x_size (attribute length) drives copy size"
      ],
      "code_excerpts": [
        "TEE_MemMove(ecpoint + hsize + poffset, x_ptr, x_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=x_size,src_sz=x_size,dst_sz=dersize",
          "flow_dir:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0267",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing_ec.c",
      "line": 564,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "tee2pkcs_ec_attributes",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies TEE-managed public coordinate y into ecpoint via TEE_MemMove; ecpoint then added to public and private attribute lists",
        "Copies public Y coordinate from TEE attribute into constructed ecpoint buffer.",
        "binding: destination pointer is ecpoint buffer (TEE-private) passed as dest for y coordinate",
        "binding: source pointer y_ptr originates from alloc_get_tee_attribute_data (TEE-private)",
        "binding: length argument y_size (attribute length) drives copy size"
      ],
      "code_excerpts": [
        "TEE_MemMove(ecpoint + hsize + psize + poffset, y_ptr, y_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=y_size,src_sz=y_size,dst_sz=dersize",
          "flow_dir:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0268",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing_ec.c",
      "line": 839,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "binding: destination ctx->ctx passed as dest (likely TEE-private buffer) into TEE_MemMove",
        "binding: source ctx_data passed into TEE_MemMove; provenance unclear (could be REE-derived)",
        "binding: length ctx_len drives copy size into ctx->ctx"
      ],
      "code_excerpts": [
        "TEE_MemMove(ctx->ctx, ctx_data, ctx_len);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=ctx_len,src_sz=unknown,dst_sz=ctx->ctx_len"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0269",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing_rsa.c",
      "line": 708,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "generate_rsa_keys",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies attribute bytes (a_ptr) into local modulus_bits via TEE_MemMove; a_ptr provenance uncertain (could be from processed template), but size is validated prior",
        "Copies attribute bytes into local modulus_bits after get_attribute_ptr; relies on get_attribute_ptr to have validated size.",
        "Binding: destination parameter aliases local modulus_bits (TEE-private) passed as &modulus_bits into TEE_MemMove",
        "Binding: source parameter aliases a_ptr which was obtained from attribute template; provenance unclear (could be REE-derived or TA-allocated)",
        "Copies bytes from a_ptr into local modulus_bits; source provenance uncertain though size was validated to sizeof(uint32_t)",
        "Source a_ptr provenance uncertain though size validated; copy into local modulus_bits may be safe but upstream origin unknown."
      ],
      "code_excerpts": [
        "TEE_MemMove(&modulus_bits, a_ptr, sizeof(uint32_t));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=a_size,dst_sz=sizeof(uint32_t)",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=sizeof(uint32_t),dst_sz=sizeof(uint32_t)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0270",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing_symm.c",
      "line": 1052,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "wrap_data_by_symm_enc"
      ],
      "sink_functions": [
        "TEE_CipherDoFinal"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Potential disclosure: cipher output is written into out_buf (caller-owned REE-visible) from TA-private key material; there is a bounds check that may prevent overflow."
      ],
      "code_excerpts": [
        "res = TEE_CipherDoFinal(proc->tee_op_handle, in_buf, in_sz, tmp_buf, &tmp_sz);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:secret",
          "size_triplet:copy_len=in_sz,src_sz=data_sz,dst_sz=*out_sz (params[2].memref.size)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0271",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/processing_symm.c",
      "line": 1078,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Call-site binding: destination in_buf is TEE_Malloc'd buffer (TA-private) receiving data.",
        "Call-site binding: source is (uint8_t *)data + in_sz aliasing caller-provided TA-private data (sensitive key material).",
        "Call-site binding: length argument 'align' derived from data_sz % TEE_AES_BLOCK_SIZE (tainted by data_sz)."
      ],
      "code_excerpts": [
        "TEE_MemMove(in_buf, (uint8_t *)data + in_sz, align);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=align,src_sz=unknown,dst_sz=TEE_AES_BLOCK_SIZE",
          "sensitivity_label:secret",
          "size_triplet:copy_len=align,src_sz=data_sz,dst_sz=TEE_AES_BLOCK_SIZE",
          "flow_dir:unknown",
          "src_region:unknown",
          "dst_region:unknown",
          "sensitivity_label:public"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0272",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 33,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "serialargs_get"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies 'size' bytes from src (derived from untrusted serialargs) into out; size is caller-provided and may be attacker-controlled.",
        "Performs TEE_MemMove(out, src, size) where src originates from args (likely REE-backed) and size is caller-controlled; limited check relies on serialargs_get_ptr correctness",
        "Performs TEE_MemMove(out, src, size) where src originates from args (likely REE-backed) and size is caller-controlled; relies on serialargs_get_ptr correctness",
        "Copies 'size' bytes from caller-controlled src (derived from args) into out via TEE_MemMove without visible bounds/sanity checks on args contents.",
        "Copies 'size' bytes from caller-controlled src into out via TEE_MemMove without additional local bounds/sanity checks at this function boundary.",
        "TEE_MemMove copies 'size' bytes from src (from args/REE) into out (TA-private); source is REE-controlled shared memory",
        "Copies size bytes from src (derived from args buffer, i.e., REE-provided) into out without validating content, potentially letting untrusted bytes drive session_handle.",
        "Copies 'size' bytes from src (derived from caller-controlled serial buffer) into out without further validation of src contents or that size fits destination.",
        "Copies 'size' bytes from src derived from a REE-controlled serial buffer into out without further validation of src contents; relies on callers to ensure size matches destination."
      ],
      "code_excerpts": [
        "TEE_MemMove(out, src, size);",
        "if (!rc) TEE_MemMove(out, src, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=orig_remaining,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=args->available_bytes,dst_sz=unknown",
          "sensitivity_label:public",
          "size_triplet:copy_len=size,src_sz=args->memref.size,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=size",
          "sensitivity_label:session",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=sizeof(out)"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0273",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 34,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "serialargs_get"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Copies 'size' bytes from src (derived from untrusted serialargs/REE buffer) into out without additional bounds validation here; size is attacker-influenced",
        "Binding: src argument originates from caller-controlled serialargs buffer (REE-visible); alias of shared buffer passed into helper",
        "Binding: out parameter (destination) is caller-provided storage or local buffer and receives copied data; callee dest aliasing to caller storage",
        "alias of caller-provided 'out' (TA-local/out param) passed as dst here; destination originates from caller context",
        "alias of 'src' pointer (from serialargs_get_ptr) passed as src here; src is derived from args which originates from REE-provided buffer",
        "copies 'size' bytes from src (derived from args/REE) into out without validating that src contents or full bounds are trusted here",
        "Copies 'size' bytes from REE-derived src into TA memory without an explicit visible bounds check here tying size to destination capacity.",
        "Copies size bytes from src (derived from args/REE data) into caller-provided out using TEE_MemMove; size originates from caller-controlled call and may be unvalidated.",
        "Copies 'size' bytes from src (derived from args/REE data) into out using TEE_MemMove; size is caller-influenced and may be unvalidated.",
        "Copies 'size' bytes from src (derived from serialargs_get_ptr reading args which originate from REE) into caller stack object 'out' (TEE-private) via TEE_MemMove",
        "Copies bytes from args-derived src (REE) into local attr object; relies on serialargs_get_ptr for bounds validation",
        "TEE_MemMove copies size bytes from src (derived via serialargs_get_ptr from REE data) into out without validating size or src provenance",
        "Copies size bytes from src (derived from serialargs_get_ptr reading REE-controlled args) into caller-provided out without validating src provenance beyond serialargs_get_ptr return",
        "TEE_MemMove copies 'size' bytes from REE-derived src into TA memory without explicit validation at this callsite.",
        "Copies 'size' bytes from src (derived from args/REE input) into out without explicit local validation here; size is caller-provided.",
        "Copies 'size' bytes from src (derived from serialargs/REE input) into out without local validation here; size is caller-controlled.",
        "Call-site binding: destination 'out' at serialargs_get call is alias of caller-local buffer (e.g. &attr or &session_handle) - TEE-private.",
        "Copies 'size' bytes from src (derived from untrusted serialargs) into out; size may be attacker-controlled.",
        "Call-site binding: destination 'out' aliases caller-provided 'out' (TA-private) while src originates from serial buffer (REE-visible).",
        "Copies bytes from 'src' (may point into REE-originated serialargs buffer) into 'out' (TA-local destination), propagating untrusted input into TA memory.",
        "TEE_MemMove copies 'size' bytes from src (derived from args) to out without additional bounds validation here",
        "Copies 'size' bytes from src (derived from serialargs, likely REE-origin) to out without local bounds validation at this call-site",
        "Performs TEE_MemMove(out, src, size) using size derived from caller without explicit upper-bound here",
        "Copies 'size' bytes from src (derived from args->next, REE-provided) into caller dest without an upper-bound check here",
        "Copies 'size' bytes from src (derived from REE-provided serialargs) into out without further type/value validation of contents",
        "Copies 'size' bytes from src (derived from REE-provided serialargs) into caller 'out' without validating content beyond size",
        "Copies 'size' bytes from src (derived from REE-provided serialargs) into out without validating the semantic/value of the data.",
        "Copies size bytes from src (originating from serialargs_get_ptr -> args, REE-backed) into caller 'out' without additional local bounds verification",
        "binding: 'out' argument is caller-supplied (e.g. &session_handle) passed into TEE_MemMove",
        "binding: 'src' argument originates from serialargs_get_ptr(args) which is backed by REE memref buffer",
        "Copies size bytes from src (derived from args/REE buffer) into out without content validation beyond serialargs_get_ptr success.",
        "Copies 'size' bytes from src (derived from caller-controlled serialargs) into out (TA-private) without content validation beyond serialargs_get_ptr success.",
        "src pointer originates from serialargs_get_ptr which reads from caller-controlled buffer (alias of REE-visible memory).",
        "Call-site binding: destination 'out' aliases caller-provided out pointer (here &session_handle in caller).",
        "Copies 'size' bytes from caller-controlled src (derived from args) into out via TEE_MemMove; relies on serialargs_get_ptr but lacks local bounds sanity here.",
        "TEE_MemMove copies 'size' bytes from src (derived from args/REE) into out without additional provenance checks here.",
        "Copies sizeof(uint32_t) from src derived from serialargs (REE-provided) into caller out (TEE-private) without extra provenance checks here.",
        "Copies bytes from src (derived via serialargs_get_ptr from REE-provided buffer) into out without visible content validation; untrusted session_handle can influence control flow.",
        "dst parameter 'out' binds to caller-provided buffer (caller stack variable), receiving bytes from src.",
        "src parameter 'src' originates from serialargs_get_ptr which points into REE-provided serial buffer.",
        "Copies untrusted bytes from REE-visible src into TA memory without content validation; session_handle can be attacker-controlled.",
        "Copies untrusted bytes from src (derived via serialargs_get_ptr into REE buffer) into TA memory without content validation; may allow attacker-controlled session_handle.",
        "TEE_MemMove copies 'size' bytes from src (from args, originated from REE-visible buffer) into out (caller-provided TA buffer), creating REE->TA flow.",
        "Copies 'size' bytes from src (originating from serialargs, which is backed by caller memref buffer) into out; creates REE->TA flow from shared buffer into TA memory.",
        "TEE_MemMove copies 'size' bytes from args-derived src into out; overall REE->TA flow recorded though caller used this to read a session handle.",
        "Copies size bytes from src (derived from REE-controlled serialargs) into out via TEE_MemMove; src is attacker-influenced even though rc is checked.",
        "Copies size bytes from src (derived from REE-controlled serialargs_get_ptr) into caller out; src is attacker-influenced though call-site checks rc.",
        "Call-site binding: 'out' parameter aliases caller stack variable (e.g., &session_handle) written by TEE_MemMove.",
        "Call-site binding: 'size' argument controls copy length (influences amount of REE-origin data moved).",
        "Generic risk: TEE_MemMove moves attacker-influenced bytes from a shared-source into local memory; correctness depends on prior validation of size and src pointer.",
        "Copies attacker-influenced bytes from serialargs into TA memory; correctness depends on upstream validation.",
        "Copies 'size' bytes from src (derived from REE-controlled args) into out without validating that src content is a well-formed integer/session handle.",
        "Copies 'size' bytes from src (derived from REE-controlled serialized args) into out without validating src content semantics.",
        "Copies attacker-controlled serialized bytes into TA-local session_handle without semantic validation.",
        "Performs direct copy of 'size' bytes from src (derived from caller-provided buffer via serialargs_get_ptr) into out without additional validation beyond serialargs_get_ptr.",
        "Binding dst 'out' to caller-provided pointer (TA-private) and src to args-derived pointer (shared/REE-visible); record aliasing of parameters.",
        "Copies 'size' bytes from src (derived from args buffer, likely REE-provided) into caller-supplied out buffer via TEE_MemMove; source is REE-tainted.",
        "Copies 'size' bytes from src (derived from serialargs, likely REE-provided) into caller out buffer; source is REE-tainted.",
        "Binding dst argument to caller-provided 'out' (caller stack/local) so callee writes into caller memory.",
        "Copies 'size' bytes from args-derived src (REE-visible) into caller-provided out buffer; guarded by serialargs_get_ptr but source is REE-tainted.",
        "Copies 'size' bytes from src (obtained via serialargs_get_ptr from args) into out; src may originate from REE-visible buffer via args.",
        "Binding of dest parameter to caller 'out' which is TA-private stack storage (&session_handle) at call-site; records aliasing origin.",
        "Binding of src parameter to pointer obtained from serialargs_get_ptr which may reference REE-originated buffer via args; records possible REE->TA origin.",
        "Copies size bytes from src (derived from args which is REE-originated) into out via TEE_MemMove; src may be attacker-controlled if serialargs_get_ptr insufficiently validated.",
        "Call-site binding: 'out' parameter aliases caller-provided destination (e.g., &session_handle) which is TA-private at this call-site.",
        "Call-site binding: 'src' parameter aliases a pointer obtained from serialargs_get_ptr over args (which is built from REE memref), so src is REE-originated/shared.",
        "Copies 'size' bytes from src (derived from REE buffer) into out without additional size/overlap checks here; src may be attacker-controlled.",
        "Copies bytes from REE-derived src into TA memory; if serialargs_get_ptr lacks adequate bounds/format validation, attacker-controlled input may influence parsed values.",
        "TEE_MemMove copies 'size' bytes from 'src' (derived from args/serial buffer, potentially REE-controlled) into caller-supplied out buffer.",
        "Destination 'out' is a TA-private buffer in serialargs_get but receives data from 'src' derived from args (potentially REE-controlled).",
        "Source 'src' originates from serialargs_get_ptr reading from a serial buffer (caller-controlled), so memmove copies REE-controlled bytes into TA memory.",
        "Call is dependent on 'size' provided by caller path; if serialargs_get_ptr did insufficient validation, this copy could be out-of-bounds.",
        "Copies 'size' bytes from src (derived from args -> shared REE buffer) into out without visible bounds check here; if serialargs_get_ptr insufficiently validated, untrusted data is copied into TA memory.",
        "Copies 'size' bytes from src derived from serialargs (REE-visible) into out without local bounds here; untrusted src can influence TA memory.",
        "Copies 'size' bytes from src derived from serialargs into TA memory; correctness depends on serialargs_get_ptr validation.",
        "Copies from src derived via serialargs_get_ptr (likely REE-controlled) into out (&session_handle) which is TA-private; records binding of src/dest provenance.",
        "Copies size bytes from src (derived from serialargs/REE buffer) into out via TEE_MemMove; src is untrusted and size-driven copy may be attacker-controlled.",
        "Copies 'size' bytes from src (derived from serialargs/REE buffer) into out (caller-provided); src is untrusted and length-driven copy may be attacker-controlled.",
        "Copies 'size' bytes from src (likely pointer into args->buffer derived from REE) into caller-provided out without additional validation of content.",
        "Binding: callee 'out' parameter is the caller's &session_handle (TA-local destination) passed into TEE_MemMove at call-site.",
        "Binding: callee 'src' parameter originates from args->buffer which was initialized from an REE-provided memref (shared/REE-visible).",
        "Binding: callee 'size' parameter is a caller-supplied length (numeric) used to control the copy; provenance and bounds validation depend on caller.",
        "Copies 'size' bytes from a source that may be REE-visible into a TA destination without additional validation here; caller must ensure bounds and trustworthiness.",
        "Copies 'size' bytes from a source derived from REE into TA-local memory without local validation here; relies on caller and serialargs_get_ptr to ensure bounds.",
        "Copies 'size' bytes from src (derived from args, potentially REE-shared buffer) into out via TEE_MemMove; risk of copying REE-provided data into TA memory if src is shared",
        "dest 'out' is written from src derived from args (which was initialized from ctrl->memref.buffer, REE-provided/shared); binding callee 'dest'/'src' to caller origins",
        "Copies 'size' bytes from src (derived from args/REE-controlled buffer) into out (TA-private); source is REE-visible shared memory.",
        "Copies 'size' bytes from src (derived from args which may be REE-provided) into out without content validation; untrusted bytes can control copied data.",
        "Call-site binding: destination 'out' is callee-provided pointer (alias of caller's out) at serialargs_get call.",
        "Copies 'size' bytes from src (derived from serialargs buffer, REE-controlled) into out without validating src contents or size against destination capacity.",
        "Copies size bytes from src into out via TEE_MemMove without local verification of src length in this function (relies on serialargs_get_ptr).",
        "Copies size bytes from src (bound to caller ctrl->memref.buffer) into out without local verification here; relies on upstream checks.",
        "Copies size bytes from REE-provided src into out without local verification in this function; relies on serialargs_get_ptr/upstream validation.",
        "Copies 'size' bytes from src (obtained from args which references REE-visible memref) into out (caller buffer); flow moves REE-origin data into TA caller buffer.",
        "Copies 'size' bytes from src (obtained from serialargs_get_ptr which may reference REE-provided memref) into caller buffer 'out'; binds callee params to REE-derived source and caller destination.",
        "TEE_MemMove copies 'size' bytes from src (derived from args which may reference REE buffer) into out; correctness relies on serialargs_get_ptr's validation of bounds.",
        "Destination 'out' (caller-provided) receives size bytes from src derived from serialargs_get_ptr which reads from REE-originated buffer; relies on upstream validation.",
        "Call-site binding: 'src' parameter aliases memory obtained from args (which may reference REE-visible buffer).",
        "TEE_MemMove copies 'size' bytes from src (derived from REE args) into out; correctness depends on serialargs_get_ptr bounds validation.",
        "Copies bytes from src (from args->buffer, likely REE-visible) into out via TEE_MemMove without local checks",
        "Binding dest parameter to caller 'out' (TA-private) at call site — alias of callee dest to local TA storage",
        "Binding src parameter to pointer returned by serialargs_get_ptr (likely from args->buffer, REE-visible)",
        "Copies bytes from src (from args->buffer, likely REE-visible) into out via TEE_MemMove; relies on serialargs_get_ptr for validation.",
        "Copy from src (derived from REE-visible buffer) into caller-provided out pointer (callee writes into caller stack/vars) via TEE_MemMove observed at this call-site.",
        "Destination 'out' at this call-site is a TA-local variable pointer (callee writes into TA-private storage) while source originates from serialargs_get_ptr (derived from caller-provided REE buffer).",
        "Source 'src' at this call-site is bound from serialargs_get_ptr which reads from an args-initialized buffer (caller-provided memref).",
        "serialargs_get copies from src derived from caller memref into out; src origin is REE-visible buffer initialized by caller.",
        "Copies from src (obtained via serialargs_get_ptr, likely wrapping REE-provided buffer) into out; destination origin depends on caller (&token_id in callers) so aliasing between shared and private exists.",
        "Copies 'size' bytes from src (pointer derived from caller-controlled args) into out without local bounds checks here; size originates from caller in many call-sites.",
        "Copies 'size' bytes from src (derived from caller-controlled serialargs buffer) into out (TA memory) without local checks here.",
        "Copies 'size' bytes from src (pointer derived from caller-controlled args) into out without local checks here; relies on serialargs_get_ptr correctness.",
        "Copies from src (which may originate from REE memref) into out; binds callee args to a caller-provided buffer origin.",
        "Copies from a src pointer supplied by serialargs_get_ptr into caller-provided out; relies on serialargs_get_ptr validation.",
        "Copies 'size' bytes from src derived from REE-provided args into out without additional semantic validation of 'size' vs remaining buffer.",
        "Call-site binding: destination 'out' is TA-private (&old_pin_size/&pin_size) while source 'src' originates from serialargs buffer initialized from REE.",
        "Copies 'size' bytes from REE-derived src into TA memory; 'size' is caller-controlled and relies on prior serialargs validation.",
        "Copies caller-controlled 'size' bytes from REE-derived src into TA memory; relies on serialargs_get_ptr correctness.",
        "Call-site binding: callee dest 'out' aliases caller-provided TA stack/storage (&user_type or &pin_size) — destination is TA-private.",
        "Call-site binding: callee src 'src' is provided by serialargs_get_ptr and ultimately originates from ctrl->memref.buffer (REE-visible).",
        "Copies 'size' bytes from REE-origin src into out without additional validation beyond the earlier pointer retrieval; size is caller-controlled.",
        "Copies caller-controlled 'size' bytes from REE-origin src into TA-private out without an explicit local bounds check at this line; correctness depends on serialargs_get_ptr's validation.",
        "Copies 'size' bytes from src (obtained from REE-backed serialargs buffer) into caller-provided out; source is REE-controlled and size origin may be attacker-influenced via serialargs state.",
        "Binding: destination 'out' at call site comes from caller's out parameter (caller-provided), origin depends on call chain.",
        "Binding: source 'src' is obtained via serialargs_get_ptr from args which may be backed by REE-visible memref buffer.",
        "Copies 'size' bytes from REE-backed serialargs buffer into TA memory without explicit per-callsite bounds proof here.",
        "TEE_MemMove copies 'size' bytes from src (derived from serialargs buffer, REE-origin) into caller-provided out pointer; potential untrusted input copied into TA memory",
        "TEE_MemMove copies 'size' bytes from src (derived from serialargs buffer initialized from ctrl->memref.buffer, REE-provided) into out (caller TA memory); untrusted src flows into TA memory.",
        "Copies 'size' bytes from serialargs buffer (initialized from REE memref) into TA memory; ensure serialargs_get_ptr robustly bounds checks.",
        "copies size bytes from src (obtained from serialargs_get_ptr, likely derived from REE buffer) into caller out without local validation here",
        "binding: caller passes 'out' (&object_handle in upstream) as destination into TEE_MemMove; record origin",
        "copies 'size' bytes from src (obtained from serialargs_get_ptr, likely derived from REE buffer) into out without validation here",
        "copies size bytes from src (obtained from serialargs_get_ptr, likely derived from REE buffer) into out without validation here",
        "Copies 'size' bytes from src (returned by serialargs_get_ptr, likely into REE-provided memref buffer) into caller-supplied out via TEE_MemMove",
        "Call-site binding: destination 'out' is caller-provided pointer (callee dst aliases caller variable)",
        "Call-site binding: source 'src' originates from serialargs_get_ptr reading from args (likely REE-provided buffer)"
      ],
      "code_excerpts": [
        "if (!rc) TEE_MemMove(out, src, size);",
        "TEE_MemMove(out, src, size);",
        "if (!rc)\n\tTEE_MemMove(out, src, size);",
        "TEE_MemMove(dst, src, size);",
        "rc = serialargs_get_ptr(args, &src, size);",
        "rc = serialargs_get_ptr(args, &src, size); if (!rc) TEE_MemMove(out, src, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:public",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=unknown",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "flow_dir:TA->TA",
          "src_region:unknown",
          "flow_dir:unknown",
          "src_region:TEE-private",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=sizeof(out buffer)",
          "size_triplet:copy_len=size,src_sz=orig_remaining_bytes,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=sizeof(attr)",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=sizeof(caller_type)",
          "size_triplet:copy_len=size,src_sz=orig_remaining,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=args->remaining,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=args->available_bytes,dst_sz=unknown",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=unknown",
          "sensitivity_label:session",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=sizeof(uint32_t)",
          "size_triplet:copy_len=size,src_sz=args->memref.size,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=args->remaining_bytes,dst_sz=size",
          "size_triplet:copy_len=0,src_sz=unknown,dst_sz=unknown",
          "sensitivity_label:credential",
          "size_triplet:copy_len=size,src_sz=args_remaining,dst_sz=size",
          "size_triplet:copy_len=sizeof(uint32_t),src_sz=ctrl->memref.size,dst_sz=sizeof(uint32_t)",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=serialargs_remaining_or_buffer_size,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=serialargs_buffer_size,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=sizeof(rc?)?,dst_sz=sizeof(rc?)?"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0274",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 48,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "alloc_and_get"
      ],
      "sink_functions": [
        "serialargs_get_ptr",
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Uses 'size' (derived from reader-controlled data) to compute allocation/copies; only overflow check and serialargs_get_ptr error cover it but no explicit upper bound on size.",
        "Uses 'size' from reader-controlled input to allocate and copy without an explicit semantic upper bound (resource/exhaustion risk).",
        "Uses 'size' (attr.attrs_size) from untrusted serialized input to compute allocation and drive copy; attacker-controlled size may affect allocation and copies despite overflow check."
      ],
      "code_excerpts": [
        "if (ADD_OVERFLOW(buf0_sz, size, &sz))",
        "if (ADD_OVERFLOW(buf0_sz, size, &sz))\n    return PKCS11_CKR_ARGUMENTS_BAD;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=remaining_bytes,dst_sz=sz",
          "size_triplet:copy_len=size+buf0_sz,src_sz=orig_next_remaining,dst_sz=sz"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0275",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 60,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "alloc_and_get"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Allocates 'sz' = buf0_sz + size (size controlled by input) and copies both buf0 and src into the allocation; large size may lead to resource exhaustion or unexpected behavior."
      ],
      "code_excerpts": [
        "ptr = TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sz,src_sz=buf0_sz+size,dst_sz=sz"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0276",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 66,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "alloc_and_get",
        "serialargs_get"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "dst 'ptr' (allocated local buffer) passed as dst; ptr is TA-allocated but will contain copied data",
        "src 'buf0' passed as src; origin uncertain (could be REE-visible or TA-private) from earlier context",
        "First TEE_MemMove copies buf0 (likely TA data) into ptr, second copies src (potentially REE-controlled) into ptr+buf0_sz; second copy size may be influenced by REE.",
        "Copies buf0_sz bytes from buf0 into ptr; origin of buf0 unclear (could be REE-derived), binding ptr target is TEE-private allocation",
        "Copies buf0_sz bytes from buf0 (origin may be REE-visible) into allocated ptr without validating combined sizes/overlap",
        "Call-site binding: 'ptr' destination is TA-allocated buffer (TEE-private) receiving data from caller buffers.",
        "Copies buf0_sz bytes from caller buffers into TA-allocated ptr without local robustness checks here.",
        "Call-site binding: destination 'ptr' is TA-allocated buffer while source 'buf0' origin is unclear (could be TEE-private).",
        "Call-site binding: source 'buf0' parameter bound at call-site; origin of buf0 is not shown (unknown region).",
        "Copies buf0 (from orig_next/serialargs) into allocated ptr; source likely REE-origin and destination TEE-private, possible untrusted data concatenation without explicit bounds check here.",
        "Concatenates pieces read from serialargs into allocated buffer without an explicit bounds check visible here.",
        "First call copies buf0_sz bytes from buf0 (origin unclear) into ptr; source/destination origins not fully validated here",
        "Assembly copies into allocated buffer using buf0_sz and size without visible bounds checks here",
        "Copies buf0_sz bytes from buf0 (likely REE-provided) into allocated ptr without visible bounds check here",
        "binding: ptr/dst is target buffer (allocated locally) while buf0/src origins vary; pointer arguments forwarded into TEE_MemMove from upstream callers",
        "binding: destination 'ptr' passed into TEE_MemMove from caller context",
        "binding: source 'buf0' passed into TEE_MemMove; provenance unclear",
        "Dest 'ptr' is a constructed buffer pointer (TA-allocated/unknown) passed as destination for copies.",
        "src 'buf0' may be caller-controlled/shared memory passed into TEE_MemMove.",
        "Call-site binding: destination 'ptr' is TA-allocated pointer, src 'buf0' likely from caller-controlled data; origins differ.",
        "Destination ptr may be TA-allocated and src buf0 is likely caller-provided; aliasing/binding of pointers at call-site recorded.",
        "dst parameter 'ptr' binds to TA-allocated buffer receiving first copy chunk.",
        "src parameter 'buf0' is TA-local data (previously populated); second copy uses 'src' which may be from serialargs (REE-visible).",
        "Copies bytes from src into TA buffer without visible validation of content or ensuring combined buffer capacity.",
        "First TEE_MemMove copies buf0 (likely from REE or intermediate) into ptr, possibly building a concatenated buffer; records REE->TA aliasing risk.",
        "Call-site binding: copies buf0 (origin uncertain) into ptr; origins of ptr and buf0 are local/alloc and/or caller-dependent.",
        "Copies buf0 into allocated ptr; buf0 origin unclear (could be REE-controlled), potential aliasing of shared buffers.",
        "Copies buf0_sz bytes from buf0 (origin unclear) into ptr; src may be REE-visible or TA-private depending on caller.",
        "Binding of dest parameter to allocated ptr which will become returned to caller (*out); alias of TA-allocated buffer passed back to caller.",
        "Copies buf0 (origin unclear) into ptr; origin of buf0 may be REE or TA and is not shown here, so binding is uncertain.",
        "First TEE_MemMove binds dest ptr and buf0 (src) origins; buf0 provenance unclear (could be REE or TA) so record aliasing.",
        "Copies buf0 into ptr then copies src into ptr+buf0_sz; src/buf0 may originate from untrusted serialargs/REE buffers leading to unvalidated concatenation.",
        "dest 'ptr' is written from buf0 (caller-provided) and then from src; binds callee args to caller buffers (ptr, buf0, src)",
        "First copy writes buf0 (likely REE-origin) into ptr (TA-private), second call (line 67) appends src into ptr; origins differ and src may be REE-controlled.",
        "Copies buf0 (origin not proven here) into allocated ptr; origin region of buf0 is unknown at this call-site.",
        "Copies buf0 into allocated buffer; origin of buf0 unclear at this call-site.",
        "Call-site binding: destination 'ptr' is TA-allocated target (alias passed into helper).",
        "Call-site binding: second call writes src into ptr+buf0_sz; src origin uncertain (could be REE-derived).",
        "Copies buf0 into allocated ptr; provenance of buf0 unclear (could be REE or TA), so origin is unknown.",
        "Copies buf0 into newly allocated ptr; binds callee dst 'ptr' (TA-private) to src 'buf0' (origin unclear from context).",
        "Call-site binding: destination 'ptr' is TA-allocated (write target) receiving buf0 bytes then more data; dst is TA-private.",
        "Binding dest parameter to ptr (allocated/TA-private) for concatenation",
        "Binding src parameter to buf0 (origin depends on caller; could be REE-visible or TA-private)",
        "First call at this site writes buf0 into allocated ptr; buf0 origin unclear (could be TA or REE), binding observed.",
        "Copies buf0 into allocated ptr; buf0 origin (REE vs TA) is unclear at call-site.",
        "Copies buf0 into ptr and then src into ptr+buf0_sz; source buffers may be REE-origin and destination ptr is allocator output — potential aliasing and size-controlled arithmetic from callers.",
        "Copies with ptr arithmetic and caller-controlled sizes; potential aliasing/size arithmetic risks.",
        "Copies buf0_sz bytes into allocated ptr from buf0; operands appear internal (likely TA-private) but origin not fully proven here.",
        "Internal copy into allocated buffer; provenance not fully proven here.",
        "Copies buf0 into ptr; buf0 likely originates from caller-provided data, so record alias/binding.",
        "Call-site binding: destination 'ptr' is TA-allocated buffer while source 'buf0' is from earlier buffer possibly derived from REE.",
        "Call-site binding: callee dest 'ptr' aliases local allocation (ptr) — destination is TA-private.",
        "Call-site binding: callee src 'buf0' origin unclear (could be TA or REE); origin marked unknown.",
        "Binding: destination 'ptr' (first call) is TA-allocated buffer (alloc_and_get), origin TA-private.",
        "Binding: source 'buf0' is from caller/context; origin unclear (could be REE or TA), treated as unknown.",
        "TEE_MemMove copies buf0_sz bytes from buf0 into ptr; origins of buf0/ptr uncertain (could be REE-visible or TA-private), potential aliasing of shared buffers.",
        "binding: destination 'ptr' passed as first arg (TEE-private) to TEE_MemMove",
        "binding: source 'buf0' passed as second arg; origin unclear (could be REE-visible)",
        "Call-site binding: first call destination 'ptr' points to allocated buffer (TA-private)",
        "Call-site binding: first call source 'buf0' provenance uncertain (could be REE or TA); treated as unknown",
        "Copies buf0 (likely TA-private struct data) into newly allocated ptr in-place; binding of caller buf0 into dst occurs here",
        "binds destination 'ptr' (TEE-allocated) to caller-local pointer; copies TA-local header region into allocated buffer",
        "Copies 'src' read from args (REE-visible) into newly allocated TA-private buffer via TEE_MemMove; origin of src is attacker-controlled.",
        "Destination 'ptr' is TA-private buffer allocated by TEE_Malloc; source 'buf0' is TA-private (caller stack) copied into TA memory.",
        "Source 'buf0' originates from caller-provided buffer (caller stack) but is TA-private in this context.",
        "Copies buf0 (&attr, TEE-private) into malloc'd ptr (TEE-private) via TEE_MemMove; both source and dest are TA-private but size arithmetic influences allocation",
        "Copies local attr structure into allocated buffer; safe but size contributes to allocation arithmetic.",
        "Copies buf0 (from REE-derived attr) into newly allocated TEE heap via TEE_MemMove",
        "Destination ptr is allocated in TEE heap (TEE_Malloc) while source buf0 originates from REE-derived attr; binding of dest pointer is an alias of TEE-private heap",
        "Source buf0 was populated from serialargs (REE-controlled); binding records origin as REE-visible",
        "Copies data from buf0 and src into a TEE-allocated buffer using sizes that include input-derived 'size'; destination is TEE-private but source is REE-originated.",
        "Call-site binding: destination 'ptr' is TEE-allocated buffer (TEE-private) returned to caller; alias established at alloc_and_get.",
        "Call-site binding: source 'buf0' originates from local 'attr' populated from args (which come from REE); treat as potentially REE-derived.",
        "Performs TEE_MemMove from 'src' (data read from serialargs -> likely REE-provided) into TEE_Malloc'd buffer; copying attacker-controlled bytes into TA memory.",
        "Destination 'ptr' is TA-private (TEE_Malloc) and is written from 'buf0' which is caller-local (TA-private); copy of non-REE data into TA memory.",
        "Dest ptr is TA-allocated (TEE-private) and source buf0 is TA-local (&attr); copying buf0 into allocated region.",
        "Binding: destination ptr (returned via *out) is TA-private pointer assigned to caller; records allocation origin.",
        "size (from upstream attr.attrs_size via serialargs) is used to read from REE (serialargs_get_ptr) and drive copies without additional validation here",
        "buf0 (source) is a TEE-private/local stack struct pointer (&attr) passed into memmove as source; dst ptr is TEE-allocated private memory",
        "binding: dst pointer 'ptr' is returned via out parameter to caller (TEE-private) - alias recorded",
        "Copies REE-provided 'src' into newly allocated TA-private buffer via TEE_MemMove; destination is TA-private but data originates from REE",
        "Copies local header buf0 (TA-private) into allocated TA-private buffer ptr; simple TA->TA move of non-REE data"
      ],
      "code_excerpts": [
        "TEE_MemMove(ptr, buf0, buf0_sz);",
        "TEE_MemMove(ptr, buf0, buf0_sz); TEE_MemMove(ptr + buf0_sz, src, size);",
        "TEE_MemMove(ptr + buf0_sz, src, size);",
        "TEE_MemMove(ptr, buf0, buf0_sz);\nTEE_MemMove(ptr + buf0_sz, src, size);",
        "*out = ptr;"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=buf0_sz,src_sz=unknown,dst_sz=unknown",
          "src_region:unknown",
          "flow_dir:REE->TA",
          "size_triplet:copy_len=buf0_sz or size,src_sz=buf0_sz/orig_remaining_bytes,dst_sz=ptr_alloc_sz",
          "size_triplet:copy_len=buf0_sz,src_sz=buf0_sz,dst_sz=unknown",
          "src_region:REE-visible",
          "flow_dir:TA->TA",
          "sensitivity_label:public",
          "size_triplet:copy_len=buf0_sz/size,src_sz=unknown,dst_sz=unknown",
          "dst_region:unknown",
          "size_triplet:copy_len=buf0_sz,src_sz=buf0_sz,dst_sz=buf0_sz",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=size",
          "flow_dir:TA->REE",
          "size_triplet:copy_len=buf0_sz,src_sz=buf0_sz,dst_sz=ptr_region_size",
          "size_triplet:copy_len=buf0_sz,src_sz=buf0_sz,dst_sz=allocated_ptr_sz",
          "size_triplet:copy_len=buf0_sz,src_sz=buf0_sz,dst_sz=allocated_ptr_size",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=buf0_sz or size,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=buf0_sz,src_sz=buf0_sz,dst_sz=available_ptr_space",
          "size_triplet:copy_len=buf0_sz,src_sz=buf0_sz,dst_sz=sz",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=sz",
          "flow_dir:TA->TEE-private",
          "size_triplet:copy_len=buf0_sz+size,src_sz=buf0_sz and size,dst_sz=sz",
          "size_triplet:copy_len=size,src_sz=orig_next_remaining,dst_sz=sz - buf0_sz",
          "size_triplet:copy_len=sizeof(void *),src_sz=unknown,dst_sz=sizeof(void *)",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=sz",
          "size_triplet:copy_len=buf0_sz+size,src_sz=buf0_sz+size,dst_sz=sz",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=sz - buf0_sz"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0277",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 67,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "alloc_and_get"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "dst 'ptr + buf0_sz' (pointer arithmetic) passed as dst; arithmetic on TA buffer influenced by sizes possibly from REE",
        "src 'src' passed as src; provenance may be REE-controlled via serialargs, making copied bytes untrusted",
        "TEE_MemMove copies 'size' bytes from src (reader-controlled) into ptr+buf0_sz; offset arithmetic with buf0_sz may lead to out-of-bounds if sizes unvalidated.",
        "Copies 'size' bytes from src into ptr+buf0_sz; src origin uncertain (likely args-derived) and destination is TA-private buffer with pointer arithmetic",
        "Copies size bytes from src into ptr+buf0_sz without validating src provenance or that ptr has room for buf0_sz+size",
        "Copies 'size' bytes from src (possibly REE-originated) into ptr+buf0_sz without local size/sanity checks here.",
        "Copies 'size' bytes from src (origin may be untrusted) into ptr+buf0_sz; size may be attacker-controlled.",
        "Copies 'src' into ptr+offset (constructed buffer); 'src' may be REE-originated and write uses computed pointer arithmetic (ptr+buf0_sz).",
        "Second call copies 'size' bytes from src (likely REE-derived) into ptr+buf0_sz without explicit bounds check here",
        "Copies 'size' bytes from src (from args) into ptr+buf0_sz without explicit bounds check here",
        "binding: second copy into ptr+offset uses src (possibly REE-origin) and caller-controlled offset arithmetic",
        "binding: destination ptr+buf0_sz passed into TEE_MemMove (pointer arithmetic may alias buffers)",
        "binding: source 'src' passed into TEE_MemMove here; provenance unclear at this call-site",
        "Dest 'ptr + buf0_sz' is pointer arithmetic on buffer; destination aliases constructed buffer and may enable overwrite if sizes miscomputed.",
        "src 'src' at this site may originate from earlier serialargs_get_ptr or caller buffers (shared/REE-visible).",
        "Second copy composes ptr + buf0_sz offset and copies 'size' bytes from src without an explicit bounds check here.",
        "Second copy into ptr+buf0_sz from src (derived from args) binds caller-provided data into assembled buffer.",
        "dst parameter 'ptr + buf0_sz' binds to TA-allocated buffer offset receiving bytes from src (potentially REE-derived).",
        "Second copy moves bytes from src (potentially REE-controlled) into TA buffer without validation of content or bounds beyond size parameter.",
        "Second TEE_MemMove appends src into ptr+buf0_sz; src may be REE-derived and size-driven, so concatenation bounds should be tracked.",
        "Call-site binding: copies src (origin unclear) into ptr+buf0_sz; pointer arithmetic on dst uses prior size.",
        "Copies src into ptr+offset; src provenance ambiguous (could be REE) and write uses computed offset into allocated buffer.",
        "Copies 'size' bytes from src into ptr+buf0_sz; pointer arithmetic on dst may alias shared or local memory depending on ptr origin.",
        "Binding of dest parameter to ptr+buf0_sz (TA-allocated region) and src parameter to 'src' (origin uncertain); records potential mixing of regions.",
        "Copies 'size' bytes from src into ptr+buf0_sz; if src is from REE-visible input, this writes untrusted bytes into TA buffer without local bounds here.",
        "Copies 'size' bytes from src into allocated buffer without local visible bounds here; relies on upstream checks.",
        "Second TEE_MemMove binds dest (ptr+buf0_sz) and src; src provenance (serialargs-derived) may be REE-visible—record aliasing and taint of size.",
        "Copies src into ptr+buf0_sz using size 'size' possibly derived from serialargs; addition of offsets may allow attacker-controlled overwrite if sizes/offsets unchecked.",
        "Copies src into ptr+buf0_sz using size possibly derived from serialargs; addition of offsets may allow attacker-controlled overwrite if sizes/offsets unchecked.",
        "dest 'ptr+buf0_sz' is written from src (which may be REE-derived); binds callee args to caller origins",
        "Copies 'size' bytes from src (potentially REE-controlled) into ptr+buf0_sz (TA-private); offset arithmetic uses buf0_sz which must be trusted.",
        "Copies 'size' bytes from src into ptr+buf0_sz; src provenance may be REE-visible and size is caller-controlled.",
        "Call-site binding: this call writes additional src region into assembled buffer; src may be REE-controlled.",
        "Copies src into ptr+buf0_sz; src provenance not established in this site, so treated as unknown.",
        "Appends 'size' bytes from src into ptr+buf0_sz; binds callee dst (ptr+offset) as TA-private and src origin as unknown/possibly REE-visible.",
        "Second copy into ptr+buf0_sz uses 'src' and 'size' which may originate from serialargs (REE); relies on upstream bounds checks.",
        "Binding dest parameter to ptr + buf0_sz (TA-private) for appending",
        "Binding src parameter to src (provided by caller code path; origin not resolved here)",
        "Second call at this site copies src into ptr+buf0_sz; origin of src unclear at call-site so binding is recorded as unknown.",
        "Copies src into ptr+buf0_sz; src origin unclear at call-site.",
        "Copies src into ptr+buf0_sz where ptr arithmetic uses buf0_sz (caller-controlled); index/offset arithmetic driven by sizes from callers.",
        "Copies 'size' bytes into ptr+offset from src; src provenance may be caller-controlled and size is externally supplied at call-sites.",
        "Copies 'size' bytes into ptr+offset from src; src provenance may be caller-controlled at call-sites.",
        "Copies src into ptr+buf0_sz; src may be REE-origin and offset arithmetic writes into TA memory, record binding and offset usage.",
        "Call-site binding: destination 'ptr + buf0_sz' is TA-allocated; source 'src' may be REE-derived.",
        "Call-site binding: callee dest 'ptr + buf0_sz' aliases TA-local allocation region — destination is TA-private.",
        "Call-site binding: callee src 'src' origin unclear at this call-site (marked unknown).",
        "Binding: destination 'ptr + buf0_sz' is TA-private pointer arithmetic writing into allocated buffer.",
        "Binding: source 'src' may originate from serialargs buffer (REE-backed), so copy may move REE-controlled bytes into TA memory.",
        "TEE_MemMove copies 'size' bytes from src into ptr+buf0_sz; src origin uncertain (could be REE-derived), and write uses pointer arithmetic into ptr.",
        "binding: destination 'ptr + buf0_sz' (TEE-private pointer arithmetic) passed as first arg",
        "binding: source 'src' passed as second arg; origin depends on caller (possibly REE-derived)",
        "Call-site binding: second call destination 'ptr + buf0_sz' is TA-private buffer offset (in-place aliasing risk if arithmetic tainted)",
        "Call-site binding: second call source 'src' here originates from args/buffer (likely REE-visible)",
        "Copies 'size' bytes from src (derived from serialargs/REE) into TA-private buffer ptr+buf0_sz; length 'size' is from untrusted args",
        "copies 'size' bytes from src (obtained via serialargs_get_ptr from REE buffer) into TEE buffer without further validation here",
        "Destination 'ptr + buf0_sz' is TA-private buffer region; source 'src' is read from args (REE-visible) and copied into TA memory.",
        "Source 'src' is derived from serialargs_get_ptr reading 'size' bytes from REE-controlled buffer (args).",
        "Copies data from src (derived from serialargs -> REE-visible) into TA-allocated buffer (ptr + offset), bringing REE-origin data into TA memory",
        "Copies REE-provided serialargs bytes into TA heap; source is untrusted and may require validation before use elsewhere.",
        "Copies src (from serialargs/REE) into allocated heap via TEE_MemMove; src originates from REE-controlled serialargs",
        "Destination ptr+buf0_sz is derived from TEE-allocated ptr via pointer arithmetic (TEE-private)",
        "Source src is obtained from serialargs_get_ptr (REE-controlled) and then copied into heap",
        "Call-site binding: destination 'ptr + buf0_sz' (offset into TEE-allocated buffer) aliases the same TEE-private allocation.",
        "Copies 'size' bytes from 'src' (read from args) into dest; 'size' is input-derived (attr.attrs_size) and lacks additional validation here.",
        "Copies 'src' (data read from serialargs -> likely REE-provided) into TA-private buffer using attacker-influenced 'size' (attr.attrs_size).",
        "Dest ptr+buf0_sz is TA-allocated; source 'src' is obtained from serialargs_get_ptr and may point into REE-visible memory (shared).",
        "src is derived from REE-visible serialargs_get_ptr and size (from upstream attr.attrs_size) controls the copy into TEE memory without local validation here",
        "Copies 'src' (read from args->next, REE-controlled) into TA-private ptr at offset; data originates from REE"
      ],
      "code_excerpts": [
        "TEE_MemMove(ptr + buf0_sz, src, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=unknown",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=unknown",
          "size_triplet:copy_len=size,src_sz=orig_remaining_bytes,dst_sz=ptr_alloc_sz - buf0_sz",
          "src_region:unknown",
          "size_triplet:copy_len=size,src_sz=orig_remaining,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=unknown",
          "sensitivity_label:public",
          "dst_region:unknown",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=size",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=ptr_region_size",
          "size_triplet:copy_len=size,src_sz=args_remaining,dst_sz=unknown",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size_or_src_size,dst_sz=allocated_ptr_sz - buf0_sz",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=allocated_ptr_size - buf0_sz",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=size",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=available_ptr_space - buf0_sz",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=sz",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=sz - buf0_sz",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=sz",
          "size_triplet:copy_len=size,src_sz=orig_next_remaining,dst_sz=sz - buf0_sz",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=sz-buf0_sz",
          "size_triplet:copy_len=size,src_sz=ctrl->memref.size,dst_sz=sz",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=sz - buf0_sz"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0278",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 145,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_alloc_get_attributes"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Assigns allocated pointer 'p' to caller-provided out; propagates TA-private allocation back to caller"
      ],
      "code_excerpts": [
        "*out = p;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sizeof(void*),src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0279",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 171,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialargs_get_session_from_handle"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Writes resolved session pointer back into caller-provided sess (alias of caller stack); records binding of callee output to caller region.",
        "Assigns resolved session pointer back to caller-provided sess pointer; records binding."
      ],
      "code_excerpts": [
        "*sess = session;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:session",
          "size_triplet:copy_len=sizeof(void*),src_sz=sizeof(void*),dst_sz=sizeof(void*)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0280",
      "file": "/workspace/benchmark/vuln-ta-collection/optee-pkcs11-cve/ta/serializer.c",
      "line": 188,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "other",
      "functions": [
        "TEE_MemMove",
        "alloc_and_get / related",
        "alloc_and_get",
        "some_helper",
        "serializer.c",
        "serialargs_*",
        "serialargs_get",
        "serialargs_helper",
        "some_func",
        "some_fn",
        "some_function",
        "serialize"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "other",
        "weak_input_validation",
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "dst 'buf + *blen' (offset write) passed as dst; destination offset depends on *blen which may be attacker-influenced leading to potential overflow",
        "Copies 'len' bytes from data into buf + *blen; *blen and len may be influenced by caller-controlled values leading to overflow if unbounded.",
        "Appends 'len' bytes from data into buf + *blen; data/source origin may be REE-visible and write uses caller-provided length *blen (tainted arithmetic)",
        "Appends len bytes from data into buf + *blen using tainted arithmetic for destination offset",
        "Copies len bytes from data (likely REE-controlled) into buf + *blen without explicit bounds check against buffer capacity",
        "Copies 'len' bytes from data (caller-provided) into buf + *blen without validating that destination has sufficient space here.",
        "Copies len bytes from data into buf + *blen without a local check that destination has sufficient space.",
        "Appends len bytes from data into buf+*blen; 'len' and 'data' may be derived from untrusted input leading to overflow if not checked.",
        "Call-site binding: destination 'buf + *blen' aliases caller buffer 'buf' (TA-private) while 'data' originates externally (unknown/REE-visible).",
        "Appends data using len derived from untrusted input; possible overflow if buffer capacity not enforced",
        "Copies 'data' into buf+*blen; source provenance unclear (may be REE or TA); destination is TA buffer updated with new length—possible overflow risk if bounds not enforced here.",
        "Writes data into buf + *blen using a length 'len'—bounds at this point are not evident, posing potential overflow risk.",
        "Appends 'len' bytes from data into buf + *blen without visible bounds validation at this site",
        "Copies len bytes from data into buf + *blen; len and *blen derived from caller-controlled values without local upper-bound here",
        "Copies 'len' bytes from data into buf + *blen where *blen and len may be influenced by caller data; offset/length not validated here",
        "Copy into buffer at offset *blen uses caller-influenced length/offset without local validation here.",
        "binding: destination buf + *blen passed into TEE_MemMove (destination may be shared or local depending on caller)",
        "binding: source 'data' passed into TEE_MemMove; provenance (REE vs TEE) not clear here",
        "Copies 'len' bytes from data (potentially REE-controlled) into buf + *blen without further validation; risk of overflow if blen/len not checked.",
        "Destination pointer 'buf + *blen' aliases buffer with runtime offset derived from *blen; origin/limits are unclear.",
        "TEE_MemMove(buf + *blen, data, len) copies caller-controlled data into buffer at runtime offset derived from *blen; bounds/limit checks are not obvious here.",
        "Call-site binding: destination 'buf + *blen' may be TA buffer and source 'data' originates from caller; offset arithmetic present.",
        "Appends 'len' bytes from caller-controlled data into buf at offset *blen without visible local bounds check here (risk of overflow).",
        "Appends data (from caller/REE) into buf at offset *blen without visible bounds check here.",
        "dst parameter 'buf + *blen' binds to TA buffer offset; destination derived from TA-managed buffer pointer and length.",
        "Copies 'len' bytes from 'data' (untrusted) into buf without visible range check against actual buffer capacity here.",
        "Copies len bytes from data (untrusted) into buf at offset *blen without visible bounds check here.",
        "Copies 'len' bytes from data into buf + *blen; destination is buffer growth in TA but source may be REE-visible—possible bounds/overflow risk if not checked by caller.",
        "Call-site binding: copies data (origin unclear) into buf + *blen; dst arithmetic uses *blen which may be attacker-influenced if not validated here.",
        "Appends 'len' bytes from data (likely REE-controlled) into buf at *blen without clear bounds check on buf; write target may alias shared/REE-visible memory.",
        "Copies len bytes from data (caller-provided) into buf + *blen; destination arithmetic uses *blen which is influenced by TA state and may cause overflow if unchecked.",
        "Binding src argument to caller 'data' which originates from REE-provided memref (shared).",
        "Binding of dest parameter to buf + *blen (buffer concat) and src to data; caller origins uncertain—possible REE-derived data copied into TA buffer or vice versa.",
        "Copies 'len' bytes into buf + *blen where *blen is attacker-influenced/tainted; possible out-of-bounds/overwrite of destination without evident bounds check here.",
        "Copies 'len' bytes into buf + *blen where *blen is tainted/variable; potential overwrite if bounds not enforced.",
        "Copies 'len' bytes from data (likely caller-provided) into buf + *blen (TA buffer) without local bounds here; record possible tainted-size/overflow risk.",
        "Copies 'len' bytes from data into buf + *blen; data may be REE-supplied and destination offset is attacker-influenced leading to potential overflow.",
        "dest 'buf + *blen' (caller buffer) is written from data (caller-provided); binds callee args to caller buffer origins and sizes",
        "Appends 'len' bytes from data into buf+*blen; data/source provenance unclear (could be REE), and write uses dynamic offset *blen.",
        "Copies 'len' bytes from data into buf + *blen; provenance of data and current buf length should be validated by caller.",
        "Call-site binding: destination 'buf + *blen' is buffer managed by caller; pointer aliasing of shared/TEE buffer uncertain.",
        "Copies 'len' bytes from data (caller-controlled) into buf+*blen without explicit bounds check against buffer capacity in this call-site.",
        "Copies data into buf+*blen; provenance of data not asserted here and destination is TA buffer—origin unknown.",
        "Writes 'len' bytes from data into buf + *blen (buffer growth); destination may be TA-managed but size/offset depend on caller-controlled *blen and len.",
        "Writes 'len' bytes into buf + *blen using caller-managed lengths; potential for out-of-bounds if caller-supplied lengths are incorrect.",
        "Copies 'len' bytes from 'data' into buf + *blen; 'data' may be from REE and len may be attacker-controlled if upstream checks are insufficient.",
        "Call-site binding: 'dst' computed as buf + *blen aliases TA buffer with offset derived from TA state; must ensure offset+len within allocation.",
        "Binding dest parameter to buf + *blen (buffer in caller; likely REE-visible or TA-private depending on allocation)",
        "Binding src parameter to data (origin from caller; may be REE-visible), then copying into buf -- potential shared-memory transfer",
        "Call copies data into buf + *blen; destination is TA buffer (buf) while source 'data' origin is unclear (could be REE or TA).",
        "Copies data into buf + *blen; destination is TA buffer while source origin is unclear.",
        "Copies data (likely REE-provided) into buf + *blen; destination offset uses *blen (caller-managed) which can lead to out-of-bounds if not checked here.",
        "Copies data into buf + *blen where *blen is caller-managed; if not checked this can overflow destination.",
        "Appends 'len' bytes from data (possibly caller-controlled) into buf + *blen without local bounds proof here.",
        "Copies data (likely caller-supplied) into buf+*blen; tainted length/offset used in destination pointer arithmetic recorded as structural risk.",
        "TEE_MemMove uses destination pointer with tainted offset buf + *blen and tainted length len; potential offset/size arithmetic risk if callers don't validate.",
        "Copies 'len' bytes into buf + *blen using len/from data which may be influenced by REE without localized bounds enforcement here.",
        "Call-site binding: callee dest 'buf + *blen' aliases caller buffer (likely TA-owned) used for accumulation; destination region marked TEE-private.",
        "Copies 'len' bytes into buf+*blen without local bounds check here; if len or *blen influenced by attacker, may overflow destination.",
        "Binding: destination 'buf + *blen' is a TA buffer but pointer arithmetic uses *blen (TA-controlled), origin TA-private.",
        "Binding: source 'data' origin depends on caller; in some call-sites data may be REE-controlled, treated as unknown here.",
        "TEE_MemMove appends 'len' bytes from data into buf + *blen; src likely caller data (potentially REE-visible) and destination uses runtime blen offset, risk of overflow if bounds not enforced here.",
        "binding: destination 'buf + *blen' passed as first arg (TEE-private buffer with offset)",
        "copies 'len' bytes from data into buf+*blen without local validation here; if data is REE-derived this is an unvalidated inbound copy",
        "Call-site binding: destination 'buf + *blen' is TA buffer offset; arithmetic uses *blen which may be tainted if caller-controlled",
        "Call-site binding: source 'data' originates from caller/serialargs (potentially REE-visible)",
        "Copies data into buf at offset *blen; origin/regions of buf and data ambiguous here causing structural alias risk",
        "copies data (likely REE-provided) into buffer at offset *blen; potential unchecked bounds if caller did not validate",
        "Destination 'buf + *blen' likely points into caller-managed buffer; origin ambiguous but write may extend into REE-visible region depending on buf provenance.",
        "Source 'data' is caller-provided input; if 'buf' is REE-visible this copy could write REE-visible memory from attacker-controlled source.",
        "Copies data (unknown origin, likely REE-visible) into buffer at buf + *blen; destination offset uses *blen (tainted/unchecked index risk)",
        "Destination buf + *blen uses dynamic offset; origin/region of buf not established here (unknown)",
        "Source data passed into TEE_MemMove likely originates from serialargs/REE at call-site",
        "Call-site binding: destination buffer ('buf + *blen') and source ('data') origins depend on caller; potential REE->TA copy depending on caller.",
        "Destination buf + *blen may be REE-visible or shared; source 'data' origin unknown (likely from serialargs) and length 'len' is caller-controlled.",
        "data (likely from REE) is copied into buf+*blen using len without shown bounds check here",
        "Copies 'data' into buffer at buf + *blen (possible append); origin of 'data' and bounds of buf depend on caller and are uncertain",
        "destination pointer buf + *blen aliases caller-managed buffer (bstart) and is mutated after realloc, creating aliasing of caller buffer into internal region",
        "data pointer and len (often derived from upstream REE-provided template) are copied into destination without further validation of content or expected type",
        "length argument len is caller-controlled (propagated from template parsing) and is forwarded to memmove, affecting allocation and copy size",
        "Copies 'len' bytes from caller-controlled data into reallocated buffer; though overflow check exists, data length is caller-controlled and realloc may succeed with large allocations",
        "Call-site binding: destination pointer is buffer returned by TEE_Realloc (TA-private) computed from bstart/*blen",
        "Call-site binding: source 'data' originates from parsed attribute stream (influenced by REE input)",
        "Copies caller-controlled 'len' bytes into reallocated buffer; although ADD_OVERFLOW checks integer overflow, 'len' is untrusted and may cause excessive allocation or logic issues",
        "Copies caller-controlled 'len' bytes into reallocated buffer; overflow check present but no policy upper-bound on 'len'.",
        "TEE_MemMove copies caller-controlled data into reallocated buffer without validating data content or checking that data pointer is valid for len bytes",
        "alias of destination pointer (buf + *blen) passed into TEE_MemMove; destination is TA heap buffer derived from caller-managed bstart",
        "alias of source data pointer passed into TEE_MemMove; data may point into REE-provided buffers parsed earlier",
        "TEE_MemMove copies caller-controlled data pointer for len bytes without validating that 'data' is valid for 'len' or that len is within expected provenance",
        "destination pointer is an alias into a realloc'd buffer computed in caller; record binding of callee dest to caller-owned buffer (TEE-private)",
        "copies 'len' bytes from caller-provided 'data' into internal buffer; 'len' originates from higher-level input and lacks an application-level upper bound check here",
        "binds callee 'data' parameter to caller-origin 'data' pointer (may be heap or REE-derived); record origin",
        "TEE_MemMove writes len bytes at buf + *blen after realloc; reliance on ADD_OVERFLOW and realloc success provides safety but write uses caller-controlled *blen and len",
        "Destination buffer (buf + *blen) is derived from caller-managed bstart and updated via realloc; write target provenance links caller buffer into this copy",
        "Source pointer 'data' may originate from allocated TEE attribute buffers or local temporaries (e.g., a_ptr or &data32) and is copied into buf",
        "The copy uses caller-controlled *blen and len; safety depends on prior ADD_OVERFLOW and successful realloc—no explicit runtime check at the copy site",
        "Copy uses caller-controlled *blen and len; safety depends on earlier overflow check and successful realloc.",
        "destination buffer 'buf + *blen' is alias of realloc'd bstart which originates from attribute buffer (caller-influenced); reallocation then used as copy target",
        "source 'data' may be caller-controlled (either local data32 or a TEE-allocated a_ptr); origin depends on callsite",
        "length 'len' (copy size) is used to bound the copy after realloc; although integer-overflow and alloc checks exist, no semantic check ensures 'len' matches expected attribute capacity",
        "length 'len' is used to bound the copy after realloc; semantic validation that 'len' matches expected attribute capacity is missing",
        "bstart-derived buffer (head-derived) is reallocated and used as destination; origin of bstart at call-site ties to upstream REE-derived templates.",
        "blen (buf_len) at call-site is updated and used to compute destination offset; initial blen derived from (*head)->attrs_size (upstream).",
        "copies caller-provided data into TA-managed buffer without semantic validation of data contents (data originates from REE).",
        "destination pointer is buf + *blen into TA-allocated buffer (result of TEE_Realloc); binds callee dest to TA-private buffer used as serialization target",
        "copies 'data' of length len into buffer; 'data' may originate from REE (e.g., EC_PARAMS via a_ptr) and len is caller-controlled without semantic validation",
        "copies caller-controlled 'data' of length 'len' into buffer at offset *blen; although integer overflow and allocation are checked, there is no explicit validation of 'len' relative to expected attribute semantics",
        "destination pointer is alias into TA-allocated buffer 'buf' produced by TEE_Realloc; binding buf+*blen into copy",
        "source 'data' may originate from REE (caller-provided attribute payload) and is passed into TEE_MemMove",
        "copies caller-controlled data of length 'len' into TA buffer at offset *blen; although overflow and allocation are checked, there is no semantic validation of 'len' vs expected attribute semantics",
        "copies caller-controlled data of length 'len' into TA buffer; lacks attribute-specific length validation though integer overflow/allocation are checked."
      ],
      "code_excerpts": [
        "TEE_MemMove(buf + *blen, data, len);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "weak_input_validation",
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:unknown",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=*blen + len",
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "size_triplet:copy_len=len,src_sz=orig_remaining_bytes,dst_sz=buf_capacity - *blen",
          "src_region:unknown",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=(*blen)+len",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=unknown",
          "size_triplet:copy_len=len,src_sz=orig_remaining,dst_sz=*blen + len",
          "size_triplet:copy_len=len,src_sz=data_len_unknown,dst_sz=*blen + len",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=(*blen)+len",
          "sensitivity_label:public",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=(buf_size - *blen)",
          "dst_region:unknown",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=(*blen + len)",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=unknown",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=buf_size-*blen",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=(*blen + len)",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=buf_capacity - *blen",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=(*buf_size - *blen)",
          "dst_region:REE-visible",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=buffer_capacity - *blen",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=buffer_total_size - *blen",
          "size_triplet:copy_len=len,src_sz=unknown,dst_sz=*blen+len",
          "flow_dir:TA->TA",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=*blen + len",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=buffer_total_size - *blen",
          "flow_dir:REE->unknown",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=unknown - *blen",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=nlen - *blen",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=*blen",
          "flow_dir:TA->TEE-private",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=*blen",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=nlen - *blen",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=nlen",
          "flow_dir:TEE->TA",
          "size_triplet:copy_len=sizeof(char*),src_sz=unknown,dst_sz=nlen",
          "size_triplet:copy_len=sizeof(size_t),src_sz=(*head)->attrs_size,dst_sz=nlen",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=*blen + len"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0281",
      "file": "/workspace/vuln-ta-collection/optee-pkcs11-cve/ta/attributes.c",
      "line": 49,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "serialize"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "data pointer passed into serialize originates from caller (may point into REE-provided buffer parsed earlier)"
      ],
      "code_excerpts": [
        "rc = serialize(bstart, &buf_len, data, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=len,src_sz=len,dst_sz=*blen"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0282",
      "file": "/workspace/vuln-ta-collection/optee-pkcs11-cve/ta/handle.c",
      "line": 64,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "TEE_MemFill"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Destination pointer is db->ptrs + db->max_ptrs (TA-managed buffer) passed into MemFill; length derived from db fields used to initialize newly realloc'd region."
      ],
      "code_excerpts": [
        "TEE_MemFill(db->ptrs + db->max_ptrs, 0, (new_max_ptrs - db->max_ptrs) * sizeof(void *));"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=(new_max_ptrs - db->max_ptrs) * sizeof(void *),src_sz=unknown,dst_sz=new_max_ptrs * sizeof(void *)"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0283",
      "file": "/workspace/vuln-ta-collection/optee-pkcs11-cve/ta/processing.c",
      "line": 376,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "add_attribute"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "data pointer (a_ptr) passed in originates from TEE alloc_get_tee_attribute_data (TEE-private) and is copied into attribute list"
      ],
      "code_excerpts": [
        "rc = add_attribute(head, pkcs11_id, a_ptr, a_size);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:secret",
          "size_triplet:copy_len=a_size,src_sz=a_size,dst_sz=buf_len"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    }
  ]
}