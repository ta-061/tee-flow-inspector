{
  "analysis_date": "2025-11-29T06:46:38.478078",
  "analysis_time_seconds": 866.1345021724701,
  "analysis_time_formatted": "14.4 minutes",
  "llm_provider": "openai",
  "analysis_mode": "hybrid",
  "rag_enabled": false,
  "statistics": {
    "total_flows_analyzed": 14,
    "flows_with_vulnerabilities": 13,
    "total_vulnerability_lines": 27,
    "total_structural_risk_lines": 70,
    "total_detections_before_consolidation": 138,
    "total_lines_after_consolidation": 97,
    "consolidation_rate": "29.7%",
    "severity_distribution": {
      "critical": 0,
      "high": 27,
      "medium": 0,
      "low": 0
    },
    "cwe_distribution": {
      "CWE-200": 11,
      "CWE-319": 4,
      "CWE-122": 10,
      "CWE-120": 1,
      "CWE-367": 1
    },
    "rule_distribution": {
      "unencrypted_output": 14,
      "other": 49,
      "weak_input_validation": 34,
      "shared_memory_overwrite": 14
    },
    "execution_time_seconds": 866.1345021724701,
    "llm_calls": 39,
    "cache_hits": 13,
    "cache_partial_hits": 13,
    "cache_misses": 1,
    "cache_hit_rate": "92.9%",
    "token_usage": {},
    "retries": 0,
    "retry_successes": 0
  },
  "total_vulnerability_lines": 27,
  "vulnerabilities": [
    {
      "vulnerability_id": "VULN-0001",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 116,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key2 copied unencrypted to REE-visible params[1].memref.buffer; variable name implies sensitive key material"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable key2 initialized with literal '123456'",
          "propagation_path": [
            "key2 (TEE-private) -> params[1].memref.buffer (REE-visible) @ /workspace/benchmark/bad-partitioning/ta/entry.c:116"
          ],
          "sink": "TEE_MemMove copies key2 to REE-visible shared memory buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE and can invoke TA_HELLO_WORLD_CMD_OUTPUT command",
            "params[1] is configured as MEMREF_INOUT allowing REE to read the output"
          ],
          "attack_scenario": "Attacker invokes the TA command from REE, causing the TA to copy the sensitive key material into shared memory. Attacker then reads the shared memory buffer from REE to obtain the plaintext key.",
          "impact": "Disclosure of sensitive cryptographic key material to untrusted REE, compromising confidentiality of protected data"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce_2:116",
          "recommendation": "Encrypt key2 before copying to REE-visible buffer, or avoid exposing key material to REE entirely"
        },
        {
          "type": "access_control",
          "location": "produce_2:116",
          "recommendation": "Implement policy check to prevent sensitive key material from being copied to shared memory"
        }
      ],
      "decision_rationales": [
        "Line 116 copies TEE-private key material (key2) directly to REE-visible shared memory via TEE_MemMove. The variable name 'key2' indicates sensitive data, the destination is confirmed REE-visible (params[1].memref.buffer from MEMREF_INOUT), and no encryption or sanitization is applied. All three promotion conditions for unencrypted_output are satisfied."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0002",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 117,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key2 copied unencrypted to REE-visible params[2].memref.buffer"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable key2 initialized with literal '123456'",
          "propagation_path": [
            "key2 <- '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:112",
            "params[2].memref.buffer <- key2 via snprintf @ /workspace/benchmark/bad-partitioning/ta/entry.c:117",
            "params[2].memref.buffer <- key2-vi via snprintf @ /workspace/benchmark/bad-partitioning/ta/entry.c:121",
            "params[2].memref.buffer <- key2-vi-v via snprintf @ /workspace/benchmark/bad-partitioning/ta/entry.c:122"
          ],
          "sink": "snprintf writes to REE-visible shared memory buffer params[2].memref.buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command from REE",
            "Attacker has access to shared memory buffer params[2].memref.buffer"
          ],
          "attack_scenario": "Attacker invokes the TA command from Normal World, causing the TA to copy sensitive key material into REE-visible shared memory. Attacker then reads the shared memory to obtain the plaintext key.",
          "impact": "Disclosure of cryptographic key material to untrusted Normal World, compromising confidentiality of protected data"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce_2:117",
          "recommendation": "Encrypt key2 before copying to REE-visible buffer or avoid exposing key material to REE"
        },
        {
          "type": "encryption",
          "location": "produce_2:121",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        },
        {
          "type": "encryption",
          "location": "produce_2:122",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        }
      ],
      "decision_rationales": [
        "Lines 117, 121, 122 copy TEE-private data named 'key2' (implying sensitive key material) directly to REE-visible shared memory without encryption. All three promotion conditions are met: dst_region is REE-visible, sensitivity_label is 'key' based on variable naming, and no sanitizer blocks the flow. This constitutes information disclosure (CWE-200)."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0003",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 121,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key2 and vi copied unencrypted to REE-visible shared memory"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable key2 initialized with literal '123456'",
          "propagation_path": [
            "key2 <- '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:112",
            "params[2].memref.buffer <- key2 via snprintf @ /workspace/benchmark/bad-partitioning/ta/entry.c:117",
            "params[2].memref.buffer <- key2-vi via snprintf @ /workspace/benchmark/bad-partitioning/ta/entry.c:121",
            "params[2].memref.buffer <- key2-vi-v via snprintf @ /workspace/benchmark/bad-partitioning/ta/entry.c:122"
          ],
          "sink": "snprintf writes to REE-visible shared memory buffer params[2].memref.buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command from REE",
            "Attacker has access to shared memory buffer params[2].memref.buffer"
          ],
          "attack_scenario": "Attacker invokes the TA command from Normal World, causing the TA to copy sensitive key material into REE-visible shared memory. Attacker then reads the shared memory to obtain the plaintext key.",
          "impact": "Disclosure of cryptographic key material to untrusted Normal World, compromising confidentiality of protected data"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce_2:117",
          "recommendation": "Encrypt key2 before copying to REE-visible buffer or avoid exposing key material to REE"
        },
        {
          "type": "encryption",
          "location": "produce_2:121",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        },
        {
          "type": "encryption",
          "location": "produce_2:122",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        }
      ],
      "decision_rationales": [
        "Lines 117, 121, 122 copy TEE-private data named 'key2' (implying sensitive key material) directly to REE-visible shared memory without encryption. All three promotion conditions are met: dst_region is REE-visible, sensitivity_label is 'key' based on variable naming, and no sanitizer blocks the flow. This constitutes information disclosure (CWE-200)."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0004",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 122,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key2, vi, v copied unencrypted to REE-visible shared memory"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable key2 initialized with literal '123456'",
          "propagation_path": [
            "key2 <- '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:112",
            "params[2].memref.buffer <- key2 via snprintf @ /workspace/benchmark/bad-partitioning/ta/entry.c:117",
            "params[2].memref.buffer <- key2-vi via snprintf @ /workspace/benchmark/bad-partitioning/ta/entry.c:121",
            "params[2].memref.buffer <- key2-vi-v via snprintf @ /workspace/benchmark/bad-partitioning/ta/entry.c:122"
          ],
          "sink": "snprintf writes to REE-visible shared memory buffer params[2].memref.buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command from REE",
            "Attacker has access to shared memory buffer params[2].memref.buffer"
          ],
          "attack_scenario": "Attacker invokes the TA command from Normal World, causing the TA to copy sensitive key material into REE-visible shared memory. Attacker then reads the shared memory to obtain the plaintext key.",
          "impact": "Disclosure of cryptographic key material to untrusted Normal World, compromising confidentiality of protected data"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce_2:117",
          "recommendation": "Encrypt key2 before copying to REE-visible buffer or avoid exposing key material to REE"
        },
        {
          "type": "encryption",
          "location": "produce_2:121",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        },
        {
          "type": "encryption",
          "location": "produce_2:122",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        }
      ],
      "decision_rationales": [
        "Lines 117, 121, 122 copy TEE-private data named 'key2' (implying sensitive key material) directly to REE-visible shared memory without encryption. All three promotion conditions are met: dst_region is REE-visible, sensitivity_label is 'key' based on variable naming, and no sanitizer blocks the flow. This constitutes information disclosure (CWE-200)."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0005",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 136,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key1 copied unencrypted to REE-visible params[1].memref.buffer; variable name 'key1' indicates sensitive key material"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable key1 initialized with literal '123456'",
          "propagation_path": [
            "key1 (TEE-private) -> params[1].memref.buffer (REE-visible) @ /workspace/benchmark/bad-partitioning/ta/entry.c:136"
          ],
          "sink": "TEE_MemMove copies key1 to REE-visible shared memory buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls Normal World application",
            "TA_HELLO_WORLD_CMD_OUTPUT command is invoked",
            "params[1] is configured as MEMREF_INOUT"
          ],
          "attack_scenario": "Attacker invokes TA with CMD_OUTPUT command, providing a shared memory buffer in params[1]. The TA copies the sensitive key material directly into this REE-visible buffer, allowing the attacker to read the key from Normal World.",
          "impact": "Disclosure of cryptographic key material to untrusted Normal World, compromising confidentiality of any data protected by this key"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce:136",
          "recommendation": "Encrypt key1 before copying to REE-visible buffer, or do not expose key material to Normal World"
        },
        {
          "type": "access_control",
          "location": "produce:136",
          "recommendation": "Verify caller authorization before exposing sensitive key material"
        }
      ],
      "decision_rationales": [
        "Line 136 copies a TEE-private variable named 'key1' (indicating sensitive cryptographic material) directly to REE-visible shared memory via TEE_MemMove. All three promotion conditions are met: (a) dst_region is REE-visible (params[1].memref.buffer), (b) sensitivity_label is 'key' based on variable naming, (c) no sanitizer or encryption protects this flow. This constitutes unencrypted output of sensitive data to the Normal World."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0006",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 137,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key1 copied to REE-visible buffer without encryption"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variables key1, vi, v in produce()",
          "propagation_path": [
            "key1 = '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:132",
            "vi = 'abcd' @ /workspace/benchmark/bad-partitioning/ta/entry.c:133",
            "v = 100 @ /workspace/benchmark/bad-partitioning/ta/entry.c:134",
            "snprintf(params[2].memref.buffer, ..., key1) @ /workspace/benchmark/bad-partitioning/ta/entry.c:137",
            "snprintf(params[2].memref.buffer, ..., key1, vi) @ /workspace/benchmark/bad-partitioning/ta/entry.c:143",
            "snprintf(params[2].memref.buffer, ..., key1, vi, v) @ /workspace/benchmark/bad-partitioning/ta/entry.c:144",
            "snprintf(params[2].memref.buffer, ..., key1, vi) @ /workspace/benchmark/bad-partitioning/ta/entry.c:148"
          ],
          "sink": "params[2].memref.buffer (REE-visible shared memory)"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command from Normal World",
            "params[2] is configured as MEMREF_INOUT accessible to REE"
          ],
          "attack_scenario": "Attacker invokes the TA command and reads the shared memory buffer params[2].memref.buffer after the call returns, obtaining the plaintext key material",
          "impact": "Disclosure of TEE-private key material to untrusted Normal World, compromising confidentiality of secrets meant to stay within TEE"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce:137",
          "recommendation": "Encrypt key1 before copying to REE-visible buffer or avoid exposing key material to shared memory"
        },
        {
          "type": "encryption",
          "location": "produce:143",
          "recommendation": "Encrypt sensitive data before copying to REE-visible buffer"
        },
        {
          "type": "encryption",
          "location": "produce:144",
          "recommendation": "Encrypt sensitive data before copying to REE-visible buffer"
        },
        {
          "type": "encryption",
          "location": "produce:148",
          "recommendation": "Encrypt vi before concatenating with post-enc key1 and copying to REE"
        }
      ],
      "decision_rationales": [
        "TEE-private variables with names indicating sensitivity (key1, vi) are copied directly to REE-visible shared memory without encryption at lines 137, 143, 144, and 148. This constitutes information disclosure from the secure world to the normal world."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0007",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 143,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key1 and vi copied to REE-visible buffer without encryption"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variables key1, vi, v in produce()",
          "propagation_path": [
            "key1 = '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:132",
            "vi = 'abcd' @ /workspace/benchmark/bad-partitioning/ta/entry.c:133",
            "v = 100 @ /workspace/benchmark/bad-partitioning/ta/entry.c:134",
            "snprintf(params[2].memref.buffer, ..., key1) @ /workspace/benchmark/bad-partitioning/ta/entry.c:137",
            "snprintf(params[2].memref.buffer, ..., key1, vi) @ /workspace/benchmark/bad-partitioning/ta/entry.c:143",
            "snprintf(params[2].memref.buffer, ..., key1, vi, v) @ /workspace/benchmark/bad-partitioning/ta/entry.c:144",
            "snprintf(params[2].memref.buffer, ..., key1, vi) @ /workspace/benchmark/bad-partitioning/ta/entry.c:148"
          ],
          "sink": "params[2].memref.buffer (REE-visible shared memory)"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command from Normal World",
            "params[2] is configured as MEMREF_INOUT accessible to REE"
          ],
          "attack_scenario": "Attacker invokes the TA command and reads the shared memory buffer params[2].memref.buffer after the call returns, obtaining the plaintext key material",
          "impact": "Disclosure of TEE-private key material to untrusted Normal World, compromising confidentiality of secrets meant to stay within TEE"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce:137",
          "recommendation": "Encrypt key1 before copying to REE-visible buffer or avoid exposing key material to shared memory"
        },
        {
          "type": "encryption",
          "location": "produce:143",
          "recommendation": "Encrypt sensitive data before copying to REE-visible buffer"
        },
        {
          "type": "encryption",
          "location": "produce:144",
          "recommendation": "Encrypt sensitive data before copying to REE-visible buffer"
        },
        {
          "type": "encryption",
          "location": "produce:148",
          "recommendation": "Encrypt vi before concatenating with post-enc key1 and copying to REE"
        }
      ],
      "decision_rationales": [
        "TEE-private variables with names indicating sensitivity (key1, vi) are copied directly to REE-visible shared memory without encryption at lines 137, 143, 144, and 148. This constitutes information disclosure from the secure world to the normal world."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0008",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 144,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key1, vi, v copied to REE-visible buffer without encryption"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variables key1, vi, v in produce()",
          "propagation_path": [
            "key1 = '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:132",
            "vi = 'abcd' @ /workspace/benchmark/bad-partitioning/ta/entry.c:133",
            "v = 100 @ /workspace/benchmark/bad-partitioning/ta/entry.c:134",
            "snprintf(params[2].memref.buffer, ..., key1) @ /workspace/benchmark/bad-partitioning/ta/entry.c:137",
            "snprintf(params[2].memref.buffer, ..., key1, vi) @ /workspace/benchmark/bad-partitioning/ta/entry.c:143",
            "snprintf(params[2].memref.buffer, ..., key1, vi, v) @ /workspace/benchmark/bad-partitioning/ta/entry.c:144",
            "snprintf(params[2].memref.buffer, ..., key1, vi) @ /workspace/benchmark/bad-partitioning/ta/entry.c:148"
          ],
          "sink": "params[2].memref.buffer (REE-visible shared memory)"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command from Normal World",
            "params[2] is configured as MEMREF_INOUT accessible to REE"
          ],
          "attack_scenario": "Attacker invokes the TA command and reads the shared memory buffer params[2].memref.buffer after the call returns, obtaining the plaintext key material",
          "impact": "Disclosure of TEE-private key material to untrusted Normal World, compromising confidentiality of secrets meant to stay within TEE"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce:137",
          "recommendation": "Encrypt key1 before copying to REE-visible buffer or avoid exposing key material to shared memory"
        },
        {
          "type": "encryption",
          "location": "produce:143",
          "recommendation": "Encrypt sensitive data before copying to REE-visible buffer"
        },
        {
          "type": "encryption",
          "location": "produce:144",
          "recommendation": "Encrypt sensitive data before copying to REE-visible buffer"
        },
        {
          "type": "encryption",
          "location": "produce:148",
          "recommendation": "Encrypt vi before concatenating with post-enc key1 and copying to REE"
        }
      ],
      "decision_rationales": [
        "TEE-private variables with names indicating sensitivity (key1, vi) are copied directly to REE-visible shared memory without encryption at lines 137, 143, 144, and 148. This constitutes information disclosure from the secure world to the normal world."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0009",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 148,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "Unencrypted vi copied to REE-visible buffer alongside post-enc key1"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variables key1, vi, v in produce()",
          "propagation_path": [
            "key1 = '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:132",
            "vi = 'abcd' @ /workspace/benchmark/bad-partitioning/ta/entry.c:133",
            "v = 100 @ /workspace/benchmark/bad-partitioning/ta/entry.c:134",
            "snprintf(params[2].memref.buffer, ..., key1) @ /workspace/benchmark/bad-partitioning/ta/entry.c:137",
            "snprintf(params[2].memref.buffer, ..., key1, vi) @ /workspace/benchmark/bad-partitioning/ta/entry.c:143",
            "snprintf(params[2].memref.buffer, ..., key1, vi, v) @ /workspace/benchmark/bad-partitioning/ta/entry.c:144",
            "snprintf(params[2].memref.buffer, ..., key1, vi) @ /workspace/benchmark/bad-partitioning/ta/entry.c:148"
          ],
          "sink": "params[2].memref.buffer (REE-visible shared memory)"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command from Normal World",
            "params[2] is configured as MEMREF_INOUT accessible to REE"
          ],
          "attack_scenario": "Attacker invokes the TA command and reads the shared memory buffer params[2].memref.buffer after the call returns, obtaining the plaintext key material",
          "impact": "Disclosure of TEE-private key material to untrusted Normal World, compromising confidentiality of secrets meant to stay within TEE"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce:137",
          "recommendation": "Encrypt key1 before copying to REE-visible buffer or avoid exposing key material to shared memory"
        },
        {
          "type": "encryption",
          "location": "produce:143",
          "recommendation": "Encrypt sensitive data before copying to REE-visible buffer"
        },
        {
          "type": "encryption",
          "location": "produce:144",
          "recommendation": "Encrypt sensitive data before copying to REE-visible buffer"
        },
        {
          "type": "encryption",
          "location": "produce:148",
          "recommendation": "Encrypt vi before concatenating with post-enc key1 and copying to REE"
        }
      ],
      "decision_rationales": [
        "TEE-private variables with names indicating sensitivity (key1, vi) are copied directly to REE-visible shared memory without encryption at lines 137, 143, 144, and 148. This constitutes information disclosure from the secure world to the normal world."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0010",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 154,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-319",
      "functions": [
        "produce_3"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-319"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key copied to REE-visible shared buffer without encryption; 'key' name indicates sensitive credential"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce_3",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable key[1000] = \"123456\" at line 153",
          "propagation_path": [
            "key (TEE-private) -> buf (REE-visible alias) @ /workspace/benchmark/bad-partitioning/ta/entry.c:154",
            "buf bound to params[1].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:182",
            "params[1].memref.buffer is REE-visible shared memory"
          ],
          "sink": "TEE_MemMove(buf, key, strlen(key)) copies plaintext key to REE-visible buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command",
            "Attacker provides params[1].memref.buffer as shared memory"
          ],
          "attack_scenario": "Attacker invokes the TA with CMD_OUTPUT, receives the plaintext key '123456' in the shared memory buffer params[1].memref.buffer without any encryption or protection",
          "impact": "Disclosure of sensitive key material to untrusted Normal World; compromises confidentiality of TA secrets"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce_3:154",
          "recommendation": "Encrypt key material before copying to REE-visible shared memory"
        },
        {
          "type": "access_control",
          "location": "produce_3:154",
          "recommendation": "Verify caller authorization before exposing sensitive data to REE"
        }
      ],
      "decision_rationales": [
        "Line 154 copies a TEE-private variable named 'key' (sensitivity_label=key) directly to an REE-visible buffer (dst_region=REE-visible) via TEE_MemMove without any encryption. All three promotion conditions are met: (a) dst_region is REE-visible, (b) sensitivity_label is 'key', (c) no sanitizer present. This constitutes unencrypted output of sensitive data to the Normal World."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0011",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 155,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "produce_3"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "Plaintext key copied to REE-visible shared buffer via snprintf without encryption"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce_3",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable key[1000] = \"123456\" in produce_3",
          "propagation_path": [
            "params[1].memref.buffer (REE-visible) -> buf parameter @ /workspace/benchmark/bad-partitioning/ta/entry.c:151",
            "key (TEE-private) -> snprintf destination buf @ /workspace/benchmark/bad-partitioning/ta/entry.c:155"
          ],
          "sink": "snprintf(buf, size, \"%s\", key) writes plaintext key to REE-visible shared memory"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command from Normal World",
            "Attacker provides params[1] as MEMREF_INOUT with accessible buffer"
          ],
          "attack_scenario": "Attacker invokes the TA command and reads the shared memory buffer params[1].memref.buffer after the call returns, obtaining the plaintext key value",
          "impact": "Disclosure of sensitive key material from TEE to untrusted Normal World, compromising confidentiality of TEE-protected secrets"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "produce_3:155",
          "recommendation": "Encrypt key material before copying to REE-visible buffer, or avoid exposing key to shared memory entirely"
        },
        {
          "type": "access_control",
          "location": "produce_3:151",
          "recommendation": "Verify that sensitive data should be exposed to the caller before writing to shared buffer"
        }
      ],
      "decision_rationales": [
        "The snprintf at line 155 copies a TEE-private variable named 'key' (sensitivity_label=key) directly to an REE-visible buffer (buf is alias of params[1].memref.buffer). All three promotion conditions are met: (a) dst_region=REE-visible, (b) sensitivity_label=key, (c) no sanitizer/encryption. This constitutes unencrypted output of sensitive data to Normal World."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0012",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 175,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-200",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-200"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key copied to REE-visible params[1].memref.buffer without encryption"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable 'key' initialized with literal '123456'",
          "propagation_path": [
            "key (TEE-private) -> params[1].memref.buffer (REE-visible) @ /workspace/benchmark/bad-partitioning/ta/entry.c:175"
          ],
          "sink": "TEE_MemMove copies key to REE-visible shared memory buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command",
            "Attacker provides params[1] as MEMREF_INOUT with accessible buffer"
          ],
          "attack_scenario": "Attacker invokes the TA command and reads the shared memory buffer params[1].memref.buffer after the call returns, obtaining the plaintext key value",
          "impact": "Disclosure of sensitive key material to untrusted Normal World, compromising confidentiality of TA secrets"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "output:175",
          "recommendation": "Encrypt key material before copying to REE-visible memory, or avoid exposing keys to Normal World entirely"
        },
        {
          "type": "access_control",
          "location": "output:175",
          "recommendation": "Implement policy check to verify caller is authorized to receive key material"
        }
      ],
      "decision_rationales": [
        "The code copies a TEE-private variable named 'key' directly to REE-visible shared memory via TEE_MemMove. The variable name strongly indicates sensitive cryptographic material. The destination params[1].memref.buffer is shared with Normal World (REE-visible). No encryption or access control is applied. This satisfies all promotion criteria: dst_region=REE-visible, sensitivity_label=key, no effective sanitizer."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0013",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 176,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-319",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-319"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key copied to REE-visible buffer without encryption"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable 'key' initialized with literal '123456'",
          "propagation_path": [
            "key <- '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:171",
            "params[2].memref.buffer <- key @ /workspace/benchmark/bad-partitioning/ta/entry.c:176",
            "params[2].memref.buffer <- key-vi @ /workspace/benchmark/bad-partitioning/ta/entry.c:184",
            "params[2].memref.buffer <- key-vi-v @ /workspace/benchmark/bad-partitioning/ta/entry.c:185"
          ],
          "sink": "snprintf writes to REE-visible params[2].memref.buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command",
            "Attacker has access to shared memory buffer params[2].memref.buffer"
          ],
          "attack_scenario": "Attacker invokes the TA command and reads the shared memory buffer to obtain the plaintext key value that was intended to remain private within the TEE",
          "impact": "Disclosure of sensitive key material from TEE to REE, compromising confidentiality of TA-private secrets"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "output:176",
          "recommendation": "Encrypt key before copying to REE-visible buffer or use secure channel"
        },
        {
          "type": "encryption",
          "location": "output:184",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        },
        {
          "type": "encryption",
          "location": "output:185",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        }
      ],
      "decision_rationales": [
        "Lines 176, 184, 185 copy a variable named 'key' (sensitivity_label=key) directly from TEE-private memory to REE-visible shared memory buffer without any encryption. All three promotion conditions are met: dst_region=REE-visible, sensitivity_label=key, and no effective sanitizer. This constitutes unencrypted output of sensitive data."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0014",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 184,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-319",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-319"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key and vi copied to REE-visible buffer without encryption"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable 'key' initialized with literal '123456'",
          "propagation_path": [
            "key <- '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:171",
            "params[2].memref.buffer <- key @ /workspace/benchmark/bad-partitioning/ta/entry.c:176",
            "params[2].memref.buffer <- key-vi @ /workspace/benchmark/bad-partitioning/ta/entry.c:184",
            "params[2].memref.buffer <- key-vi-v @ /workspace/benchmark/bad-partitioning/ta/entry.c:185"
          ],
          "sink": "snprintf writes to REE-visible params[2].memref.buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command",
            "Attacker has access to shared memory buffer params[2].memref.buffer"
          ],
          "attack_scenario": "Attacker invokes the TA command and reads the shared memory buffer to obtain the plaintext key value that was intended to remain private within the TEE",
          "impact": "Disclosure of sensitive key material from TEE to REE, compromising confidentiality of TA-private secrets"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "output:176",
          "recommendation": "Encrypt key before copying to REE-visible buffer or use secure channel"
        },
        {
          "type": "encryption",
          "location": "output:184",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        },
        {
          "type": "encryption",
          "location": "output:185",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        }
      ],
      "decision_rationales": [
        "Lines 176, 184, 185 copy a variable named 'key' (sensitivity_label=key) directly from TEE-private memory to REE-visible shared memory buffer without any encryption. All three promotion conditions are met: dst_region=REE-visible, sensitivity_label=key, and no effective sanitizer. This constitutes unencrypted output of sensitive data."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0015",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 185,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-319",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-319"
      ],
      "rule_ids": [
        "unencrypted_output"
      ],
      "descriptions": [
        "TEE-private key, vi, v copied to REE-visible buffer without encryption"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "TEE-private local variable 'key' initialized with literal '123456'",
          "propagation_path": [
            "key <- '123456' @ /workspace/benchmark/bad-partitioning/ta/entry.c:171",
            "params[2].memref.buffer <- key @ /workspace/benchmark/bad-partitioning/ta/entry.c:176",
            "params[2].memref.buffer <- key-vi @ /workspace/benchmark/bad-partitioning/ta/entry.c:184",
            "params[2].memref.buffer <- key-vi-v @ /workspace/benchmark/bad-partitioning/ta/entry.c:185"
          ],
          "sink": "snprintf writes to REE-visible params[2].memref.buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker can invoke TA_HELLO_WORLD_CMD_OUTPUT command",
            "Attacker has access to shared memory buffer params[2].memref.buffer"
          ],
          "attack_scenario": "Attacker invokes the TA command and reads the shared memory buffer to obtain the plaintext key value that was intended to remain private within the TEE",
          "impact": "Disclosure of sensitive key material from TEE to REE, compromising confidentiality of TA-private secrets"
        }
      ],
      "missing_mitigations": [
        {
          "type": "encryption",
          "location": "output:176",
          "recommendation": "Encrypt key before copying to REE-visible buffer or use secure channel"
        },
        {
          "type": "encryption",
          "location": "output:184",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        },
        {
          "type": "encryption",
          "location": "output:185",
          "recommendation": "Encrypt sensitive data before copying to shared memory"
        }
      ],
      "decision_rationales": [
        "Lines 176, 184, 185 copy a variable named 'key' (sensitivity_label=key) directly from TEE-private memory to REE-visible shared memory buffer without any encryption. All three promotion conditions are met: dst_region=REE-visible, sensitivity_label=key, and no effective sanitizer. This constitutes unencrypted output of sensitive data."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "unencrypted_output": 1
      }
    },
    {
      "vulnerability_id": "VULN-0016",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 208,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "REE-tainted params[3].memref.size used as copy length into 1000-byte heap buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "produce_i2",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param params[2].memref.size and params[3].memref.size",
          "propagation_path": [
            "params <- REE @ entry.c:502",
            "params -> produce_i0(params) @ entry.c:311",
            "params -> produce_i2(params) @ entry.c:229",
            "params[3].memref.size -> TEE_MemMove size arg @ entry.c:208",
            "params[2].memref.size -> TEE_MemMove size arg @ entry.c:212"
          ],
          "sink": "TEE_MemMove(str, params[X].memref.buffer, params[X].memref.size) where str is 1000-byte heap buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[2].memref.size or params[3].memref.size from REE",
            "TA_HELLO_WORLD_CMD_INPUT command is invoked",
            "param_types validation passes (TEE_PARAM_TYPE_MEMREF_INOUT for params[2] and params[3])"
          ],
          "attack_scenario": "Attacker invokes TA with cmd_id=TA_HELLO_WORLD_CMD_INPUT, setting params[3].memref.size > 1000 or params[2].memref.size > 1000. The TEE_MemMove at line 208 or 212 copies attacker-controlled bytes beyond the 1000-byte heap allocation, corrupting adjacent heap metadata or TA data structures.",
          "impact": "Heap buffer overflow in TEE secure world can lead to arbitrary code execution within the trusted application, compromising confidentiality and integrity of secure assets, potential privilege escalation."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i2:208",
          "recommendation": "Add check: if (params[3].memref.size > 1000) return TEE_ERROR_BAD_PARAMETERS; before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "produce_i2:212",
          "recommendation": "Add check: if (params[2].memref.size > 1000) return TEE_ERROR_BAD_PARAMETERS; before TEE_MemMove"
        }
      ],
      "decision_rationales": [
        "Both TEE_MemMove calls at lines 208 and 212 use REE-tainted size values (params[3].memref.size and params[2].memref.size respectively) to copy data into a fixed 1000-byte heap buffer allocated via TEE_Malloc. There are no bounds checks on these size values within produce_i2 or its callers before these specific lines. An attacker can supply size values exceeding 1000, causing heap buffer overflow (CWE-122)."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0017",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 212,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as copy length into 1000-byte heap buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "produce_i2",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param params[2].memref.size and params[3].memref.size",
          "propagation_path": [
            "params <- REE @ entry.c:502",
            "params -> produce_i0(params) @ entry.c:311",
            "params -> produce_i2(params) @ entry.c:229",
            "params[3].memref.size -> TEE_MemMove size arg @ entry.c:208",
            "params[2].memref.size -> TEE_MemMove size arg @ entry.c:212"
          ],
          "sink": "TEE_MemMove(str, params[X].memref.buffer, params[X].memref.size) where str is 1000-byte heap buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[2].memref.size or params[3].memref.size from REE",
            "TA_HELLO_WORLD_CMD_INPUT command is invoked",
            "param_types validation passes (TEE_PARAM_TYPE_MEMREF_INOUT for params[2] and params[3])"
          ],
          "attack_scenario": "Attacker invokes TA with cmd_id=TA_HELLO_WORLD_CMD_INPUT, setting params[3].memref.size > 1000 or params[2].memref.size > 1000. The TEE_MemMove at line 208 or 212 copies attacker-controlled bytes beyond the 1000-byte heap allocation, corrupting adjacent heap metadata or TA data structures.",
          "impact": "Heap buffer overflow in TEE secure world can lead to arbitrary code execution within the trusted application, compromising confidentiality and integrity of secure assets, potential privilege escalation."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i2:208",
          "recommendation": "Add check: if (params[3].memref.size > 1000) return TEE_ERROR_BAD_PARAMETERS; before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "produce_i2:212",
          "recommendation": "Add check: if (params[2].memref.size > 1000) return TEE_ERROR_BAD_PARAMETERS; before TEE_MemMove"
        }
      ],
      "decision_rationales": [
        "Both TEE_MemMove calls at lines 208 and 212 use REE-tainted size values (params[3].memref.size and params[2].memref.size respectively) to copy data into a fixed 1000-byte heap buffer allocated via TEE_Malloc. There are no bounds checks on these size values within produce_i2 or its callers before these specific lines. An attacker can supply size values exceeding 1000, causing heap buffer overflow (CWE-122)."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0018",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 227,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "REE-tainted size3 used as copy length into fixed 1000-byte buffer without bounds check"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param values (params[0].value.a, params[2].memref.size, params[3].memref.size, params[2].memref.buffer, params[3].memref.buffer)",
          "propagation_path": [
            "params -> input() @ /workspace/benchmark/bad-partitioning/ta/entry.c:311",
            "a <- params[0].value.a @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "size2 <- params[2].memref.size @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "size3 <- params[3].memref.size @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "buf2 <- params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "buf3 <- params[3].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "TEE_MemMove(str, buf3, size3) @ /workspace/benchmark/bad-partitioning/ta/entry.c:227",
            "TEE_MemMove(str, buf2, size2) @ /workspace/benchmark/bad-partitioning/ta/entry.c:238",
            "TEE_MemMove(buf2, str, 1000) @ /workspace/benchmark/bad-partitioning/ta/entry.c:246"
          ],
          "sink": "TEE_MemMove with tainted size or fixed size exceeding destination capacity"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE and can invoke TA_HELLO_WORLD_CMD_INPUT command",
            "Attacker can set params[2].memref.size and params[3].memref.size to values > 1000",
            "Attacker can set params[2].memref.buffer to a shared memory region smaller than 1000 bytes"
          ],
          "attack_scenario": "Attacker invokes the TA with size3 or size2 > 1000 to overflow the TEE-private str buffer (lines 227, 238), or provides a params[2].memref.buffer smaller than 1000 bytes to trigger shared memory overflow (line 246)",
          "impact": "Heap buffer overflow in TEE-private memory can corrupt TA state, enable code execution in secure world; shared memory overflow can corrupt REE memory or leak TEE data"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i0:227",
          "recommendation": "Add check: if (size3 > 1000) return TEE_ERROR_BAD_PARAMETERS; before line 227"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:238",
          "recommendation": "Add check: if (size2 > 1000) return TEE_ERROR_BAD_PARAMETERS; before line 238"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:246",
          "recommendation": "Add check: if (size2 < 1000) return TEE_ERROR_BAD_PARAMETERS; should be if (size2 < 1000) to ensure destination can hold 1000 bytes, or use min(1000, size2) as copy length"
        }
      ],
      "decision_rationales": [
        "Lines 227, 238, and 246 have direct taint flow from REE-controlled size parameters to TEE_MemMove without adequate bounds validation. Line 227 and 238 can overflow the TEE-private heap buffer str. Line 246 writes a fixed 1000 bytes to REE-visible buf2 without verifying destination capacity, and the check at line 241 is inverted (rejects size2 < 1000 instead of size2 >= 1000)."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0019",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 238,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "REE-tainted size2 used as copy length into fixed 1000-byte buffer; size3 check does not guard size2"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param values (params[0].value.a, params[2].memref.size, params[3].memref.size, params[2].memref.buffer, params[3].memref.buffer)",
          "propagation_path": [
            "params -> input() @ /workspace/benchmark/bad-partitioning/ta/entry.c:311",
            "a <- params[0].value.a @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "size2 <- params[2].memref.size @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "size3 <- params[3].memref.size @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "buf2 <- params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "buf3 <- params[3].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "TEE_MemMove(str, buf3, size3) @ /workspace/benchmark/bad-partitioning/ta/entry.c:227",
            "TEE_MemMove(str, buf2, size2) @ /workspace/benchmark/bad-partitioning/ta/entry.c:238",
            "TEE_MemMove(buf2, str, 1000) @ /workspace/benchmark/bad-partitioning/ta/entry.c:246"
          ],
          "sink": "TEE_MemMove with tainted size or fixed size exceeding destination capacity"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE and can invoke TA_HELLO_WORLD_CMD_INPUT command",
            "Attacker can set params[2].memref.size and params[3].memref.size to values > 1000",
            "Attacker can set params[2].memref.buffer to a shared memory region smaller than 1000 bytes"
          ],
          "attack_scenario": "Attacker invokes the TA with size3 or size2 > 1000 to overflow the TEE-private str buffer (lines 227, 238), or provides a params[2].memref.buffer smaller than 1000 bytes to trigger shared memory overflow (line 246)",
          "impact": "Heap buffer overflow in TEE-private memory can corrupt TA state, enable code execution in secure world; shared memory overflow can corrupt REE memory or leak TEE data"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i0:227",
          "recommendation": "Add check: if (size3 > 1000) return TEE_ERROR_BAD_PARAMETERS; before line 227"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:238",
          "recommendation": "Add check: if (size2 > 1000) return TEE_ERROR_BAD_PARAMETERS; before line 238"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:246",
          "recommendation": "Add check: if (size2 < 1000) return TEE_ERROR_BAD_PARAMETERS; should be if (size2 < 1000) to ensure destination can hold 1000 bytes, or use min(1000, size2) as copy length"
        }
      ],
      "decision_rationales": [
        "Lines 227, 238, and 246 have direct taint flow from REE-controlled size parameters to TEE_MemMove without adequate bounds validation. Line 227 and 238 can overflow the TEE-private heap buffer str. Line 246 writes a fixed 1000 bytes to REE-visible buf2 without verifying destination capacity, and the check at line 241 is inverted (rejects size2 < 1000 instead of size2 >= 1000)."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0020",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 246,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "Fixed 1000-byte copy into REE-visible buf2 without checking destination capacity; inverted bounds check"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param values (params[0].value.a, params[2].memref.size, params[3].memref.size, params[2].memref.buffer, params[3].memref.buffer)",
          "propagation_path": [
            "params -> input() @ /workspace/benchmark/bad-partitioning/ta/entry.c:311",
            "a <- params[0].value.a @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "size2 <- params[2].memref.size @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "size3 <- params[3].memref.size @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "buf2 <- params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "buf3 <- params[3].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:215",
            "TEE_MemMove(str, buf3, size3) @ /workspace/benchmark/bad-partitioning/ta/entry.c:227",
            "TEE_MemMove(str, buf2, size2) @ /workspace/benchmark/bad-partitioning/ta/entry.c:238",
            "TEE_MemMove(buf2, str, 1000) @ /workspace/benchmark/bad-partitioning/ta/entry.c:246"
          ],
          "sink": "TEE_MemMove with tainted size or fixed size exceeding destination capacity"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE and can invoke TA_HELLO_WORLD_CMD_INPUT command",
            "Attacker can set params[2].memref.size and params[3].memref.size to values > 1000",
            "Attacker can set params[2].memref.buffer to a shared memory region smaller than 1000 bytes"
          ],
          "attack_scenario": "Attacker invokes the TA with size3 or size2 > 1000 to overflow the TEE-private str buffer (lines 227, 238), or provides a params[2].memref.buffer smaller than 1000 bytes to trigger shared memory overflow (line 246)",
          "impact": "Heap buffer overflow in TEE-private memory can corrupt TA state, enable code execution in secure world; shared memory overflow can corrupt REE memory or leak TEE data"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i0:227",
          "recommendation": "Add check: if (size3 > 1000) return TEE_ERROR_BAD_PARAMETERS; before line 227"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:238",
          "recommendation": "Add check: if (size2 > 1000) return TEE_ERROR_BAD_PARAMETERS; before line 238"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:246",
          "recommendation": "Add check: if (size2 < 1000) return TEE_ERROR_BAD_PARAMETERS; should be if (size2 < 1000) to ensure destination can hold 1000 bytes, or use min(1000, size2) as copy length"
        }
      ],
      "decision_rationales": [
        "Lines 227, 238, and 246 have direct taint flow from REE-controlled size parameters to TEE_MemMove without adequate bounds validation. Line 227 and 238 can overflow the TEE-private heap buffer str. Line 246 writes a fixed 1000 bytes to REE-visible buf2 without verifying destination capacity, and the check at line 241 is inverted (rejects size2 < 1000 instead of size2 >= 1000)."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0021",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 290,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "REE-tainted params[3].memref.size used as copy length into fixed 1000-byte buffer without bounds check"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param params[2].memref.size, params[3].memref.size, params[2].memref.buffer",
          "propagation_path": [
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:290",
            "params[2].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:306",
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:307",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:291",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:309"
          ],
          "sink": "TEE_MemMove with unchecked REE-tainted length or fixed-size copy to REE buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[2].memref.size or params[3].memref.size from REE",
            "Attacker can set memref.size > 1000 for heap overflow",
            "Attacker can set params[2].memref.size < 1000 for shared memory overwrite"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_INPUT with params[3].memref.size > 1000 to overflow the 1000-byte str buffer allocated via TEE_Malloc, corrupting heap metadata or adjacent data. Alternatively, attacker sets params[2].memref.size < 1000 and the fixed 1000-byte copy overwrites beyond the shared buffer boundary.",
          "impact": "Heap buffer overflow in TEE-private memory (lines 290,306,307) can lead to arbitrary code execution in secure world. Shared memory overwrite (lines 291,309) can corrupt REE memory beyond allocated bounds."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        },
        {
          "type": "bounds_check",
          "location": "input:306",
          "recommendation": "Validate params[2].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:307",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        }
      ],
      "decision_rationales": [
        "Lines 290, 306, 307 use REE-controlled memref.size as copy length into a fixed 1000-byte heap buffer without any bounds validation, creating heap buffer overflow (CWE-122). Lines 291, 309 copy a fixed 1000 bytes into REE-visible shared memory without verifying the destination can hold 1000 bytes, creating shared memory overwrite. The param_types check at line 277 only validates parameter types, not sizes."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0022",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 291,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "Fixed 1000-byte copy into REE-visible buffer without checking destination size"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param params[2].memref.size, params[3].memref.size, params[2].memref.buffer",
          "propagation_path": [
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:290",
            "params[2].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:306",
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:307",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:291",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:309"
          ],
          "sink": "TEE_MemMove with unchecked REE-tainted length or fixed-size copy to REE buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[2].memref.size or params[3].memref.size from REE",
            "Attacker can set memref.size > 1000 for heap overflow",
            "Attacker can set params[2].memref.size < 1000 for shared memory overwrite"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_INPUT with params[3].memref.size > 1000 to overflow the 1000-byte str buffer allocated via TEE_Malloc, corrupting heap metadata or adjacent data. Alternatively, attacker sets params[2].memref.size < 1000 and the fixed 1000-byte copy overwrites beyond the shared buffer boundary.",
          "impact": "Heap buffer overflow in TEE-private memory (lines 290,306,307) can lead to arbitrary code execution in secure world. Shared memory overwrite (lines 291,309) can corrupt REE memory beyond allocated bounds."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        },
        {
          "type": "bounds_check",
          "location": "input:306",
          "recommendation": "Validate params[2].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:307",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        }
      ],
      "decision_rationales": [
        "Lines 290, 306, 307 use REE-controlled memref.size as copy length into a fixed 1000-byte heap buffer without any bounds validation, creating heap buffer overflow (CWE-122). Lines 291, 309 copy a fixed 1000 bytes into REE-visible shared memory without verifying the destination can hold 1000 bytes, creating shared memory overwrite. The param_types check at line 277 only validates parameter types, not sizes."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0023",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 306,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as copy length into fixed 1000-byte buffer without bounds check"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param params[2].memref.size, params[3].memref.size, params[2].memref.buffer",
          "propagation_path": [
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:290",
            "params[2].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:306",
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:307",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:291",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:309"
          ],
          "sink": "TEE_MemMove with unchecked REE-tainted length or fixed-size copy to REE buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[2].memref.size or params[3].memref.size from REE",
            "Attacker can set memref.size > 1000 for heap overflow",
            "Attacker can set params[2].memref.size < 1000 for shared memory overwrite"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_INPUT with params[3].memref.size > 1000 to overflow the 1000-byte str buffer allocated via TEE_Malloc, corrupting heap metadata or adjacent data. Alternatively, attacker sets params[2].memref.size < 1000 and the fixed 1000-byte copy overwrites beyond the shared buffer boundary.",
          "impact": "Heap buffer overflow in TEE-private memory (lines 290,306,307) can lead to arbitrary code execution in secure world. Shared memory overwrite (lines 291,309) can corrupt REE memory beyond allocated bounds."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        },
        {
          "type": "bounds_check",
          "location": "input:306",
          "recommendation": "Validate params[2].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:307",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        }
      ],
      "decision_rationales": [
        "Lines 290, 306, 307 use REE-controlled memref.size as copy length into a fixed 1000-byte heap buffer without any bounds validation, creating heap buffer overflow (CWE-122). Lines 291, 309 copy a fixed 1000 bytes into REE-visible shared memory without verifying the destination can hold 1000 bytes, creating shared memory overwrite. The param_types check at line 277 only validates parameter types, not sizes."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0024",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 307,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "REE-tainted params[3].memref.size used as copy length into fixed 1000-byte buffer without bounds check"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param params[2].memref.size, params[3].memref.size, params[2].memref.buffer",
          "propagation_path": [
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:290",
            "params[2].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:306",
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:307",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:291",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:309"
          ],
          "sink": "TEE_MemMove with unchecked REE-tainted length or fixed-size copy to REE buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[2].memref.size or params[3].memref.size from REE",
            "Attacker can set memref.size > 1000 for heap overflow",
            "Attacker can set params[2].memref.size < 1000 for shared memory overwrite"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_INPUT with params[3].memref.size > 1000 to overflow the 1000-byte str buffer allocated via TEE_Malloc, corrupting heap metadata or adjacent data. Alternatively, attacker sets params[2].memref.size < 1000 and the fixed 1000-byte copy overwrites beyond the shared buffer boundary.",
          "impact": "Heap buffer overflow in TEE-private memory (lines 290,306,307) can lead to arbitrary code execution in secure world. Shared memory overwrite (lines 291,309) can corrupt REE memory beyond allocated bounds."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        },
        {
          "type": "bounds_check",
          "location": "input:306",
          "recommendation": "Validate params[2].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:307",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        }
      ],
      "decision_rationales": [
        "Lines 290, 306, 307 use REE-controlled memref.size as copy length into a fixed 1000-byte heap buffer without any bounds validation, creating heap buffer overflow (CWE-122). Lines 291, 309 copy a fixed 1000 bytes into REE-visible shared memory without verifying the destination can hold 1000 bytes, creating shared memory overwrite. The param_types check at line 277 only validates parameter types, not sizes."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0025",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 309,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-122",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-122"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "Fixed 1000-byte copy into REE-visible buffer without checking destination size"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-provided TEE_Param params[2].memref.size, params[3].memref.size, params[2].memref.buffer",
          "propagation_path": [
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:290",
            "params[2].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:306",
            "params[3].memref.size -> TEE_MemMove length @ /workspace/benchmark/bad-partitioning/ta/entry.c:307",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:291",
            "str -> params[2].memref.buffer @ /workspace/benchmark/bad-partitioning/ta/entry.c:309"
          ],
          "sink": "TEE_MemMove with unchecked REE-tainted length or fixed-size copy to REE buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[2].memref.size or params[3].memref.size from REE",
            "Attacker can set memref.size > 1000 for heap overflow",
            "Attacker can set params[2].memref.size < 1000 for shared memory overwrite"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_INPUT with params[3].memref.size > 1000 to overflow the 1000-byte str buffer allocated via TEE_Malloc, corrupting heap metadata or adjacent data. Alternatively, attacker sets params[2].memref.size < 1000 and the fixed 1000-byte copy overwrites beyond the shared buffer boundary.",
          "impact": "Heap buffer overflow in TEE-private memory (lines 290,306,307) can lead to arbitrary code execution in secure world. Shared memory overwrite (lines 291,309) can corrupt REE memory beyond allocated bounds."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        },
        {
          "type": "bounds_check",
          "location": "input:306",
          "recommendation": "Validate params[2].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:307",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove"
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Validate params[2].memref.size >= 1000 before copying 1000 bytes to shared buffer"
        }
      ],
      "decision_rationales": [
        "Lines 290, 306, 307 use REE-controlled memref.size as copy length into a fixed 1000-byte heap buffer without any bounds validation, creating heap buffer overflow (CWE-122). Lines 291, 309 copy a fixed 1000 bytes into REE-visible shared memory without verifying the destination can hold 1000 bytes, creating shared memory overwrite. The param_types check at line 277 only validates parameter types, not sizes."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0026",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 401,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "TOCTOU: sz checked but params[0].memref.size used in TEE_MemMove; attacker can modify shared memory size after check"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "shared_memory",
          "produce_s3",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "params[0].memref.buffer and params[0].memref.size from REE-provided TEE_Param",
          "propagation_path": [
            "params <- REE @ entry.c:355",
            "buf <- params[0].memref.buffer @ entry.c:357",
            "sz <- params[0].memref.size @ entry.c:358",
            "str <- params[0].memref.buffer via TEE_MemMove @ entry.c:401"
          ],
          "sink": "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size) at line 401"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE and can invoke TA with crafted params",
            "Shared memory buffer is REE-visible and can be modified concurrently"
          ],
          "attack_scenario": "Attacker passes sz <= 1000 to pass bounds check at line 397, then modifies params[0].memref.size in shared memory to a larger value before TEE_MemMove executes, causing stack buffer overflow in str[1000]",
          "impact": "Stack buffer overflow leading to potential code execution or TA crash"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_s3:401",
          "recommendation": "Use the locally cached sz variable instead of params[0].memref.size in TEE_MemMove call to prevent TOCTOU"
        },
        {
          "type": "mem_access_check",
          "location": "produce_s3:401",
          "recommendation": "Copy params[0].memref.size to a local variable before bounds check and use that local variable consistently"
        }
      ],
      "decision_rationales": [
        "The bounds check at line 397 validates sz (a local copy), but the TEE_MemMove at line 401 uses params[0].memref.size directly from shared memory. Since shared memory is REE-visible, an attacker can modify params[0].memref.size after the check passes, causing a buffer overflow into the 1000-byte stack buffer str."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0027",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 485,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-367",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-367"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "TOCTOU: bounds check on sz but TEE_MemMove uses params[0].memref.size which can be modified by REE after check"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "shared_memory",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "params[0].memref.buffer and params[0].memref.size from REE-controlled shared memory",
          "propagation_path": [
            "params[0].memref.size -> sz @ /workspace/benchmark/bad-partitioning/ta/entry.c:423",
            "sz checked against 1000 @ /workspace/benchmark/bad-partitioning/ta/entry.c:481",
            "params[0].memref.size (re-read from shared memory) -> TEE_MemMove size @ /workspace/benchmark/bad-partitioning/ta/entry.c:485"
          ],
          "sink": "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size) at line 485"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "REE attacker can modify shared memory concurrently",
            "TA reads params[0].memref.size twice: once for check, once for copy"
          ],
          "attack_scenario": "Attacker passes size <= 1000 initially to pass bounds check at line 481, then modifies params[0].memref.size in shared memory to a value > 1000 before TEE_MemMove executes at line 485, causing stack buffer overflow in str[1000]",
          "impact": "Stack buffer overflow allowing potential code execution in TEE, compromise of trusted application integrity"
        }
      ],
      "missing_mitigations": [
        {
          "type": "mem_access_check",
          "location": "shared_memory:485",
          "recommendation": "Use the locally cached sz variable instead of re-reading params[0].memref.size from shared memory: TEE_MemMove(str, params[0].memref.buffer, sz)"
        },
        {
          "type": "bounds_check",
          "location": "shared_memory:485",
          "recommendation": "Copy shared memory values to local variables once and use only local copies for all subsequent operations"
        }
      ],
      "decision_rationales": [
        "The bounds check at line 481 validates sz (local copy), but line 485 re-reads params[0].memref.size from shared memory. Since shared memory is REE-controlled, an attacker can modify the size between the check and use, bypassing the bounds validation and causing a stack buffer overflow in the 1000-byte str array."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    }
  ],
  "total_finding_lines": 70,
  "structural_risks": [
    {
      "finding_id": "RISK-0001",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 116,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "unencrypted_output",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "unencrypted_output"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key2 literal copied to REE-visible params[1].memref.buffer; variable named 'key2' implies sensitive",
        "TEE-private key2 copied to REE-visible params[1].memref.buffer; variable named 'key2' implies sensitive"
      ],
      "code_excerpts": [
        "TEE_MemMove(params[1].memref.buffer, key2, strlen(key2));"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key2),src_sz=1000,dst_sz=params[1].memref.size"
        ]
      },
      "rule_distribution": {
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0002",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 117,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "unencrypted_output",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "unencrypted_output"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key2 copied to REE-visible params[2].memref.buffer via snprintf; 'key2' name implies sensitive",
        "snprintf writes TEE-private key2 to REE-visible params[2].memref.buffer; 'key2' name implies sensitive"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key2);"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key2),src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0003",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 121,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "unencrypted_output",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "unencrypted_output"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key2 and vi copied to REE-visible buffer; 'key2' name implies sensitive",
        "snprintf writes TEE-private key2 and vi to REE-visible buffer; 'key2' name implies sensitive"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key2, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key2)+strlen(vi)+1,src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0004",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 122,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "unencrypted_output",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "unencrypted_output"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key2, vi, v copied to REE-visible buffer; 'key2' name implies sensitive",
        "snprintf writes TEE-private key2, vi, v to REE-visible buffer; 'key2' name implies sensitive"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s-%d\", key2, vi, v);"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key2)+strlen(vi)+digits(v)+2,src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0005",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 125,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "key2 passed to enc() then copied to REE; if enc() encrypts in-place, output may be ciphertext (uncertain)",
        "snprintf writes post-enc key2 to REE-visible buffer; encryption status uncertain"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key2);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=strlen(key2),src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0006",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 126,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "post-enc key2 and vi copied to REE; vi not encrypted, key2 encryption status uncertain",
        "snprintf writes post-enc key2 and unencrypted vi to REE-visible buffer; mixed encryption status"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key2, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=strlen(key2)+strlen(vi)+1,src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0007",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 136,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "unencrypted_output",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "unencrypted_output"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key1 literal copied to REE-visible params[1].memref.buffer; variable named 'key1' implies sensitive",
        "TEE-private key1 copied to REE-visible params[1].memref.buffer; variable named 'key1' implies sensitive"
      ],
      "code_excerpts": [
        "TEE_MemMove(params[1].memref.buffer, key1, strlen(key1));"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key1),src_sz=1000,dst_sz=params[1].memref.size"
        ]
      },
      "rule_distribution": {
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0008",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 137,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "unencrypted_output",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "unencrypted_output"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key1 copied to REE-visible params[2].memref.buffer via snprintf; 'key1' name implies sensitive",
        "snprintf writes TEE-private key1 to REE-visible params[2].memref.buffer; 'key1' name implies sensitive",
        "TEE-private key1 written to REE-visible params[2].memref.buffer; 'key1' name implies sensitive"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key1);"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key1),src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0009",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 143,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "unencrypted_output",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "unencrypted_output"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key1 and vi copied to REE-visible buffer; 'key1' name implies sensitive",
        "snprintf writes TEE-private key1 and vi to REE-visible buffer; 'key1' name implies sensitive",
        "TEE-private key1 and vi written to REE-visible buffer; 'key1' name implies sensitive"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key1, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key1)+strlen(vi)+1,src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0010",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 144,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "unencrypted_output",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "unencrypted_output"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key1, vi, v copied to REE-visible buffer; 'key1' name implies sensitive",
        "snprintf writes TEE-private key1, vi, v to REE-visible buffer; 'key1' name implies sensitive",
        "TEE-private key1, vi, v written to REE-visible buffer; 'key1' name implies sensitive"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s-%d\", key1, vi, v);"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key1)+strlen(vi)+digits(v)+2,src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0011",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 147,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "key1 passed to enc() then copied to REE; if enc() encrypts in-place, output may be ciphertext (uncertain)",
        "snprintf writes post-enc key1 to REE-visible buffer; encryption status uncertain",
        "key1 passed to enc() then written to REE; encryption status uncertain"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key1);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=strlen(key1),src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0012",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 148,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "post-enc key1 and vi copied to REE; vi not encrypted, key1 encryption status uncertain",
        "snprintf writes post-enc key1 and unencrypted vi to REE-visible buffer; mixed encryption status",
        "post-enc key1 and unencrypted vi written to REE; mixed encryption status"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key1, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=strlen(key1)+strlen(vi)+1,src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0013",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 154,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "unencrypted_output",
      "functions": [
        "produce_3"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "unencrypted_output",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key copied to buf which is alias of REE-visible memref.buffer; 'key' implies sensitive",
        "TEE-private key copied to buf which is alias of REE-visible memref.buffer; 'key' name implies sensitive",
        "TEE-private key literal copied to REE-visible buf; variable named 'key' implies sensitive data",
        "TEE-private key copied to REE-visible buf (alias of params[1].memref.buffer); 'key' name implies sensitive",
        "TEE_MemMove also copies plaintext key to same REE-visible buffer before snprintf"
      ],
      "code_excerpts": [
        "TEE_MemMove(buf, key, strlen(key));"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=size",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=params[1].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0014",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 155,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "produce_3"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "rules": [
        "other",
        "unencrypted_output"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "snprintf writes TEE-private key to buf; buf origin unknown from this context",
        "TEE-private key written to buf which is REE-visible alias; 'key' name implies sensitive",
        "TEE-private key copied to REE-visible buf via snprintf; 'key' name implies sensitive",
        "snprintf writes TEE-private key to buf which is alias of REE-visible params[1].memref.buffer; 'key' name implies sensitive"
      ],
      "code_excerpts": [
        "snprintf(buf, size, \"%s\", key);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=size",
          "dst_region:REE-visible"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0015",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 159,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "params array from REE bound to callee parameter; memref.buffer fields are REE-visible aliases"
      ],
      "code_excerpts": [
        "TEE_Param params[4]"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0016",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 175,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "unencrypted_output",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "unencrypted_output",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key literal copied to REE-visible params[1].memref.buffer without encryption; variable named 'key' implies sensitive",
        "TEE-private key copied to REE-visible params[1].memref.buffer; variable named 'key' implies sensitive",
        "TEE-private key copied to REE-visible params[1].memref.buffer; 'key' name implies sensitive",
        "TEE-private key copied directly to REE-visible params[1].memref.buffer; 'key' name implies sensitive",
        "TEE-private key copied to REE-visible params[1].memref.buffer; variable named 'key' implies sensitive data",
        "TEE_MemMove copies key to params[1].memref.buffer (REE-visible) without encryption; not in target sink lines but same vulnerability pattern"
      ],
      "code_excerpts": [
        "TEE_MemMove(params[1].memref.buffer, key, strlen(key));"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=params[1].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0017",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 176,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "unencrypted_output",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "unencrypted_output",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key copied to REE-visible params[2].memref.buffer via snprintf; 'key' name implies sensitive",
        "snprintf writes TEE-private key to REE-visible params[2].memref.buffer; 'key' name implies sensitive",
        "TEE-private key written to REE-visible params[2].memref.buffer; 'key' name implies sensitive",
        "TEE-private key written to REE-visible params[2].memref.buffer; variable named 'key' implies sensitive data",
        "params[2].memref.buffer is REE-visible shared memory alias passed as destination"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key);",
        "params[2].memref.buffer"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output",
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0018",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 184,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "unencrypted_output",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "unencrypted_output",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key and vi copied to REE-visible buffer; 'key' name implies sensitive",
        "snprintf writes TEE-private key and vi to REE-visible buffer; 'key' name implies sensitive",
        "TEE-private key and vi written to REE-visible buffer; 'key' name implies sensitive",
        "params[2].memref.buffer is REE-visible shared memory alias passed as destination"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key, vi);",
        "params[2].memref.buffer"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output",
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key)+strlen(vi)+1,src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0019",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 185,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "unencrypted_output",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "unencrypted_output",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE-private key, vi, v copied to REE-visible buffer; 'key' name implies sensitive",
        "snprintf writes TEE-private key, vi, v to REE-visible buffer; 'key' name implies sensitive",
        "TEE-private key, vi, v written to REE-visible buffer; 'key' name implies sensitive",
        "params[2].memref.buffer is REE-visible shared memory alias passed as destination"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s-%d\", key, vi, v);",
        "params[2].memref.buffer"
      ],
      "rule_matches": {
        "rule_id": [
          "unencrypted_output",
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:key",
          "size_triplet:copy_len=strlen(key)+strlen(vi)+digits(v)+2,src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "unencrypted_output": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0020",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 189,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "key passed to enc() then copied to REE; if enc() encrypts in-place, output may be ciphertext (uncertain)",
        "snprintf writes post-enc key to REE-visible buffer; encryption status uncertain",
        "key passed to enc() then written to REE; encryption status uncertain",
        "snprintf writes key after enc() call to REE-visible buffer; encryption status uncertain, may be ciphertext",
        "key passed to enc() then copied to REE; encryption status uncertain, may still be plaintext if enc() failed or is no-op",
        "params[2].memref.buffer is REE-visible shared memory alias passed as destination"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key);",
        "params[2].memref.buffer"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0021",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 190,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "post-enc key and vi copied to REE; vi not encrypted, key encryption status uncertain",
        "snprintf writes post-enc key and unencrypted vi to REE-visible buffer; mixed encryption status",
        "post-enc key and unencrypted vi written to REE; mixed encryption status",
        "post-enc key and unencrypted vi copied to REE; vi is plaintext, key encryption status uncertain",
        "params[2].memref.buffer is REE-visible shared memory alias passed as destination"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key, vi);",
        "params[2].memref.buffer"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=strlen(key)+strlen(vi)+1,src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0022",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 191,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "post-enc key, vi, v copied to REE; vi not encrypted, encryption status of key uncertain",
        "snprintf writes post-enc key, unencrypted vi and v to REE-visible buffer; mixed encryption status",
        "post-enc key, unencrypted vi and v written to REE; mixed encryption status",
        "post-enc key, unencrypted vi and v copied to REE; mixed encryption status",
        "params[2].memref.buffer is REE-visible shared memory alias passed as destination"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s-%d\", key, vi, v);",
        "params[2].memref.buffer"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=strlen(key)+strlen(vi)+digits(v)+2,src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0023",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 201,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size from REE-tainted 'a' (params[0].value.a) without bounds check"
      ],
      "code_excerpts": [
        "int *arr_a = TEE_Malloc(a, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=a,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0024",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 202,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size from REE-tainted 'b' (params[1].memref.size) without bounds check"
      ],
      "code_excerpts": [
        "int *arr_ref = TEE_Malloc(b, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=b,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0025",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 203,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted 'a' used as array index into stack buffer tmp_arr[20] without bounds check"
      ],
      "code_excerpts": [
        "tmp_arr[a] = 43;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=4,src_sz=?,dst_sz=80"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0026",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 204,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted size2 used as loop bound without validation against str buffer size (1000)",
        "REE-tainted size2 used as loop bound for per-byte copy without validation against str buffer size"
      ],
      "code_excerpts": [
        "for (int i = 0; i < size2; i++)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size2,src_sz=size2,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0027",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 208,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "input",
        "unknown",
        "output",
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "shared_memory_overwrite",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[3].memref.size used as copy length into TEE-private str without bounds check",
        "REE-tainted params[3].memref.size used as copy length without bounds check against destination str[1000]",
        "TEE_MemMove with REE-tainted params[3].memref.size into fixed 1000-byte buffer without bounds check",
        "REE-tainted params[3].memref.size used as copy length into 1000-byte TEE buffer without bounds check"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[3].memref.size,src_sz=params[3].memref.size,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0028",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 210,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[0].value.a used in index arithmetic into str without bounds check"
      ],
      "code_excerpts": [
        "char c = str[params[0].value.a - 3];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=1000,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0029",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 212,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "input",
        "unknown",
        "output",
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "shared_memory_overwrite",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as copy length into TEE-private str without bounds check",
        "REE-tainted params[2].memref.size used as copy length without bounds check against destination str[1000]",
        "TEE_MemMove with REE-tainted params[2].memref.size into fixed 1000-byte buffer without bounds check",
        "REE-tainted params[2].memref.size used as copy length into 1000-byte TEE buffer without bounds check"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[2].memref.buffer, params[2].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[2].memref.size,src_sz=params[2].memref.size,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0030",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 220,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size from REE-tainted 'a' (params[0].value.a) without bounds check"
      ],
      "code_excerpts": [
        "int *arr_a = TEE_Malloc(a, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=a,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0031",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 221,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size from REE-tainted 'b' (params[1].memref.size) without bounds check"
      ],
      "code_excerpts": [
        "int *arr_ref = TEE_Malloc(b, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=b,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0032",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 222,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted 'a' used as array index into stack buffer tmp_arr[20] without bounds check"
      ],
      "code_excerpts": [
        "tmp_arr[a] = 43;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=4,src_sz=?,dst_sz=80"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0033",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 223,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted size2 used as loop bound without validation against str buffer size (1000)",
        "REE-tainted size2 used as loop bound for per-byte copy without validation against str buffer size"
      ],
      "code_excerpts": [
        "for (int i = 0; i < size2; i++)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size2,src_sz=size2,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0034",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 227,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i1",
        "unknown",
        "output",
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "size3 from REE used as copy length without bounds check",
        "REE-tainted size3 used as copy length into TEE-private str without bounds check",
        "REE-tainted size3 used as copy length without bounds check against destination str[1000]",
        "TEE_MemMove with REE-tainted size3 into fixed 1000-byte buffer without prior bounds check",
        "REE-tainted size3 used as copy length into 1000-byte TEE buffer without bounds check at this point",
        "TEE_MemMove copies REE-tainted size3 bytes into fixed 1000-byte TEE-private buffer without prior bounds check"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, buf3, size3);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size3,src_sz=size3,dst_sz=1000",
          "src_region:REE-visible"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0035",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 231,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted 'a' used in index arithmetic into str without bounds check",
        "REE-tainted 'a' used in index arithmetic (a-3) into str without bounds check"
      ],
      "code_excerpts": [
        "char c = str[a - 3];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=1000,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0036",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 238,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2",
        "unknown",
        "output",
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "size2 from REE used as copy length without bounds check",
        "REE-tainted size2 used as copy length into TEE-private str without bounds check",
        "REE-tainted size2 used as copy length without bounds check against destination str[1000]",
        "REE-tainted size2 used as copy length into 1000-byte TEE buffer; check at line 233 only guards size3",
        "TEE_MemMove copies REE-tainted size2 bytes into fixed 1000-byte buffer; size3 check at 233 does not guard size2"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, buf2, size2);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size2,src_sz=size2,dst_sz=1000",
          "src_region:REE-visible"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0037",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 239,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2",
        "unknown",
        "output",
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "size3 from REE used as copy length without bounds check",
        "REE-tainted size3 used as copy length into TEE-private str without bounds check",
        "REE-tainted size3 used as copy length without bounds check against destination str[1000]",
        "REE-tainted size3 used as copy length but guarded by check at line 233 (size3 > 1000)",
        "TEE_MemMove copies size3 bytes after size3>1000 check at line 233 provides upper bound"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, buf3, size3);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "shared_memory_overwrite",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size3,src_sz=size3,dst_sz=1000",
          "src_region:REE-visible"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0038",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 246,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "produce_i2",
        "unknown",
        "output",
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "other",
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Fixed 1000 bytes copied from TEE-private str to buf2; buf2 region unknown",
        "TEE-private str copied to buf2 which is alias of REE-visible memref.buffer",
        "TEE-private str copied to REE-visible buf2 with fixed length 1000; potential overwrite of shared memory",
        "Fixed 1000 bytes copied to REE-visible buf2 which may be smaller; potential buffer overflow in shared memory",
        "Fixed 1000-byte copy into REE-visible buf2 (alias of params[2].memref.buffer) without checking destination size",
        "Fixed 1000-byte copy into REE-visible buf2 (alias of params[2].memref.buffer) without checking destination capacity"
      ],
      "code_excerpts": [
        "TEE_MemMove(buf2, str, 1000);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1000,src_sz=1000,dst_sz=size2",
          "dst_region:REE-visible"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0039",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 283,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size from REE-tainted params[0].value.a without bounds check"
      ],
      "code_excerpts": [
        "int *arr_a = TEE_Malloc(params[0].value.a, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[0].value.a,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0040",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 284,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size from REE-tainted params[1].memref.size before bounds check at line 298"
      ],
      "code_excerpts": [
        "int *arr_ref = TEE_Malloc(params[1].memref.size, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[1].memref.size,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0041",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 285,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[0].value.a used as array index into stack buffer tmp_arr[20] without bounds check"
      ],
      "code_excerpts": [
        "tmp_arr[params[0].value.a] = 43;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=?,dst_sz=80"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0042",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 286,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as loop bound without validation against str buffer size (1000)",
        "REE-tainted params[2].memref.size used as loop bound for per-byte copy into str without validation"
      ],
      "code_excerpts": [
        "for (int i = 0; i < params[2].memref.size; i++)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[2].memref.size,src_sz=params[2].memref.size,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0043",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 290,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "shared_memory",
        "produce_i0",
        "unknown",
        "output",
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[3].memref.size used as copy length into TEE-private str without bounds check",
        "REE-tainted params[3].memref.size used as copy length without bounds check against destination str[1000]",
        "TEE_MemMove with REE-tainted size params[3].memref.size into fixed 1000-byte buffer without bounds check",
        "REE-tainted params[3].memref.size used as copy length into 1000-byte TEE buffer without bounds check",
        "TEE_MemMove copies REE-tainted params[3].memref.size bytes into fixed 1000-byte buffer without bounds check",
        "REE-tainted params[3].memref.size used as copy length into fixed 1000-byte TEE-private buffer without bounds check",
        "src pointer params[3].memref.buffer bound to REE-visible region",
        "dst pointer str bound to TEE-private region (TEE_Malloc)"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size);",
        "params[3].memref.buffer",
        "str"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite",
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[3].memref.size,src_sz=params[3].memref.size,dst_sz=1000",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0044",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 291,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "shared_memory",
        "produce_i0",
        "unknown",
        "output",
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "other",
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Fixed 1000 bytes copied from TEE-private str to REE-visible params[2].memref.buffer",
        "TEE-private str copied to REE-visible params[2].memref.buffer",
        "TEE-private str copied to REE-visible params[2].memref.buffer with fixed length 1000; may exceed buffer size",
        "Fixed 1000 bytes copied to REE-visible params[2].memref.buffer which may be smaller; potential buffer overflow",
        "Fixed 1000-byte copy into REE-visible params[2].memref.buffer without checking destination size",
        "Fixed 1000-byte copy into REE-visible params[2].memref.buffer without checking destination capacity",
        "dst pointer params[2].memref.buffer bound to REE-visible region"
      ],
      "code_excerpts": [
        "TEE_MemMove(params[2].memref.buffer, str, 1000);",
        "params[2].memref.buffer"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1000,src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0045",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 293,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[3].memref.size used in index arithmetic without bounds check"
      ],
      "code_excerpts": [
        "char c = ((char *)params[3].memref.buffer)[params[3].memref.size - 3];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=params[3].memref.size,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0046",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 295,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[0].value.a used in index arithmetic into str without bounds check"
      ],
      "code_excerpts": [
        "c = str[params[0].value.a - 3];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=1000,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0047",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 296,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[0].value.a used in index arithmetic into str without bounds check"
      ],
      "code_excerpts": [
        "c = str[30 - params[0].value.a];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:TEE-private",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=1000,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0048",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 306,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "shared_memory",
        "unknown",
        "output",
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "shared_memory_overwrite",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as copy length into TEE-private str without bounds check",
        "REE-tainted params[2].memref.size used as copy length without bounds check against destination str[1000]",
        "TEE_MemMove with REE-tainted size params[2].memref.size into fixed 1000-byte buffer without bounds check",
        "REE-tainted params[2].memref.size used as copy length into 1000-byte TEE buffer without bounds check",
        "TEE_MemMove copies REE-tainted params[2].memref.size bytes into fixed 1000-byte buffer without bounds check",
        "REE-tainted params[2].memref.size used as copy length into fixed 1000-byte TEE-private buffer without bounds check"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[2].memref.buffer, params[2].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[2].memref.size,src_sz=params[2].memref.size,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0049",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 307,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "shared_memory",
        "unknown",
        "output",
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "shared_memory_overwrite",
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[3].memref.size used as copy length into TEE-private str without bounds check",
        "REE-tainted params[3].memref.size used as copy length without bounds check against destination str[1000]",
        "TEE_MemMove with REE-tainted size params[3].memref.size into fixed 1000-byte buffer without bounds check",
        "REE-tainted params[3].memref.size used as copy length into 1000-byte TEE buffer without bounds check",
        "TEE_MemMove copies REE-tainted params[3].memref.size bytes into fixed 1000-byte buffer without bounds check",
        "REE-tainted params[3].memref.size used as copy length into fixed 1000-byte TEE-private buffer without bounds check"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite",
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[3].memref.size,src_sz=params[3].memref.size,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0050",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 309,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "other",
      "functions": [
        "shared_memory",
        "unknown",
        "output",
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "rules": [
        "other",
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "Fixed 1000 bytes copied from TEE-private str to REE-visible params[2].memref.buffer",
        "TEE-private str copied to REE-visible params[2].memref.buffer",
        "TEE-private str copied to REE-visible params[2].memref.buffer with fixed length 1000; may exceed buffer size",
        "Fixed 1000 bytes copied to REE-visible params[2].memref.buffer which may be smaller; potential buffer overflow",
        "Fixed 1000-byte copy into REE-visible params[2].memref.buffer without checking destination size",
        "Fixed 1000-byte copy into REE-visible params[2].memref.buffer without checking destination capacity"
      ],
      "code_excerpts": [
        "TEE_MemMove(params[2].memref.buffer, str, 1000);"
      ],
      "rule_matches": {
        "rule_id": [
          "other",
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1000,src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0051",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 334,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce_s"
      ],
      "sink_functions": [
        "strcmp"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "strcmp on REE-visible shared buffer without prior copy to TEE-private memory",
        "strcmp operates directly on REE-visible shared buffer without prior copy, TOCTOU risk"
      ],
      "code_excerpts": [
        "if (strcmp(\"123456\", buf) == 0)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0052",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 340,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_s"
      ],
      "sink_functions": [
        "TEE_MemCompare"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_MemCompare uses REE-tainted size on shared buffer before bounds check",
        "TEE_MemCompare uses REE-tainted size on shared buffer before bounds check at line 346"
      ],
      "code_excerpts": [
        "TEE_MemCompare(buf, \"123456\", size)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0053",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 350,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_s1",
        "unknown",
        "output",
        "produce_s0",
        "produce_s"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "weak_input_validation",
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "size from REE used as copy length without bounds check",
        "REE-tainted size used as copy length into TEE-private str without bounds check",
        "REE-tainted size used as copy length without bounds check against destination str[1000]",
        "REE-tainted size used as copy length into 1000-byte stack buffer without bounds check",
        "TEE_MemMove copies REE-tainted size bytes into fixed 1000-byte stack buffer without bounds check",
        "REE-tainted size used as copy length into fixed 1000-byte stack buffer without bounds check",
        "src pointer buf bound to unknown region (depends on caller)",
        "TEE_MemMove copies from REE-visible buffer to TEE-private stack with bounds-checked size",
        "TEE_MemMove dest str is TEE-private stack buffer bound at call site",
        "TEE_MemMove src buf is alias of REE-visible shared buffer bound at call site",
        "TEE_MemMove copies from REE-visible to TEE-private with bounds-checked size"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, buf, size);",
        "buf"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "shared_memory_overwrite",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=size,dst_sz=1000",
          "src_region:REE-visible",
          "flow_dir:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0054",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 357,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of REE-visible shared buffer assigned to local pointer buf"
      ],
      "code_excerpts": [
        "void *buf = params[0].memref.buffer;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=sz,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0055",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 358,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted size value assigned to local variable sz"
      ],
      "code_excerpts": [
        "uint32_t sz = params[0].memref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0056",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 359,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "strcmp"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "strcmp on REE-visible shared buffer without prior copy to TEE-private memory"
      ],
      "code_excerpts": [
        "if (strcmp(\"123456\", buf) == 0)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0057",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 366,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "TEE_MemCompare"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_MemCompare uses REE-tainted params[0].memref.size on shared buffer without bounds check"
      ],
      "code_excerpts": [
        "TEE_MemCompare(params[0].memref.buffer, \"123456\", params[0].memref.size)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[0].memref.size,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0058",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 372,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "TEE_MemCompare"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_MemCompare uses REE-tainted params[0].memref.size on shared buffer without bounds check"
      ],
      "code_excerpts": [
        "TEE_MemCompare(\"123456\", params[0].memref.buffer, params[0].memref.size)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[0].memref.size,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0059",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 378,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "TEE_MemCompare"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_MemCompare uses REE-tainted sz on shared buffer alias without bounds check at this point"
      ],
      "code_excerpts": [
        "TEE_MemCompare(\"123456\", buf, sz)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sz,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0060",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 384,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "strcmp"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "strcmp on REE-visible shared buffer without prior copy"
      ],
      "code_excerpts": [
        "strcmp(params[0].memref.buffer, \"123456\")"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0061",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 389,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "strcmp"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "strcmp on REE-visible shared buffer without prior copy"
      ],
      "code_excerpts": [
        "strcmp(\"123456\", params[0].memref.buffer)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0062",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 393,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "strcmp"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "strcmp on REE-visible shared buffer alias without prior copy"
      ],
      "code_excerpts": [
        "strcmp(buf, \"123456\")"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0063",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 401,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "unknown",
        "produce_s3",
        "output",
        "shared_memory"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[0].memref.size used as copy length into TEE-private str without bounds check",
        "REE-tainted params[0].memref.size used as copy length without bounds check against destination str[1000]",
        "REE-tainted params[0].memref.size used as copy length into 1000-byte stack buffer without bounds check",
        "TEE_MemMove copies REE-tainted params[0].memref.size bytes into fixed 1000-byte stack buffer without bounds check",
        "REE-tainted params[0].memref.size used as copy length into fixed 1000-byte stack buffer without bounds check",
        "src pointer params[0].memref.buffer bound to REE-visible region",
        "TEE_MemMove copies from REE-visible buffer to TEE-private stack with bounds-checked size",
        "destination str is TEE-private stack buffer bound to TEE_MemMove first argument",
        "source params[0].memref.buffer is REE-visible shared memory bound to TEE_MemMove second argument",
        "copy length params[0].memref.size is REE-tainted; sz checked but params[0].memref.size used directly may differ"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size);",
        "params[0].memref.buffer",
        "TEE_MemMove(str, ...)",
        "TEE_MemMove(..., params[0].memref.buffer, ...)",
        "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size)"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite",
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[0].memref.size,src_sz=params[0].memref.size,dst_sz=1000",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?",
          "src_region:TEE-private",
          "size_triplet:copy_len=params[0].memref.size,src_sz=?,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0064",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 422,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of REE-visible shared buffer assigned to local pointer buf"
      ],
      "code_excerpts": [
        "void *buf = params[0].memref.buffer;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=sz,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0065",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 423,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted size value assigned to local variable sz"
      ],
      "code_excerpts": [
        "uint32_t sz = params[0].memref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0066",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 425,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "strcmp"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TOCTOU: strcmp on shared buffer before TEE_Wait, buffer can be modified by REE",
        "TOCTOU: strcmp on REE-visible shared buffer before TEE_Wait, content can change"
      ],
      "code_excerpts": [
        "if (strcmp(\"123456\", buf) == 0)",
        "strcmp(\"123456\", buf)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0067",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 432,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "other",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "strcmp"
      ],
      "rules": [
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TOCTOU: strcmp on shared buffer after TEE_Wait, buffer may have changed",
        "TOCTOU: strcmp on REE-visible shared buffer after TEE_Wait, content may have changed"
      ],
      "code_excerpts": [
        "if (strcmp(\"123456\", buf))",
        "strcmp(\"123456\", buf)"
      ],
      "rule_matches": {
        "rule_id": [
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0068",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 437,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "TEE_MemCompare"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_MemCompare uses REE-tainted sz as length on shared buffer without prior copy",
        "TEE_MemCompare uses REE-tainted sz on shared buffer without copy to private memory first"
      ],
      "code_excerpts": [
        "TEE_MemCompare(buf, \"123456\", sz)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=sz,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0069",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 445,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "TEE_MemCompare"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_MemCompare uses REE-tainted params[0].memref.size on shared buffer"
      ],
      "code_excerpts": [
        "TEE_MemCompare(params[0].memref.buffer, \"123456\", params[0].memref.size)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[0].memref.size,src_sz=?,dst_sz=?"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0070",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 485,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "unknown",
        "produce_s5",
        "output",
        "shared_memory"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted params[0].memref.size used as copy length into TEE-private str without bounds check",
        "REE-tainted params[0].memref.size used as copy length without bounds check against destination str[1000]",
        "REE-tainted params[0].memref.size used as copy length into TEE buffer without bounds check",
        "TEE_MemMove copies REE-tainted params[0].memref.size bytes into fixed buffer without bounds check",
        "REE-tainted params[0].memref.size used as copy length into TEE-private buffer without bounds check",
        "src pointer params[0].memref.buffer bound to REE-visible region",
        "TEE_MemMove copies from REE-visible buffer to TEE-private stack with bounds-checked size",
        "destination str is TEE-private stack buffer bound to TEE_MemMove first argument",
        "source params[0].memref.buffer is REE-visible shared memory bound to TEE_MemMove second argument",
        "copy length params[0].memref.size is REE-tainted; sz checked but params[0].memref.size used directly may differ",
        "dest parameter bound to str which is TEE-private stack buffer",
        "src parameter bound to params[0].memref.buffer which is REE-visible shared memory",
        "size parameter uses params[0].memref.size which may differ from sz checked at line 481 due to TOCTOU on shared memory"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size);",
        "params[0].memref.buffer",
        "TEE_MemMove(str, ...)",
        "TEE_MemMove(..., params[0].memref.buffer, ...)",
        "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size)"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite",
          "weak_input_validation",
          "other"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[0].memref.size,src_sz=params[0].memref.size,dst_sz=1000",
          "size_triplet:copy_len=params[0].memref.size,src_sz=params[0].memref.size,dst_sz=unknown",
          "size_triplet:copy_len=?,src_sz=?,dst_sz=?",
          "src_region:TEE-private",
          "size_triplet:copy_len=params[0].memref.size,src_sz=?,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1,
        "shared_memory_overwrite": 1,
        "other": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    }
  ]
}