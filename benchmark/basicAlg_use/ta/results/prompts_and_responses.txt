# External Function: TEE_AllocateOperation
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AllocateOperation", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AllocateOperation",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AllocateOperation",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "allocation/handle management, not a write sink"
}

# External Function: TEE_AllocateTransientObject
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AllocateTransientObject", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AllocateTransientObject",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AllocateTransientObject",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Allocation API; no write to buffers."
}

# External Function: TEE_AsymmetricDecrypt
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AsymmetricDecrypt", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AsymmetricDecrypt",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AsymmetricDecrypt",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 0, "role": "dest", "reason": "decrypt output written to output buffer"},
    {"param_index": 2, "role": "len", "reason": "size of output buffer"}
  ],
  "reason": "decrypt writes to an output buffer, enabling overflow risk"
}

# External Function: TEE_AsymmetricEncrypt
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AsymmetricEncrypt", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AsymmetricEncrypt",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AsymmetricEncrypt",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Crypto primitive; not a documented plaintext sink in GP TEE"
}

# External Function: TEE_AsymmetricSignDigest
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AsymmetricSignDigest", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AsymmetricSignDigest",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AsymmetricSignDigest",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 3, "role": "buf", "reason": "writes to output signature buffer"}
  ],
  "reason": "writes to an output buffer (signature)"
}

# External Function: TEE_AsymmetricVerifyDigest
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AsymmetricVerifyDigest", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AsymmetricVerifyDigest",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AsymmetricVerifyDigest",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Verify function does not write to REE buffers; no sink parameter."
}

# External Function: TEE_CipherDoFinal
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_CipherDoFinal", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_CipherDoFinal",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_CipherDoFinal",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 0, "role": "dest", "reason": "memcpy-like output buffer for cipher result"}
  ],
  "reason": "cipher final writes to an output buffer (memcpy-like)"
}

# External Function: TEE_CipherInit
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_CipherInit", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_CipherInit",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_CipherInit",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "crypto primitive init; not a plaintext sink."
}

# External Function: TEE_CipherUpdate
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_CipherUpdate", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_CipherUpdate",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_CipherUpdate",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "crypto primitive; not a plaintext sink"
}

# External Function: TEE_DeriveKey
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_DeriveKey", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_DeriveKey",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_DeriveKey",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 1, "role": "buf", "reason": "Derives key writes to output buffer"}
  ],
  "reason": "Derives key writes to output buffer."
}

# External Function: TEE_DigestDoFinal
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_DigestDoFinal", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_DigestDoFinal",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_DigestDoFinal",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 3, "role": "buf", "reason": "writes final digest to caller-provided buffer"}
  ],
  "reason": "Final digest output is written to a caller-supplied buffer"
}

# External Function: TEE_DigestUpdate
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_DigestUpdate", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_DigestUpdate",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_DigestUpdate",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Digest update reads input data; no attacker-writable destination."
}

# External Function: TEE_FreeOperation
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_FreeOperation", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_FreeOperation",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_FreeOperation",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Name implies deallocation; no documented write signature."
}

# External Function: TEE_FreeTransientObject
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_FreeTransientObject", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_FreeTransientObject",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_FreeTransientObject",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Deallocation function; no documented write sink"
}

# External Function: TEE_GenerateRandom
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_GenerateRandom", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_GenerateRandom",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_GenerateRandom",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 0, "role": "dest", "reason": "writes generated random bytes to destination buffer"},
    {"param_index": 1, "role": "len", "reason": "specifies number of bytes to write into destination"}
  ],
  "reason": "fill/random-to-buffer family; writes to dest buffer"
}

# External Function: TEE_GetObjectBufferAttribute
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_GetObjectBufferAttribute", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_GetObjectBufferAttribute",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_GetObjectBufferAttribute",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 2, "role": "dest", "reason": "writes attribute bytes into user buffer (memcpy-like)"}
  ],
  "reason": "dest buffer write of object attribute"
}

# External Function: TEE_InitRefAttribute
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_InitRefAttribute", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_InitRefAttribute",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_InitRefAttribute",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 0, "role": "dest", "reason": "initializes attribute struct (destination write)"}
  ],
  "reason": "Name maps to memcpy-like destination write during init"
}

# External Function: TEE_MemFill
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_MemFill", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_MemFill",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_MemFill",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 0, "role": "dest", "reason": "memset-like write to destination buffer"},
    {"param_index": 1, "role": "len", "reason": "length controls write extent"}
  ],
  "reason": "memset-like fill to a buffer with attacker-influenceable length"
}

# External Function: TEE_MemMove
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_MemMove", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_MemMove",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_MemMove",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 0, "role": "dest", "reason": "dest buffer gets attacker-controlled bytes (memmove-like copy)"}
  ],
  "reason": "memmove-like copy to destination buffer (buffer write)"
}

# External Function: TEE_PopulateTransientObject
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_PopulateTransientObject", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_PopulateTransientObject",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_PopulateTransientObject",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Name implies population/setup, not a write to a buffer."
}

# External Function: TEE_SetOperationKey
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_SetOperationKey", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_SetOperationKey",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_SetOperationKey",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Insufficient information to map to a documented sink signature."
}

# External Function: UNUSED
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "UNUSED", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "UNUSED",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "UNUSED",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Name does not map to a documented write family (no buffer/len signature)."
}

