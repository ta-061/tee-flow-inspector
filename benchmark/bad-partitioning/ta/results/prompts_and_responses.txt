# External Function: DMSG
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "DMSG", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "DMSG",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "DMSG",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Explicitly excluded as a debug/log macro to reduce noise."
}
```

# External Function: IMSG
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "IMSG", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "IMSG",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "IMSG",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Excluded: IMSG is a debug/trace/log macro, not a vulnerability sink."
}
```

# External Function: TEE_Malloc
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_Malloc", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_Malloc",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "TEE_Malloc",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Memory allocation function; excluded by rule."
}
```

# External Function: TEE_MemCompare
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_MemCompare", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_MemCompare",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "TEE_MemCompare",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Function performs memory comparison (read-only), not a write operation."
}
```

# External Function: TEE_MemMove
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_MemMove", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_MemMove",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "TEE_MemMove",
  "is_sink_candidate": true,
  "dangerous_params": [
    {
      "param_index": 0,
      "role": "dest",
      "reason": "Destination buffer for byte copy, potential target for corruption."
    },
    {
      "param_index": 2,
      "role": "len",
      "reason": "Controls the number of bytes copied, critical for preventing buffer overflows."
    }
  ],
  "reason": "TEE_MemMove is a memcpy-like function, a common source of memory corruption and info leakage."
}
```

# External Function: TEE_PARAM_TYPES
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_PARAM_TYPES", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_PARAM_TYPES",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "TEE_PARAM_TYPES",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Function name indicates a type/descriptor helper, excluded from sink candidates."
}
```

# External Function: TEE_Wait
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_Wait", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_Wait",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "TEE_Wait",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "TEE_Wait is a synchronization/delay function; it does not write data to any buffer or sink."
}
```

# External Function: snprintf
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "snprintf", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "snprintf",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "snprintf",
  "is_sink_candidate": true,
  "dangerous_params": [
    {
      "param_index": 0,
      "role": "dest",
      "reason": "Output buffer for formatted string."
    },
    {
      "param_index": 1,
      "role": "len",
      "reason": "Maximum number of bytes to write to buffer."
    }
  ],
  "reason": "snprintf is a printf-like function writing formatted output to a buffer, susceptible to overflow/leakage."
}
```

# External Function: strcmp
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "strcmp", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "strcmp",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "strcmp",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Function is read-only; compares two strings, does not write to any buffer."
}
```

# External Function: strlen
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "strlen", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "strlen",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
```json
{
  "function": "strlen",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Function calculates string length; it reads, does not write to any buffer or output channel."
}
```

