# External Function: DMSG
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "DMSG", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "DMSG",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "DMSG",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "DMSG is a logging macro, excluded per guidelines"
}

# External Function: EMSG
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "EMSG", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "EMSG",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "EMSG",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Log macro; excluded from sink candidate evaluation"
}

# External Function: TEE_AllocateOperation
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AllocateOperation", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AllocateOperation",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AllocateOperation",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "allocation API; not a direct buffer write sink."
}

# External Function: TEE_AllocateTransientObject
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AllocateTransientObject", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AllocateTransientObject",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AllocateTransientObject",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "allocation API; no documented write to buffers/handles streams"
}

# External Function: TEE_FreeOperation
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_FreeOperation", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_FreeOperation",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_FreeOperation",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "deallocation API; not a data sink/byte write."
}

# External Function: TEE_FreeTransientObject
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_FreeTransientObject", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_FreeTransientObject",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_FreeTransientObject",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "not a documented write sink; frees object handle only."
}

# External Function: TEE_InitRefAttribute
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_InitRefAttribute", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_InitRefAttribute",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_InitRefAttribute",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Initialization helper; no clear destination buffer write."
}

# External Function: TEE_MACComputeFinal
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_MACComputeFinal", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_MACComputeFinal",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_MACComputeFinal",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 0, "role": "dest/buf", "reason": "MAC final output to user buffer"}
  ],
  "reason": "MAC final output writes to provided buffer"
}

# External Function: TEE_MACInit
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_MACInit", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_MACInit",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_MACInit",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Initialization of MAC context; no explicit external buffer write."
}

# External Function: TEE_MACUpdate
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_MACUpdate", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_MACUpdate",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_MACUpdate",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "MAC update takes input data; no external dest/buffer write parameter."
}

# External Function: TEE_PARAM_TYPES
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_PARAM_TYPES", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_PARAM_TYPES",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_PARAM_TYPES",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "descriptor/access-check helper; not a sink"
}

# External Function: TEE_PopulateTransientObject
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_PopulateTransientObject", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_PopulateTransientObject",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_PopulateTransientObject",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "name implies initialization; not a documented byte-write sink"
}

# External Function: TEE_SetOperationKey
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_SetOperationKey", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_SetOperationKey",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_SetOperationKey",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "No clear, documented write-to-buffer sink from name alone."
}

# External Function: memcpy
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "memcpy", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "memcpy",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "memcpy",
  "is_sink_candidate": true,
  "dangerous_params": [
    {
      "param_index": 0,
      "role": "dest",
      "reason": "Memcpy destination buffer write with attacker-controlled length"
    }
  ],
  "reason": "Memcpy to destination buffer with length"
}

# External Function: memset
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "memset", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "memset",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "memset",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 0, "role": "dest", "reason": "writes n bytes to the destination buffer"}
  ],
  "reason": "memset is a fill/write-to-buffer API (dest, len)."
}

