TA Name,Finding ID,Type,File Path,Line Number,Rule ID,Functions,Vulnerability Description,Structural Risk Description,Code Excerpt
ta,RISK-0001,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,112,,produce_2,,"sensitivity promotion: local variable name 'key2' suggests key-like material (hardcoded), treat as potentially sensitive","char key2[1000] = ""123456"";"
ta,"VULN-0001, RISK-0002",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,116,"unencrypted_output, weak_input_validation","TEE_MemMove, produce_2",No bounds check ensures params[1].memref.size can accommodate strlen(key2) bytes before the TEE_MemMove write.,"TEE_MemMove writes strlen(key2) bytes into params[1].memref.buffer without checking params[1].memref.size >= strlen(key2) (dst size is REE-controlled)
key-like data copied from TA private stack buffer into REE-visible memref buffer
call-site binding: dst argument aliases params[1].memref.buffer which is typically REE-visible shared memory
call-site binding: src argument aliases local stack buffer key2 (TA-private) and appears key-like by name
TEE_MemMove performs a raw copy of caller-supplied length; safety depends on external bound (e.g., memref.size) being checked on the same path before this call","TA_InvokeCommandEntryPoint -> output -> produce -> produce_2 -> TEE_MemMove
TEE_MemMove(params[1].memref.buffer, key2, strlen(key2));"
ta,"VULN-0002, RISK-0003",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,117,"unencrypted_output, weak_input_validation","produce_2, snprintf",Copies/formats key2 into params[2].memref.buffer (REE-visible).,"key-like data formatted into REE-visible memref buffer (params[2].memref.buffer) using REE-controlled size
call-site binding: snprintf destination pointer aliases params[2].memref.buffer, which is typically REE-visible shared memory
snprintf bound 'n' is params[2].memref.size (REE-controlled); if inconsistent with actual mapped buffer size, write bounds may not match real destination capacity
Call-site binding: params[2].memref.buffer passed as snprintf destination is an alias of REE-visible shared memory.","TA_InvokeCommandEntryPoint -> output -> produce -> produce_2 -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s"", key2);
snprintf(params[2].memref.buffer, params[2].memref.size, ...)"
ta,"VULN-0003, RISK-0004",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,121,unencrypted_output,produce_2,Copies/formats key2 into params[2].memref.buffer (REE-visible).,key-like data (plus vi) formatted into REE-visible memref buffer (params[2].memref.buffer),"TA_InvokeCommandEntryPoint -> output -> produce -> produce_2 -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s-%s"", key2, vi);"
ta,"VULN-0004, RISK-0005",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,122,unencrypted_output,produce_2,Copies/formats key2 into params[2].memref.buffer (REE-visible).,key-like data (plus vi and v) formatted into REE-visible memref buffer (params[2].memref.buffer),"TA_InvokeCommandEntryPoint -> output -> produce -> produce_2 -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s-%s-%d"", key2, vi, v);"
ta,"VULN-0005, RISK-0006",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,125,unencrypted_output,produce_2,Copies/formats key2 into params[2].memref.buffer (REE-visible) even after enc(key2).,"after enc(key2), key2 is still treated as key-like material and is formatted into REE-visible memref buffer","TA_InvokeCommandEntryPoint -> output -> produce -> produce_2 -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s"", key2);"
ta,"VULN-0006, RISK-0007",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,126,unencrypted_output,produce_2,Copies/formats key2 into params[2].memref.buffer (REE-visible) even after enc(key2).,"after enc(key2), key2 (plus vi) formatted into REE-visible memref buffer","TA_InvokeCommandEntryPoint -> output -> produce -> produce_2 -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s-%s"", key2, vi);"
ta,RISK-0008,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,132,,produce,,"sensitivity promotion: local variable name 'key1' suggests key-like material (hardcoded), treat as potentially sensitive","char key1[1000] = ""123456"";"
ta,"VULN-0007, RISK-0009",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,136,"unencrypted_output, weak_input_validation","TEE_MemMove, produce",Missing check that params[1].memref.size >= strlen(key1) before copying into params[1].memref.buffer.,"TEE_MemMove writes strlen(key1) bytes into params[1].memref.buffer without checking params[1].memref.size >= strlen(key1) (dst size is REE-controlled)
key-like data copied from TA private stack buffer into REE-visible memref buffer
call-site binding: dst argument aliases params[1].memref.buffer which is typically REE-visible shared memory
call-site binding: src argument aliases local stack buffer key1 (TA-private; name suggests key-like material)","TA_InvokeCommandEntryPoint -> output -> produce -> TEE_MemMove
TEE_MemMove(params[1].memref.buffer, key1, strlen(key1));"
ta,"VULN-0008, RISK-0010",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,137,"unencrypted_output, weak_input_validation","produce, snprintf",Plaintext key-like data (key1) is formatted into REE-visible params[2].memref.buffer.,"key-like data formatted into REE-visible memref buffer (params[2].memref.buffer) using REE-controlled size
call-site binding: destination pointer 's' aliases params[2].memref.buffer which is REE-visible shared memory
call-site binding: length 'n' comes from params[2].memref.size (REE-controlled); if inconsistent with actual accessible shared buffer, snprintf may still fault/overwrite","TA_InvokeCommandEntryPoint -> output -> produce -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s"", key1);
snprintf(params[2].memref.buffer, params[2].memref.size, ...)"
ta,VULN-0009,Vulnerability,/workspace/benchmark/bad-partitioning/ta/entry.c,143,unencrypted_output,produce,Plaintext key-like data (key1) is formatted into REE-visible params[2].memref.buffer.,,TA_InvokeCommandEntryPoint -> output -> produce -> snprintf
ta,VULN-0010,Vulnerability,/workspace/benchmark/bad-partitioning/ta/entry.c,144,unencrypted_output,produce,Plaintext key-like data (key1) is formatted into REE-visible params[2].memref.buffer.,,TA_InvokeCommandEntryPoint -> output -> produce -> snprintf
ta,VULN-0011,Vulnerability,/workspace/benchmark/bad-partitioning/ta/entry.c,147,unencrypted_output,produce,Key-like data (key1) is still output to REE-visible params[2].memref.buffer; prior enc(key1) is not a proven sanitizer at this sink.,,TA_InvokeCommandEntryPoint -> output -> produce -> snprintf
ta,VULN-0012,Vulnerability,/workspace/benchmark/bad-partitioning/ta/entry.c,148,unencrypted_output,produce,Plaintext key-like data (key1) is formatted into REE-visible params[2].memref.buffer.,,TA_InvokeCommandEntryPoint -> output -> produce -> snprintf
ta,RISK-0011,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,153,,produce_3,,"sensitivity promotion: local variable named 'key' appears to hold key-like material (hardcoded), treat as potentially sensitive","char key[1000] = ""123456"";"
ta,"VULN-0013, RISK-0012",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,154,"unencrypted_output, weak_input_validation","TEE_MemMove, produce_3",Unbounded copy length (strlen(key)) into REE-controlled buf with no check that the provided memref capacity is sufficient.,"TEE_MemMove writes strlen(key) bytes to buf without checking provided size; buf/size are REE-controlled via shared memref
key-like data copied from TA private stack buffer into REE-visible buffer via buf
call-site binding: dest argument aliases REE-visible shared buffer (buf from memref.buffer), so raw copy writes into Normal World memory
call-site binding: src argument points to TA-private stack data (local key buffer) copied outward depending on dest
TEE_MemMove(buf, key, strlen(key)) uses no check that REE-controlled 'size'/actual buffer capacity is >= strlen(key), risking overflow (not a target sink line).","TA_InvokeCommandEntryPoint -> output -> produce_3 -> TEE_MemMove
TEE_MemMove(buf, key, strlen(key));"
ta,"VULN-0014, RISK-0013",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,155,"unencrypted_output, weak_input_validation","produce_3, snprintf",Potential out-of-bounds write if REE-controlled 'size' exceeds actual capacity of REE-visible buffer 'buf'.,"call-site binding: snprintf destination pointer 'buf' originates from a caller-provided pointer; region (REE-visible vs TEE-private) is unknown at this hop
call-site binding: destination pointer 's' aliases buf passed into produce_3(); upstream passes shared memref buffer here
key-like data formatted into REE-visible buffer; size parameter is REE-controlled and may be 0/too small (truncation) but still discloses content when readable
call-site binding: snprintf destination pointer 'buf' aliases REE-visible shared memory passed into produce_3()
call uses REE-controlled length 'size' to bound a write into REE-visible buffer; TA does not validate that 'size' matches actual mapped buffer length","TA_InvokeCommandEntryPoint -> output -> produce_3 -> snprintf
snprintf(buf, size, ""%s"", key);"
ta,RISK-0014,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,168,,output,,"param_types equality check does not validate memref sizes/capacities used by downstream copies, leaving size-related risks unmitigated.
Type validation exists (param_types check), but it does not prevent confidential data from being written into REE-visible buffers later.",if (param_types != exp_param_types) return TEE_ERROR_BAD_PARAMETERS;
ta,RISK-0015,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,171,,output,,"sensitivity promotion: local variable named 'key' appears to hold key-like material (hardcoded), treat as potentially sensitive","char key[1000] = ""123456"";"
ta,"VULN-0015, RISK-0016",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,175,"unencrypted_output, weak_input_validation","TEE_MemMove, output",Unchecked TEE_MemMove to REE-visible buffer can overflow when params[1].memref.size < strlen(key).,"TEE_MemMove writes strlen(key) bytes into params[1].memref.buffer without checking params[1].memref.size >= strlen(key) (dst size is REE-provided)
key-like data copied from TA private stack buffer into REE-visible memref buffer
call-site binding: dest argument aliases params[1].memref.buffer which is typically REE-visible shared memory
call-site binding: src argument points to TA stack buffer 'key' (TEE-private origin)
copy length is not checked at this hop against destination allocation; if params[1].memref.size < strlen(key) the write may overflow shared buffer","TA_InvokeCommandEntryPoint -> output -> TEE_MemMove
TEE_MemMove(params[1].memref.buffer, key, strlen(key));"
ta,"VULN-0016, RISK-0017",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,176,unencrypted_output,"output, snprintf",Writes key-like data to REE-visible memref buffer.,"key-like data formatted into REE-visible memref buffer (params[2].memref.buffer)
call-site binding: snprintf destination pointer params[2].memref.buffer is REE-visible shared memory (memref buffer from Normal World)
call-site binding: snprintf(dst=params[2].memref.buffer) receives a REE-visible shared buffer pointer (write target)
potential key-like material ('key') is formatted into a REE-visible shared buffer via snprintf","TA_InvokeCommandEntryPoint -> output -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s"", key);"
ta,"VULN-0017, RISK-0018",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,184,unencrypted_output,"output, snprintf",Writes key-like data to REE-visible memref buffer.,"call-site binding: snprintf destination pointer params[2].memref.buffer is REE-visible shared memory (memref buffer from Normal World)
potential key-like material ('key') is formatted (with 'vi') into a REE-visible shared buffer via snprintf","TA_InvokeCommandEntryPoint -> output -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s-%s"", key, vi);"
ta,"VULN-0018, RISK-0019",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,185,unencrypted_output,"output, snprintf",Writes key-like data to REE-visible memref buffer.,call-site binding: snprintf destination pointer params[2].memref.buffer is REE-visible shared memory (memref buffer from Normal World),"TA_InvokeCommandEntryPoint -> output -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s-%s-%d"", key, vi, v);"
ta,"VULN-0019, RISK-0020",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,189,unencrypted_output,"output, snprintf",Writes key-like data to REE-visible memref buffer.,call-site binding: snprintf destination pointer params[2].memref.buffer is REE-visible shared memory (memref buffer from Normal World),"TA_InvokeCommandEntryPoint -> output -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s"", key);"
ta,"VULN-0020, RISK-0021",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,190,unencrypted_output,"output, snprintf",Writes key-like data to REE-visible memref buffer.,call-site binding: snprintf destination pointer params[2].memref.buffer is REE-visible shared memory (memref buffer from Normal World),"TA_InvokeCommandEntryPoint -> output -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s-%s"", key, vi);"
ta,"VULN-0021, RISK-0022",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,191,unencrypted_output,"output, snprintf",Writes key-like data to REE-visible memref buffer.,call-site binding: snprintf destination pointer params[2].memref.buffer is REE-visible shared memory (memref buffer from Normal World),"TA_InvokeCommandEntryPoint -> output -> snprintf
snprintf(params[2].memref.buffer, params[2].memref.size, ""%s-%s-%d"", key, vi, v);"
ta,RISK-0023,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,201,weak_input_validation,produce_i2,,tainted allocation sizes a/b (from REE) used in TEE_Malloc without bounds checks (resource exhaustion/undefined behavior if negative/huge),"int *arr_a = TEE_Malloc(a, 0); int *arr_ref = TEE_Malloc(b, 0);"
ta,RISK-0024,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,203,weak_input_validation,produce_i2,,tainted index a writes into fixed stack array tmp_arr[20] without bounds check (OOB write in TA private memory),tmp_arr[a] = 43;
ta,RISK-0025,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,204,weak_input_validation,produce_i2,,tainted loop bound size2 writes into str (1000 bytes) without checking size2 <= 1000 (TA-private buffer overflow),for (int i = 0; i < size2; i++) { str[i] = ((char *)buf2)[i]; }
ta,"VULN-0022, RISK-0026",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,208,weak_input_validation,"TEE_MemMove, produce_i2",params[3].memref.size can exceed 1000 causing overflow of str.,"call-site binding: src argument aliases REE-visible shared buffer (params[3].memref.buffer), so raw copy pulls untrusted data into TA memory
TEE_MemMove copies params[3].memref.size bytes (REE-controlled) into str (1000 bytes) without bounds check (TA-private overflow)","TA_InvokeCommandEntryPoint -> input -> produce_i0 -> produce_i2 -> TEE_MemMove
TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size);"
ta,RISK-0027,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,210,weak_input_validation,produce_i2,,tainted index params[0].value.a used in str[...-3] without checking range (possible OOB read in TA-private buffer),char c = str[params[0].value.a - 3];
ta,"VULN-0023, RISK-0028",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,212,weak_input_validation,produce_i2,params[2].memref.size can exceed 1000 causing overflow of str.,TEE_MemMove copies params[2].memref.size bytes (REE-controlled) into str (1000 bytes) without bounds check (TA-private overflow),"TA_InvokeCommandEntryPoint -> input -> produce_i0 -> produce_i2 -> TEE_MemMove
TEE_MemMove(str, params[2].memref.buffer, params[2].memref.size);"
ta,RISK-0029,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,220,weak_input_validation,produce_i0,,tainted allocation sizes a/b (from REE via input()) used in TEE_Malloc without bounds checks (resource exhaustion/undefined behavior if negative/huge),"int *arr_a = TEE_Malloc(a, 0); int *arr_ref = TEE_Malloc(b, 0);"
ta,RISK-0030,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,222,weak_input_validation,produce_i0,,"tainted index a used to write into fixed stack array tmp_arr[20] with no bounds check (OOB write in TA private memory)
tainted index a writes tmp_arr[20] without bounds check (OOB write).",tmp_arr[a] = 43;
ta,RISK-0031,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,223,weak_input_validation,produce_i0,,"tainted loop bound size2 writes into str (1000 bytes) without checking size2 <= 1000 (TA-private buffer overflow)
tainted loop bound size2 writes str[1000] without checking size2<=1000 (overflow via per-byte writes).",for (int i = 0; i < size2; i++) { str[i] = ((char *)buf2)[i]; }
ta,"VULN-0024, RISK-0032",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,227,weak_input_validation,"TEE_MemMove, produce_i0",Potential overflow of 1000-byte dst str by REE-tainted size3 (check occurs after copy).,"TEE_MemMove copies size3 bytes (REE-controlled) into str (1000 bytes) before any effective bounds check (overflow if size3 > 1000)
call-site binding: dst argument 'str' is TA-private buffer at this call site
call-site binding: src argument 'buf3' aliases REE-visible shared memory at this call site
copy length 'size3' (REE-controlled) may exceed destination capacity (str is 1000 bytes) with no effective pre-check on this path","TA_InvokeCommandEntryPoint -> input -> produce_i0 -> TEE_MemMove
TEE_MemMove(str, buf3, size3);"
ta,RISK-0033,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,231,weak_input_validation,produce_i0,,"tainted value a used in str index arithmetic (a-3) without bounds checks (possible OOB read in TA-private buffer)
tainted a used in str[a-3] index arithmetic without bounds check (possible OOB read).",char c = str[a - 3];
ta,"VULN-0025, RISK-0034",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,238,weak_input_validation,"TEE_MemMove, produce_i0",Potential overflow of 1000-byte dst str by REE-tainted size2 (no pre-copy upper bound).,"TEE_MemMove copies size2 bytes (REE-controlled) into str (1000 bytes) without checking size2 <= 1000 (TA-private overflow); later check enforces size2>=1000, not <=1000
call-site binding: dst argument 'str' is TA-private buffer at this call site
call-site binding: src argument 'buf2' aliases REE-visible shared memory at this call site
copy length 'size2' (REE-controlled) may exceed destination capacity (str is 1000 bytes) with no effective pre-check on this path","TA_InvokeCommandEntryPoint -> input -> produce_i0 -> TEE_MemMove
TEE_MemMove(str, buf2, size2);"
ta,"VULN-0026, RISK-0035",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,239,weak_input_validation,"TEE_MemMove, produce_i0",Potential overflow of 1000-byte dst str by REE-tainted size3 (no pre-copy upper bound).,"call-site binding: dst argument 'str' is TA-private buffer at this call site
call-site binding: src argument 'buf3' aliases REE-visible shared memory at this call site
copy length 'size3' (REE-controlled) may exceed destination capacity (str is 1000 bytes) with no effective pre-check on this path","TA_InvokeCommandEntryPoint -> input -> produce_i0 -> TEE_MemMove
TEE_MemMove(str, buf3, size3);"
ta,RISK-0036,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,246,,TEE_MemMove,,"call-site binding: dst argument 'buf2' aliases REE-visible shared memory at this call site
call-site binding: src argument 'str' is TA-private buffer at this call site
fixed-length write (1000) into REE-visible buffer may exceed its provided size2 unless caller ensured size2>=1000","TEE_MemMove(buf2, str, 1000);"
ta,RISK-0037,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,283,weak_input_validation,input,,tainted allocation size from REE (params[0].value.a) used in TEE_Malloc without upper/lower bound checks (DoS/overflow risk depending on allocator semantics),"int *arr_a = TEE_Malloc(params[0].value.a, 0);"
ta,RISK-0038,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,285,weak_input_validation,input,,"tainted index from REE (params[0].value.a) writes into fixed stack array tmp_arr[20] with no bounds check (OOB write in TA private memory)
REE-tainted index params[0].value.a writes into tmp_arr[20] without bounds check (TA memory corruption risk).
REE-tainted index params[0].value.a writes into fixed stack array tmp_arr[20] without bounds check (OOB write).",tmp_arr[params[0].value.a] = 43;
ta,RISK-0039,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,286,weak_input_validation,input,,"tainted loop bound from REE (params[2].memref.size) used to write into str (allocated 1000 bytes) without checking memref.size <= 1000 (potential overflow of TA-private buffer)
REE-tainted loop bound params[2].memref.size writes into str[1000] without bounds check (potential overflow) via per-byte copy, independent of sink lines.","for (int i = 0; i < params[2].memref.size; i++) str[i] = ((char*)params[2].memref.buffer)[i];
for (int i = 0; i < params[2].memref.size; i++) { str[i] = ((char *)params[2].memref.buffer)[i]; }"
ta,"VULN-0027, RISK-0040",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,290,weak_input_validation,"TEE_MemMove, input",copy_len=params[3].memref.size (tainted) can exceed dest str size (1000).,"TEE_MemMove writes params[3].memref.size bytes (REE-controlled) into str (1000 bytes) without bounds check (TA-private overflow)
call-site binding: dst argument 'str' is TA-private buffer at this call site
call-site binding: src argument params[3].memref.buffer aliases REE-visible shared memory at this call site
copy length params[3].memref.size (REE-controlled) may exceed destination capacity (str is 1000 bytes) without effective pre-check
call-site binding: TEE_MemMove(dest= str) where dest points to TA-private buffer at this site
call-site binding: TEE_MemMove(src= params[3].memref.buffer) where src aliases REE-visible shared memory","TA_InvokeCommandEntryPoint -> input -> TEE_MemMove
TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size);"
ta,"VULN-0028, RISK-0041",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,291,shared_memory_overwrite,"TEE_MemMove, input","copy_len=1000 may exceed dst_sz=params[2].memref.size (tainted), overwriting REE-visible buffer.","call-site binding: dest argument aliases REE-visible shared buffer (params[2].memref.buffer), so raw copy writes TA data into Normal World memory
writes fixed 1000 bytes from TA-private str into REE-visible params[2].memref.buffer without verifying params[2].memref.size >= 1000 (may overwrite shared buffer)
fixed 1000-byte write into REE-visible params[2].memref.buffer without verifying params[2].memref.size >= 1000 (shared buffer overwrite risk).
call-site binding: dst argument params[2].memref.buffer aliases REE-visible shared memory at this call site
call-site binding: src argument 'str' is TA-private buffer at this call site
fixed-length write (1000) into REE-visible buffer may exceed provided params[2].memref.size without a check on this path
call-site binding: TEE_MemMove(dest= params[2].memref.buffer) where dest aliases REE-visible shared memory
call-site binding: TEE_MemMove(src= str) where src points to TA-private buffer at this site","TA_InvokeCommandEntryPoint -> input -> TEE_MemMove
TEE_MemMove(params[2].memref.buffer, str, 1000);"
ta,RISK-0042,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,293,weak_input_validation,input,,"tainted size from REE used in index arithmetic (params[3].memref.size - 3) without checking size>=3 (possible underflow/OOB read)
Index uses params[3].memref.size-3 without checking size>=3 (possible underflow/OOB read).","((char*)params[3].memref.buffer)[params[3].memref.size - 3]
char c = ((char *)params[3].memref.buffer)[params[3].memref.size - 3];"
ta,RISK-0043,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,295,weak_input_validation,input,,tainted value params[0].value.a used in str index arithmetic (a-3) and (30-a) without bounds checks (possible OOB read in TA-private str),c = str[params[0].value.a - 3]; c = str[30 - params[0].value.a];
ta,"VULN-0029, RISK-0044",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,306,weak_input_validation,"TEE_MemMove, input",copy_len=params[2].memref.size (tainted) can exceed dest str size (1000).,"TEE_MemMove copies params[2].memref.size bytes (REE-controlled) into str (1000 bytes) without bounds check (TA-private overflow)
call-site binding: TEE_MemMove(dest= str) where dest points to TA-private buffer at this site
call-site binding: TEE_MemMove(src= params[2].memref.buffer) where src aliases REE-visible shared memory","TA_InvokeCommandEntryPoint -> input -> TEE_MemMove
TEE_MemMove(str, params[2].memref.buffer, params[2].memref.size);"
ta,"VULN-0030, RISK-0045",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,307,weak_input_validation,"TEE_MemMove, input",copy_len=params[3].memref.size (tainted) can exceed dest str size (1000).,"call-site binding: TEE_MemMove(dest= str) where dest points to TA-private buffer at this site
call-site binding: TEE_MemMove(src= params[3].memref.buffer) where src aliases REE-visible shared memory","TA_InvokeCommandEntryPoint -> input -> TEE_MemMove
TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size);"
ta,"VULN-0031, RISK-0046",Vulnerability/Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,309,shared_memory_overwrite,"TEE_MemMove, input","copy_len=1000 may exceed dst_sz=params[2].memref.size (tainted), overwriting REE-visible buffer.","writes fixed 1000 bytes into REE-visible params[2].memref.buffer again without verifying params[2].memref.size >= 1000 (may overwrite shared buffer)
repeated fixed 1000-byte write into REE-visible params[2].memref.buffer without verifying params[2].memref.size >= 1000 (shared buffer overwrite risk).
call-site binding: TEE_MemMove(dest= params[2].memref.buffer) where dest aliases REE-visible shared memory
call-site binding: TEE_MemMove(src= str) where src points to TA-private buffer at this site","TA_InvokeCommandEntryPoint -> input -> TEE_MemMove
TEE_MemMove(params[2].memref.buffer, str, 1000);"
ta,RISK-0047,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,334,weak_input_validation,produce_s,,"strcmp() on buf is unbounded by 'size'; if shared buffer is not NUL-terminated within 'size', read may extend past intended bounds
strcmp() treats REE-shared buf as a NUL-terminated C-string without enforcing that NUL occurs within the provided length.","if (strcmp(""123456"", buf) == 0)"
ta,RISK-0048,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,340,weak_input_validation,produce_s,,"TEE_MemCompare(buf, ..., size) uses REE-tainted 'size' to read from REE-visible buffer; no local check that 'size' is valid for the pointed-to shared region","if (!TEE_MemCompare(buf, ""123456"", size))"
ta,RISK-0049,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,350,weak_input_validation,"TEE_MemMove, produce_s",,"call-site binding: TEE_MemMove(dest= str) where dest is a TA-private stack buffer at this site
call-site binding: TEE_MemMove(src= buf) origin region unclear at this hop (could alias REE-visible memory depending on caller)
TEE_MemMove(str, buf, size) reads 'size' bytes from REE-visible buf; although dest is bounded (<=1000), there is no local validation that 'buf' is readable for 'size'
call-site binding: dest argument 'str' is a TEE-private stack buffer at this call-site; passed as destination to TEE_MemMove
call-site binding: src argument 'buf' aliases REE-visible shared memory (from params[0].memref.buffer) at this call-site","TEE_MemMove(str, buf, size);"
ta,RISK-0050,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,357,,produce_s3,,alias binding: local pointer buf now points to params[0].memref.buffer (typically REE-visible shared memory),void *buf = params[0].memref.buffer;
ta,RISK-0051,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,359,weak_input_validation,produce_s3,,"strcmp() on buf may read past params[0].memref.size if REE-shared buffer is not NUL-terminated within bounds
C-string compare on REE-shared buffer uses unbounded reads (no NUL-termination guarantee within sz).","if (strcmp(""123456"", buf) == 0)"
ta,RISK-0052,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,384,weak_input_validation,produce_s3,,"strcmp(params[0].memref.buffer, ...) treats shared buffer as C-string without verifying NUL termination within params[0].memref.size
strcmp on params[0].memref.buffer treats shared memory as NUL-terminated string without bounding by memref.size.","if (!strcmp(params[0].memref.buffer, ""123456""))"
ta,RISK-0053,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,389,weak_input_validation,produce_s3,,"strcmp(""123456"", params[0].memref.buffer) reads shared buffer as C-string; no bound based on params[0].memref.size","if (!strcmp(""123456"", params[0].memref.buffer))"
ta,RISK-0054,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,393,weak_input_validation,produce_s3,,"strcmp(buf, ...) treats REE-shared buffer as unbounded C-string; size sz is not used to bound reads","if (!strcmp(buf, ""123456""))"
ta,RISK-0055,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,401,,TEE_MemMove,,"call-site binding: TEE_MemMove(dest= str) where dest is a TA-private stack buffer at this site
call-site binding: TEE_MemMove(src= params[0].memref.buffer) where src aliases REE-visible shared memory
call-site binding: dest argument 'str' is a TEE-private stack buffer at this call-site; passed as destination to TEE_MemMove
call-site binding: src argument params[0].memref.buffer is REE-visible shared memory at this call-site
call-site binding: dst argument is local stack buffer 'str[1000]' (TEE-private) passed to TEE_MemMove
call-site binding: src argument params[0].memref.buffer is REE-visible shared memory copied into TEE-private dst","TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size);"
ta,RISK-0056,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,422,,shared_memory,,alias binding: local pointer buf now points to params[0].memref.buffer (typically REE-visible shared memory),void *buf = params[0].memref.buffer;
ta,RISK-0057,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,425,weak_input_validation,shared_memory,,"strcmp() on buf may read past params[0].memref.size if the shared buffer is not NUL-terminated within bounds (size not enforced for C-string use)
strcmp() reads from REE-shared memref without bounding by memref.size, risking out-of-bounds read if not NUL-terminated in-range.
strcmp() reads buf as a C-string without enforcing NUL termination within params[0].memref.size (possible over-read from shared buffer).","if (strcmp(""123456"", buf) == 0)"
ta,RISK-0058,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,432,weak_input_validation,shared_memory,,"strcmp() on buf again assumes NUL-terminated string; shared buffer length (sz) is not used to bound the read
strcmp() again treats buf as NUL-terminated while sz is not used to bound the read (possible over-read).","if (strcmp(""123456"", buf))"
ta,RISK-0059,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,485,weak_input_validation,TEE_MemMove,,"call-site binding: TEE_MemMove(dest= str) where dest is a TA-private buffer at this site
call-site binding: TEE_MemMove(src= params[0].memref.buffer) where src aliases REE-visible shared memory
call-site binding: dest argument 'str' is a TEE-private stack buffer at this call-site; passed as destination to TEE_MemMove
call-site binding: src argument params[0].memref.buffer is REE-visible shared memory at this call-site
call-site binding: dst argument is local stack buffer 'str[1000]' (TEE-private) passed to TEE_MemMove
call-site binding: src argument params[0].memref.buffer is REE-visible shared memory copied into TEE-private dst
call-site binding: dst argument aliases local stack buffer 'str' (TEE-private) at this call-site
call-site binding: src argument aliases params[0].memref.buffer (REE-visible shared memory) at this call-site
copy length is REE-controlled (params[0].memref.size); safety depends on prior check coupling it to actual dst capacity (stack buffer size) at the call-site","TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size);"
ta,RISK-0060,Structural Risk,/workspace/benchmark/bad-partitioning/ta/entry.c,506,weak_input_validation,TA_InvokeCommandEntryPoint,,no local validation that param_types matches expected layout before dispatching to command handlers; handlers may assume specific memref/value types,"switch (cmd_id) { ... return <handler>(param_types, params); }"