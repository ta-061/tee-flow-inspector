{
  "analysis_date": "2025-11-13T16:43:54.302218",
  "analysis_time_seconds": 793.4321475028992,
  "analysis_time_formatted": "13.2 minutes",
  "llm_provider": "openai",
  "analysis_mode": "hybrid",
  "rag_enabled": false,
  "statistics": {
    "total_flows_analyzed": 14,
    "flows_with_vulnerabilities": 14,
    "total_vulnerability_lines": 35,
    "total_structural_risk_lines": 61,
    "total_detections_before_consolidation": 154,
    "total_lines_after_consolidation": 96,
    "consolidation_rate": "37.7%",
    "severity_distribution": {
      "critical": 26,
      "high": 9,
      "medium": 0,
      "low": 0
    },
    "cwe_distribution": {
      "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow)": 1,
      "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)": 11,
      "CWE-120": 5,
      "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)": 6,
      "CWE-120 (Buffer Overflow) / CWE-125 (Out-of-bounds Read)": 2,
      "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow) / CWE-125 (Out-of-bounds Read)": 4,
      "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)": 5,
      "CWE-120 (Buffer Overflow) / CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)": 1
    },
    "rule_distribution": {
      "shared_memory_overwrite": 32,
      "other": 55,
      "weak_input_validation": 32
    },
    "execution_time_seconds": 793.4321475028992,
    "llm_calls": 40,
    "cache_hits": 13,
    "cache_partial_hits": 13,
    "cache_misses": 1,
    "cache_hit_rate": "92.9%",
    "token_usage": {},
    "retries": 1,
    "retry_successes": 1
  },
  "total_vulnerability_lines": 35,
  "vulnerabilities": [
    {
      "vulnerability_id": "VULN-0001",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 116,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow)",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-visible buffer params[1].memref.buffer written with TA-private key2; copy length strlen(key2) not validated against REE-tainted params[1].memref.size, enabling buffer overflow and key disclosure."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param params[1].memref.size (untrusted shared buffer size)",
          "propagation_path": [
            "params (REE-visible) @ TA_InvokeCommandEntryPoint:502",
            "params -> produce() @ entry.c:508",
            "params -> produce_2() @ entry.c:141",
            "params[1].memref.buffer (REE-visible destination) @ produce_2:116",
            "key2 (TA-private, 1000 bytes) @ produce_2:112",
            "strlen(key2) (unbounded, up to 1000) @ produce_2:116"
          ],
          "sink": "TEE_MemMove(params[1].memref.buffer, key2, strlen(key2)) @ produce_2:116"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "REE supplies a TEE_Param with MEMREF_INOUT type at params[1]",
            "REE allocates a small shared buffer (e.g., < 1000 bytes) for params[1].memref.buffer",
            "REE sets params[1].memref.size to a value smaller than strlen(key2)",
            "TA invokes produce_2() without validating params[1].memref.size"
          ],
          "attack_scenario": "REE allocates a 10-byte shared buffer and passes it as params[1].memref.buffer with params[1].memref.size=10. TA's produce_2() copies strlen(key2)=6 bytes of the private key into the 10-byte buffer via TEE_MemMove. If key2 is longer or if subsequent snprintf calls at lines 117, 121, 122, 125, 126 also write without bounds checking, the buffer overflows into adjacent shared memory, leaking TA-private data (key2, vi) to REE or corrupting REE-visible state.",
          "impact": "Information disclosure of TA-private cryptographic material (key2, vi) to the untrusted REE; potential buffer overflow in shared memory leading to memory corruption and privilege escalation."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_2:116",
          "recommendation": "Validate strlen(key2) <= params[1].memref.size before calling TEE_MemMove; return error if size is insufficient."
        },
        {
          "type": "bounds_check",
          "location": "produce_2:117",
          "recommendation": "Validate params[2].memref.size before snprintf; ensure buffer is large enough for formatted output."
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Enforce strict param_types validation; reject MEMREF_INOUT if caller is untrusted or if buffer sizes are suspiciously small."
        },
        {
          "type": "encryption",
          "location": "produce_2:112-126",
          "recommendation": "Do not copy TA-private keys (key2, vi) into REE-visible shared buffers; use encrypted channels or keep sensitive data in TEE-private memory only."
        }
      ],
      "decision_rationales": [
        "Line 116 is vulnerable because: (1) destination params[1].memref.buffer is REE-visible (MEMREF_INOUT), (2) source key2 is TA-private sensitive data (cryptographic key), (3) copy length strlen(key2) is not validated against the REE-tainted size params[1].memref.size, (4) no effective bounds check exists on this path, and (5) the mechanism is CWE-120/121 (buffer copy without size validation). The taint flow is clear: REE-originated params[1].memref.size is untrusted; TA uses strlen(key2) as the copy length without checking if it fits in the REE-supplied buffer. This enables both buffer overflow (memory safety) and information disclosure (TA-private key material leaks to REE)."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0002",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 117,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key2 written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:176 (passed to snprintf)",
            "params[2].memref.size @ produce:137 (passed to snprintf)",
            "params[2].memref.size @ produce_2:117 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "No runtime bounds validation on memref.size before use in snprintf"
          ],
          "attack_scenario": "Attacker invokes TA with TA_HELLO_WORLD_CMD_OUTPUT, providing a large memref.size (e.g., 0xFFFFFFFF) and a small buffer. snprintf writes TA-private key material beyond the allocated buffer boundary into adjacent REE-visible memory, causing buffer overflow and information disclosure.",
          "impact": "Out-of-bounds write into REE-visible shared memory; TA-private cryptographic keys and sensitive data leak to REE; potential for heap corruption and privilege escalation"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_2:117",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; reject oversized requests"
        },
        {
          "type": "bounds_check",
          "location": "produce:137",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "bounds_check",
          "location": "output:176",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size or memref.buffer; add explicit size range checks"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit the same vulnerability pattern: REE-tainted memref.size is used as the size bound in snprintf without any validation. The type_validation sanitizer at output:168 checks param_types but does NOT validate memref.size or memref.buffer fields. snprintf will write up to size bytes into the destination buffer; if size is attacker-controlled and larger than the actual buffer, a buffer overflow occurs. The TA-private data (key, vi) is written to REE-visible shared memory, enabling information disclosure. This is a critical shared_memory_overwrite vulnerability."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0003",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 121,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key2 and vi written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:176 (passed to snprintf)",
            "params[2].memref.size @ produce:137 (passed to snprintf)",
            "params[2].memref.size @ produce_2:117 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "No runtime bounds validation on memref.size before use in snprintf"
          ],
          "attack_scenario": "Attacker invokes TA with TA_HELLO_WORLD_CMD_OUTPUT, providing a large memref.size (e.g., 0xFFFFFFFF) and a small buffer. snprintf writes TA-private key material beyond the allocated buffer boundary into adjacent REE-visible memory, causing buffer overflow and information disclosure.",
          "impact": "Out-of-bounds write into REE-visible shared memory; TA-private cryptographic keys and sensitive data leak to REE; potential for heap corruption and privilege escalation"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_2:117",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; reject oversized requests"
        },
        {
          "type": "bounds_check",
          "location": "produce:137",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "bounds_check",
          "location": "output:176",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size or memref.buffer; add explicit size range checks"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit the same vulnerability pattern: REE-tainted memref.size is used as the size bound in snprintf without any validation. The type_validation sanitizer at output:168 checks param_types but does NOT validate memref.size or memref.buffer fields. snprintf will write up to size bytes into the destination buffer; if size is attacker-controlled and larger than the actual buffer, a buffer overflow occurs. The TA-private data (key, vi) is written to REE-visible shared memory, enabling information disclosure. This is a critical shared_memory_overwrite vulnerability."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0004",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 122,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key2, vi, and v written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:176 (passed to snprintf)",
            "params[2].memref.size @ produce:137 (passed to snprintf)",
            "params[2].memref.size @ produce_2:117 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "No runtime bounds validation on memref.size before use in snprintf"
          ],
          "attack_scenario": "Attacker invokes TA with TA_HELLO_WORLD_CMD_OUTPUT, providing a large memref.size (e.g., 0xFFFFFFFF) and a small buffer. snprintf writes TA-private key material beyond the allocated buffer boundary into adjacent REE-visible memory, causing buffer overflow and information disclosure.",
          "impact": "Out-of-bounds write into REE-visible shared memory; TA-private cryptographic keys and sensitive data leak to REE; potential for heap corruption and privilege escalation"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_2:117",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; reject oversized requests"
        },
        {
          "type": "bounds_check",
          "location": "produce:137",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "bounds_check",
          "location": "output:176",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size or memref.buffer; add explicit size range checks"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit the same vulnerability pattern: REE-tainted memref.size is used as the size bound in snprintf without any validation. The type_validation sanitizer at output:168 checks param_types but does NOT validate memref.size or memref.buffer fields. snprintf will write up to size bytes into the destination buffer; if size is attacker-controlled and larger than the actual buffer, a buffer overflow occurs. The TA-private data (key, vi) is written to REE-visible shared memory, enabling information disclosure. This is a critical shared_memory_overwrite vulnerability."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0005",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 125,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key2 (post-encryption) written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:176 (passed to snprintf)",
            "params[2].memref.size @ produce:137 (passed to snprintf)",
            "params[2].memref.size @ produce_2:117 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "No runtime bounds validation on memref.size before use in snprintf"
          ],
          "attack_scenario": "Attacker invokes TA with TA_HELLO_WORLD_CMD_OUTPUT, providing a large memref.size (e.g., 0xFFFFFFFF) and a small buffer. snprintf writes TA-private key material beyond the allocated buffer boundary into adjacent REE-visible memory, causing buffer overflow and information disclosure.",
          "impact": "Out-of-bounds write into REE-visible shared memory; TA-private cryptographic keys and sensitive data leak to REE; potential for heap corruption and privilege escalation"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_2:117",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; reject oversized requests"
        },
        {
          "type": "bounds_check",
          "location": "produce:137",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "bounds_check",
          "location": "output:176",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size or memref.buffer; add explicit size range checks"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit the same vulnerability pattern: REE-tainted memref.size is used as the size bound in snprintf without any validation. The type_validation sanitizer at output:168 checks param_types but does NOT validate memref.size or memref.buffer fields. snprintf will write up to size bytes into the destination buffer; if size is attacker-controlled and larger than the actual buffer, a buffer overflow occurs. The TA-private data (key, vi) is written to REE-visible shared memory, enabling information disclosure. This is a critical shared_memory_overwrite vulnerability."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0006",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 126,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce_2"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key2 and vi (post-encryption) written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "produce_2",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:176 (passed to snprintf)",
            "params[2].memref.size @ produce:137 (passed to snprintf)",
            "params[2].memref.size @ produce_2:117 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "No runtime bounds validation on memref.size before use in snprintf"
          ],
          "attack_scenario": "Attacker invokes TA with TA_HELLO_WORLD_CMD_OUTPUT, providing a large memref.size (e.g., 0xFFFFFFFF) and a small buffer. snprintf writes TA-private key material beyond the allocated buffer boundary into adjacent REE-visible memory, causing buffer overflow and information disclosure.",
          "impact": "Out-of-bounds write into REE-visible shared memory; TA-private cryptographic keys and sensitive data leak to REE; potential for heap corruption and privilege escalation"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_2:117",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; reject oversized requests"
        },
        {
          "type": "bounds_check",
          "location": "produce:137",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "bounds_check",
          "location": "output:176",
          "recommendation": "Validate params[2].memref.size before use in snprintf; enforce upper limit"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size or memref.buffer; add explicit size range checks"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit the same vulnerability pattern: REE-tainted memref.size is used as the size bound in snprintf without any validation. The type_validation sanitizer at output:168 checks param_types but does NOT validate memref.size or memref.buffer fields. snprintf will write up to size bytes into the destination buffer; if size is attacker-controlled and larger than the actual buffer, a buffer overflow occurs. The TA-private data (key, vi) is written to REE-visible shared memory, enabling information disclosure. This is a critical shared_memory_overwrite vulnerability."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0007",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 136,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted destination size params[1].memref.size used without validation; copy length strlen(key1) not checked against destination capacity."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-tainted memref size params[1].memref.size from TEE_Param (untrusted)",
          "propagation_path": [
            "params[1].memref.size (REE-visible) @ entry.c:159",
            "strlen(key1) (TA-private, fixed 6 bytes) @ entry.c:136",
            "TEE_MemMove(params[1].memref.buffer, key1, strlen(key1)) @ entry.c:136"
          ],
          "sink": "REE-visible shared buffer params[1].memref.buffer written without bounds validation"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "REE supplies params[1].memref.size < strlen(key1) (e.g., size=2 bytes)",
            "TA calls produce() with untrusted params array",
            "No runtime bounds check on copy length vs destination capacity"
          ],
          "attack_scenario": "Attacker in REE sets params[1].memref.size to a small value (e.g., 2 bytes) while params[1].memref.buffer points to a 1000-byte shared buffer. TEE_MemMove copies strlen(key1)=6 bytes into the 2-byte destination, overflowing the shared buffer and corrupting adjacent shared memory or enabling information disclosure.",
          "impact": "Buffer overflow in shared memory; potential corruption of adjacent REE-visible data structures, denial of service, or information disclosure if overflow reaches sensitive TA state."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce:136",
          "recommendation": "Add explicit check: if (strlen(key1) > params[1].memref.size) return TEE_ERROR_SHORT_BUFFER; before TEE_MemMove."
        },
        {
          "type": "mem_access_check",
          "location": "produce:136",
          "recommendation": "Validate params[1].memref.size is non-zero and sufficient for the intended copy; use min(strlen(key1), params[1].memref.size) as copy length."
        }
      ],
      "decision_rationales": [
        "Line 136 exhibits a classic buffer overflow vulnerability (CWE-120). The TA copies a fixed-size TA-private buffer (key1, 6 bytes) into a REE-visible shared buffer using strlen(key1) as the copy length, but the destination size (params[1].memref.size) is REE-tainted and unchecked. An attacker in the REE can set params[1].memref.size to any value (including 0 or a small value like 2), causing TEE_MemMove to write beyond the intended destination boundary. No effective sanitizer (bounds check, type validation, or range check) is present on this code path. The vulnerability is memory-safety class (CWE-120 buffer overflow), which takes precedence over any information-disclosure concern."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0008",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 137,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, user-controlled)",
          "propagation_path": [
            "params[2].memref.size (REE-visible) @ entry.c:159",
            "params[2].memref.size passed to snprintf @ entry.c:137,143,144,147,148",
            "snprintf uses untrusted size as buffer bound without validation"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "TA invokes produce() via TA_InvokeCommandEntryPoint with malicious param_types and params"
          ],
          "attack_scenario": "Attacker sets params[2].memref.size to a very large value (e.g., 0xFFFFFFFF) and provides a small shared buffer. snprintf writes beyond the buffer boundary, corrupting adjacent REE or TA memory. Attacker can leak TA secrets or achieve code execution.",
          "impact": "Buffer overflow in shared memory; potential information disclosure of TA-private secrets (key, vi); potential memory corruption and code execution; violation of TA confidentiality and integrity"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce:137,143,144,147,148",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; use TEE_MemMove with explicit length checks instead of snprintf"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size fields; add explicit size validation for all MEMREF parameters"
        },
        {
          "type": "mem_access_check",
          "location": "produce:136,137",
          "recommendation": "Verify params[1].memref.size and params[2].memref.size are within safe bounds before any write operation"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit a critical buffer overflow vulnerability. The root cause is that params[2].memref.size is REE-controlled and untrusted, yet used directly as the size argument to snprintf without any validation. An attacker can set this size to an arbitrarily large value, causing snprintf to write beyond the allocated buffer. This is a classic CWE-120 buffer overflow. The vulnerability is compounded by the fact that TA-private secrets (key, vi) are being written to REE-visible shared memory with an attacker-controlled bound, enabling both memory corruption and information disclosure."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0009",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 143,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key1 and vi written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, user-controlled)",
          "propagation_path": [
            "params[2].memref.size (REE-visible) @ entry.c:159",
            "params[2].memref.size passed to snprintf @ entry.c:137,143,144,147,148",
            "snprintf uses untrusted size as buffer bound without validation"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "TA invokes produce() via TA_InvokeCommandEntryPoint with malicious param_types and params"
          ],
          "attack_scenario": "Attacker sets params[2].memref.size to a very large value (e.g., 0xFFFFFFFF) and provides a small shared buffer. snprintf writes beyond the buffer boundary, corrupting adjacent REE or TA memory. Attacker can leak TA secrets or achieve code execution.",
          "impact": "Buffer overflow in shared memory; potential information disclosure of TA-private secrets (key, vi); potential memory corruption and code execution; violation of TA confidentiality and integrity"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce:137,143,144,147,148",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; use TEE_MemMove with explicit length checks instead of snprintf"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size fields; add explicit size validation for all MEMREF parameters"
        },
        {
          "type": "mem_access_check",
          "location": "produce:136,137",
          "recommendation": "Verify params[1].memref.size and params[2].memref.size are within safe bounds before any write operation"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit a critical buffer overflow vulnerability. The root cause is that params[2].memref.size is REE-controlled and untrusted, yet used directly as the size argument to snprintf without any validation. An attacker can set this size to an arbitrarily large value, causing snprintf to write beyond the allocated buffer. This is a classic CWE-120 buffer overflow. The vulnerability is compounded by the fact that TA-private secrets (key, vi) are being written to REE-visible shared memory with an attacker-controlled bound, enabling both memory corruption and information disclosure."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0010",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 144,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key1, vi, and v written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, user-controlled)",
          "propagation_path": [
            "params[2].memref.size (REE-visible) @ entry.c:159",
            "params[2].memref.size passed to snprintf @ entry.c:137,143,144,147,148",
            "snprintf uses untrusted size as buffer bound without validation"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "TA invokes produce() via TA_InvokeCommandEntryPoint with malicious param_types and params"
          ],
          "attack_scenario": "Attacker sets params[2].memref.size to a very large value (e.g., 0xFFFFFFFF) and provides a small shared buffer. snprintf writes beyond the buffer boundary, corrupting adjacent REE or TA memory. Attacker can leak TA secrets or achieve code execution.",
          "impact": "Buffer overflow in shared memory; potential information disclosure of TA-private secrets (key, vi); potential memory corruption and code execution; violation of TA confidentiality and integrity"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce:137,143,144,147,148",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; use TEE_MemMove with explicit length checks instead of snprintf"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size fields; add explicit size validation for all MEMREF parameters"
        },
        {
          "type": "mem_access_check",
          "location": "produce:136,137",
          "recommendation": "Verify params[1].memref.size and params[2].memref.size are within safe bounds before any write operation"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit a critical buffer overflow vulnerability. The root cause is that params[2].memref.size is REE-controlled and untrusted, yet used directly as the size argument to snprintf without any validation. An attacker can set this size to an arbitrarily large value, causing snprintf to write beyond the allocated buffer. This is a classic CWE-120 buffer overflow. The vulnerability is compounded by the fact that TA-private secrets (key, vi) are being written to REE-visible shared memory with an attacker-controlled bound, enabling both memory corruption and information disclosure."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0011",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 147,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key1 (post-encryption) written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, user-controlled)",
          "propagation_path": [
            "params[2].memref.size (REE-visible) @ entry.c:159",
            "params[2].memref.size passed to snprintf @ entry.c:137,143,144,147,148",
            "snprintf uses untrusted size as buffer bound without validation"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "TA invokes produce() via TA_InvokeCommandEntryPoint with malicious param_types and params"
          ],
          "attack_scenario": "Attacker sets params[2].memref.size to a very large value (e.g., 0xFFFFFFFF) and provides a small shared buffer. snprintf writes beyond the buffer boundary, corrupting adjacent REE or TA memory. Attacker can leak TA secrets or achieve code execution.",
          "impact": "Buffer overflow in shared memory; potential information disclosure of TA-private secrets (key, vi); potential memory corruption and code execution; violation of TA confidentiality and integrity"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce:137,143,144,147,148",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; use TEE_MemMove with explicit length checks instead of snprintf"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size fields; add explicit size validation for all MEMREF parameters"
        },
        {
          "type": "mem_access_check",
          "location": "produce:136,137",
          "recommendation": "Verify params[1].memref.size and params[2].memref.size are within safe bounds before any write operation"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit a critical buffer overflow vulnerability. The root cause is that params[2].memref.size is REE-controlled and untrusted, yet used directly as the size argument to snprintf without any validation. An attacker can set this size to an arbitrarily large value, causing snprintf to write beyond the allocated buffer. This is a classic CWE-120 buffer overflow. The vulnerability is compounded by the fact that TA-private secrets (key, vi) are being written to REE-visible shared memory with an attacker-controlled bound, enabling both memory corruption and information disclosure."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0012",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 148,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted size params[2].memref.size used as snprintf bound; TA-private key1 and vi (post-encryption) written to REE-visible buffer without bounds validation"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size (untrusted, user-controlled)",
          "propagation_path": [
            "params[2].memref.size (REE-visible) @ entry.c:159",
            "params[2].memref.size passed to snprintf @ entry.c:137,143,144,147,148",
            "snprintf uses untrusted size as buffer bound without validation"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes TA-private data to REE-visible buffer with REE-controlled size"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (REE-visible shared memory)",
            "TA invokes produce() via TA_InvokeCommandEntryPoint with malicious param_types and params"
          ],
          "attack_scenario": "Attacker sets params[2].memref.size to a very large value (e.g., 0xFFFFFFFF) and provides a small shared buffer. snprintf writes beyond the buffer boundary, corrupting adjacent REE or TA memory. Attacker can leak TA secrets or achieve code execution.",
          "impact": "Buffer overflow in shared memory; potential information disclosure of TA-private secrets (key, vi); potential memory corruption and code execution; violation of TA confidentiality and integrity"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce:137,143,144,147,148",
          "recommendation": "Validate params[2].memref.size against a maximum safe bound (e.g., 1024) before passing to snprintf; use TEE_MemMove with explicit length checks instead of snprintf"
        },
        {
          "type": "access_control",
          "location": "output:168",
          "recommendation": "Type validation at line 168 checks param_types but does NOT validate memref.size fields; add explicit size validation for all MEMREF parameters"
        },
        {
          "type": "mem_access_check",
          "location": "produce:136,137",
          "recommendation": "Verify params[1].memref.size and params[2].memref.size are within safe bounds before any write operation"
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit a critical buffer overflow vulnerability. The root cause is that params[2].memref.size is REE-controlled and untrusted, yet used directly as the size argument to snprintf without any validation. An attacker can set this size to an arbitrarily large value, causing snprintf to write beyond the allocated buffer. This is a classic CWE-120 buffer overflow. The vulnerability is compounded by the fact that TA-private secrets (key, vi) are being written to REE-visible shared memory with an attacker-controlled bound, enabling both memory corruption and information disclosure."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0013",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 154,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)",
      "functions": [
        "produce_3"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-787 (Out-of-bounds Write)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "Buffer overflow: strlen(key)=6 copied into REE-visible buffer with untrusted size; no bounds check"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce_3",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated params[1].memref.buffer and params[1].memref.size (untrusted shared memory)",
          "propagation_path": [
            "params[1].memref.buffer (REE-visible) -> buf parameter in produce_3 @ /workspace/benchmark/bad-partitioning/ta/entry.c:182",
            "params[1].memref.size (REE-tainted) -> size parameter in produce_3 @ /workspace/benchmark/bad-partitioning/ta/entry.c:182",
            "buf (REE-visible alias) -> dest in TEE_MemMove @ /workspace/benchmark/bad-partitioning/ta/entry.c:154",
            "strlen(key) (TA-private, ~6 bytes) -> copy length in TEE_MemMove @ /workspace/benchmark/bad-partitioning/ta/entry.c:154"
          ],
          "sink": "TEE_MemMove(buf, key, strlen(key)) writes to REE-visible buffer without bounds check"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "REE provides a memref with size < strlen(key) (e.g., size=1)",
            "TA invokes output() command with malicious params[1].memref.size",
            "No runtime bounds validation in produce_3 or output"
          ],
          "attack_scenario": "Attacker in REE crafts a TEE_Param with params[1].memref.buffer pointing to a small shared buffer (e.g., 1 byte) and params[1].memref.size=1. TA calls produce_3(buf, 1), which then calls TEE_MemMove(buf, key, strlen(key)) where strlen(key)=6. TEE_MemMove copies 6 bytes into a 1-byte buffer, overflowing the shared memory region and potentially corrupting adjacent REE or TA state.",
          "impact": "Out-of-bounds write into shared memory; potential information disclosure (TA-private key leaked to REE), denial of service (crash), or privilege escalation if overflow corrupts critical TA state."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_3:154",
          "recommendation": "Add explicit check: if (strlen(key) > size) return error; before TEE_MemMove call"
        },
        {
          "type": "mem_access_check",
          "location": "produce_3:151-156",
          "recommendation": "Validate size parameter against known buffer bounds; reject untrusted size values"
        },
        {
          "type": "range_check",
          "location": "output:182",
          "recommendation": "Validate params[1].memref.size before passing to produce_3; enforce maximum size constraint"
        }
      ],
      "decision_rationales": [
        "Line 154 exhibits a classic buffer overflow vulnerability: a fixed-length copy (strlen(key)) into a buffer whose size is REE-tainted and unchecked. The destination is REE-visible shared memory (params[1].memref.buffer), the copy length is derived from TA-private data (key), but the buffer size bound comes from untrusted REE (params[1].memref.size). No sanitizer validates that strlen(key) <= size before the TEE_MemMove call. This satisfies CWE-120/787 criteria: out-of-bounds write due to insufficient bounds checking on a copy operation with untrusted size."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0014",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 155,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120",
      "functions": [
        "produce_3"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "snprintf writes TA-private key into REE-visible buffer using REE-tainted size as bound without validation; buffer overflow risk"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "produce_3",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated params[1].memref.size (untrusted size) and params[1].memref.buffer (REE-visible shared buffer) passed from output() to produce_3()",
          "propagation_path": [
            "params[1].memref.size (REE-tainted) @ /workspace/benchmark/bad-partitioning/ta/entry.c:182",
            "size parameter in produce_3() @ /workspace/benchmark/bad-partitioning/ta/entry.c:151",
            "snprintf(buf, size, ...) @ /workspace/benchmark/bad-partitioning/ta/entry.c:155"
          ],
          "sink": "snprintf at line 155 writes TA-private key into REE-visible buffer using untrusted size bound"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "REE can invoke TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_OUTPUT",
            "REE can set params[1].memref.size to an arbitrary value (e.g., 0, very large, or negative when cast)",
            "REE can provide a small or malicious memref.buffer"
          ],
          "attack_scenario": "REE sets params[1].memref.size to a value smaller than strlen(key) (6 bytes). snprintf writes key into the undersized buffer, causing heap overflow into adjacent REE-visible memory. Alternatively, REE sets size to 0, causing snprintf to write nothing or trigger undefined behavior.",
          "impact": "Buffer overflow in shared memory region; REE can corrupt adjacent heap structures, leak TA memory, or trigger denial of service. TA-private key data (key='123456') is written to REE-visible buffer without bounds validation."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_3:155",
          "recommendation": "Validate that size >= strlen(key) + 1 before calling snprintf, or use a fixed-size buffer and validate size against it"
        },
        {
          "type": "range_check",
          "location": "output:182",
          "recommendation": "Validate params[1].memref.size is within acceptable range (e.g., > 0 and <= MAX_SAFE_SIZE) before passing to produce_3()"
        },
        {
          "type": "mem_access_check",
          "location": "produce_3:154",
          "recommendation": "Add bounds check before TEE_MemMove: validate strlen(key) <= size"
        }
      ],
      "decision_rationales": [
        "Line 155 is vulnerable because: (1) size is REE-tainted and unchecked, (2) snprintf uses size as the buffer bound without validation, (3) the destination buffer is REE-visible (shared memory), (4) TA-private key data flows into the shared buffer, and (5) no effective sanitizer prevents the overflow. This is a classic CWE-120 buffer overflow via untrusted size parameter. The vulnerability is not mitigated by the param_types check at line 168, which only validates the type codes, not the actual memref.size values."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0015",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 175,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-visible destination params[1].memref.buffer written with TA-private key; copy length strlen(key) not validated against destination size, enabling buffer overflow."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param params[1].memref.buffer (untrusted shared memory buffer with unknown size)",
          "propagation_path": [
            "params[1].memref.buffer @ TA_InvokeCommandEntryPoint:502",
            "params[1].memref.buffer @ output:159",
            "TEE_MemMove(params[1].memref.buffer, key, strlen(key)) @ output:175"
          ],
          "sink": "TEE_MemMove writes TA-private key into REE-visible shared buffer without bounds validation"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[1].memref.size (REE-visible memref size field)",
            "Attacker can set params[1].memref.size to a value smaller than strlen(key) (6 bytes minimum)",
            "TA does not validate memref.size before TEE_MemMove"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_OUTPUT with params[1] pointing to a small shared buffer (e.g., 1 byte) and params[1].memref.size=1. The TA copies strlen(key)=6 bytes into the 1-byte buffer, overflowing into adjacent shared memory. Attacker reads the overflow to leak TA-private data or corrupts REE state.",
          "impact": "Buffer overflow in shared memory; information disclosure of TA-private key material; potential REE memory corruption or privilege escalation if overflow reaches critical REE structures."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "output:175",
          "recommendation": "Validate strlen(key) <= params[1].memref.size before TEE_MemMove; return error if violated."
        },
        {
          "type": "mem_access_check",
          "location": "output:158-194",
          "recommendation": "Implement systematic validation of all memref.size fields from params before use in copy operations."
        },
        {
          "type": "access_control",
          "location": "output:158",
          "recommendation": "Consider restricting memref.size to a known safe range or enforcing minimum buffer sizes at TA entry."
        }
      ],
      "decision_rationales": [
        "Line 175 exhibits a classic buffer overflow (CWE-120): a TA-private buffer (key, 1000 bytes) is copied into a REE-visible shared buffer (params[1].memref.buffer) using a TA-computed length (strlen(key)) without validating that length against the destination size (params[1].memref.size). The destination size is REE-tainted and unknown at the TA. The type_validation sanitizer at line 168 only checks param_types, not memref.size fields. No effective bounds check exists on the same path. This is a shared_memory_overwrite vulnerability with high severity because it allows an attacker to overflow a shared buffer and leak or corrupt TA-private data."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0016",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 176,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as snprintf bound; no validation; buffer overflow on shared memory."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size field (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:159 (passed to output function)",
            "params[2].memref.size @ output:176,184,185,189,190,191 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes to REE-visible shared buffer with untrusted size bound"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (shared memory region)",
            "No runtime bounds validation on params[2].memref.size against actual buffer capacity",
            "snprintf uses attacker-controlled size as the buffer length parameter"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_OUTPUT with crafted TEE_Param[2].memref.size set to a large value (e.g., 0xFFFFFFFF). The TA calls snprintf with this untrusted size, causing snprintf to write beyond the actual buffer boundary in shared memory, corrupting adjacent TA memory or REE memory.",
          "impact": "Buffer overflow in shared memory region; potential TA memory corruption, information disclosure of TA secrets (key, vi), denial of service, or privilege escalation if overflow reaches critical TA data structures."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "output:168-169",
          "recommendation": "Add explicit validation: if (params[2].memref.size > MAX_SAFE_SIZE || params[2].memref.size == 0) return TEE_ERROR_BAD_PARAMETERS; before any snprintf call."
        },
        {
          "type": "range_check",
          "location": "output:176,184,185,189,190,191",
          "recommendation": "Use safe snprintf wrapper that enforces maximum buffer size independent of REE-provided size parameter."
        },
        {
          "type": "mem_access_check",
          "location": "output:175",
          "recommendation": "Validate params[1].memref.size and params[2].memref.size before any memory operation; enforce upper bounds tied to TA-internal buffer sizes."
        }
      ],
      "decision_rationales": [
        "All six snprintf calls at lines 176, 184, 185, 189, 190, 191 are vulnerable because: (1) params[2].memref.size originates from REE (untrusted source), (2) it is used directly as the size bound in snprintf without any validation or sanitization, (3) the destination params[2].memref.buffer is a REE-visible shared buffer, (4) there is no effective bounds check on the same execution path (the type_validation at line 168 only validates param_types, not the memref.size values), and (5) snprintf will write up to the specified size, allowing an attacker to overflow the buffer. This is a classic shared-memory buffer overflow vulnerability (CWE-120/122)."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0017",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 184,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as snprintf bound; no validation; buffer overflow on shared memory."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size field (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:159 (passed to output function)",
            "params[2].memref.size @ output:176,184,185,189,190,191 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes to REE-visible shared buffer with untrusted size bound"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (shared memory region)",
            "No runtime bounds validation on params[2].memref.size against actual buffer capacity",
            "snprintf uses attacker-controlled size as the buffer length parameter"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_OUTPUT with crafted TEE_Param[2].memref.size set to a large value (e.g., 0xFFFFFFFF). The TA calls snprintf with this untrusted size, causing snprintf to write beyond the actual buffer boundary in shared memory, corrupting adjacent TA memory or REE memory.",
          "impact": "Buffer overflow in shared memory region; potential TA memory corruption, information disclosure of TA secrets (key, vi), denial of service, or privilege escalation if overflow reaches critical TA data structures."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "output:168-169",
          "recommendation": "Add explicit validation: if (params[2].memref.size > MAX_SAFE_SIZE || params[2].memref.size == 0) return TEE_ERROR_BAD_PARAMETERS; before any snprintf call."
        },
        {
          "type": "range_check",
          "location": "output:176,184,185,189,190,191",
          "recommendation": "Use safe snprintf wrapper that enforces maximum buffer size independent of REE-provided size parameter."
        },
        {
          "type": "mem_access_check",
          "location": "output:175",
          "recommendation": "Validate params[1].memref.size and params[2].memref.size before any memory operation; enforce upper bounds tied to TA-internal buffer sizes."
        }
      ],
      "decision_rationales": [
        "All six snprintf calls at lines 176, 184, 185, 189, 190, 191 are vulnerable because: (1) params[2].memref.size originates from REE (untrusted source), (2) it is used directly as the size bound in snprintf without any validation or sanitization, (3) the destination params[2].memref.buffer is a REE-visible shared buffer, (4) there is no effective bounds check on the same execution path (the type_validation at line 168 only validates param_types, not the memref.size values), and (5) snprintf will write up to the specified size, allowing an attacker to overflow the buffer. This is a classic shared-memory buffer overflow vulnerability (CWE-120/122)."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0018",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 185,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as snprintf bound; no validation; buffer overflow on shared memory."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size field (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:159 (passed to output function)",
            "params[2].memref.size @ output:176,184,185,189,190,191 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes to REE-visible shared buffer with untrusted size bound"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (shared memory region)",
            "No runtime bounds validation on params[2].memref.size against actual buffer capacity",
            "snprintf uses attacker-controlled size as the buffer length parameter"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_OUTPUT with crafted TEE_Param[2].memref.size set to a large value (e.g., 0xFFFFFFFF). The TA calls snprintf with this untrusted size, causing snprintf to write beyond the actual buffer boundary in shared memory, corrupting adjacent TA memory or REE memory.",
          "impact": "Buffer overflow in shared memory region; potential TA memory corruption, information disclosure of TA secrets (key, vi), denial of service, or privilege escalation if overflow reaches critical TA data structures."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "output:168-169",
          "recommendation": "Add explicit validation: if (params[2].memref.size > MAX_SAFE_SIZE || params[2].memref.size == 0) return TEE_ERROR_BAD_PARAMETERS; before any snprintf call."
        },
        {
          "type": "range_check",
          "location": "output:176,184,185,189,190,191",
          "recommendation": "Use safe snprintf wrapper that enforces maximum buffer size independent of REE-provided size parameter."
        },
        {
          "type": "mem_access_check",
          "location": "output:175",
          "recommendation": "Validate params[1].memref.size and params[2].memref.size before any memory operation; enforce upper bounds tied to TA-internal buffer sizes."
        }
      ],
      "decision_rationales": [
        "All six snprintf calls at lines 176, 184, 185, 189, 190, 191 are vulnerable because: (1) params[2].memref.size originates from REE (untrusted source), (2) it is used directly as the size bound in snprintf without any validation or sanitization, (3) the destination params[2].memref.buffer is a REE-visible shared buffer, (4) there is no effective bounds check on the same execution path (the type_validation at line 168 only validates param_types, not the memref.size values), and (5) snprintf will write up to the specified size, allowing an attacker to overflow the buffer. This is a classic shared-memory buffer overflow vulnerability (CWE-120/122)."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0019",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 189,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as snprintf bound; no validation; buffer overflow on shared memory."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size field (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:159 (passed to output function)",
            "params[2].memref.size @ output:176,184,185,189,190,191 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes to REE-visible shared buffer with untrusted size bound"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (shared memory region)",
            "No runtime bounds validation on params[2].memref.size against actual buffer capacity",
            "snprintf uses attacker-controlled size as the buffer length parameter"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_OUTPUT with crafted TEE_Param[2].memref.size set to a large value (e.g., 0xFFFFFFFF). The TA calls snprintf with this untrusted size, causing snprintf to write beyond the actual buffer boundary in shared memory, corrupting adjacent TA memory or REE memory.",
          "impact": "Buffer overflow in shared memory region; potential TA memory corruption, information disclosure of TA secrets (key, vi), denial of service, or privilege escalation if overflow reaches critical TA data structures."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "output:168-169",
          "recommendation": "Add explicit validation: if (params[2].memref.size > MAX_SAFE_SIZE || params[2].memref.size == 0) return TEE_ERROR_BAD_PARAMETERS; before any snprintf call."
        },
        {
          "type": "range_check",
          "location": "output:176,184,185,189,190,191",
          "recommendation": "Use safe snprintf wrapper that enforces maximum buffer size independent of REE-provided size parameter."
        },
        {
          "type": "mem_access_check",
          "location": "output:175",
          "recommendation": "Validate params[1].memref.size and params[2].memref.size before any memory operation; enforce upper bounds tied to TA-internal buffer sizes."
        }
      ],
      "decision_rationales": [
        "All six snprintf calls at lines 176, 184, 185, 189, 190, 191 are vulnerable because: (1) params[2].memref.size originates from REE (untrusted source), (2) it is used directly as the size bound in snprintf without any validation or sanitization, (3) the destination params[2].memref.buffer is a REE-visible shared buffer, (4) there is no effective bounds check on the same execution path (the type_validation at line 168 only validates param_types, not the memref.size values), and (5) snprintf will write up to the specified size, allowing an attacker to overflow the buffer. This is a classic shared-memory buffer overflow vulnerability (CWE-120/122)."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0020",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 190,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as snprintf bound; no validation; buffer overflow on shared memory."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size field (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:159 (passed to output function)",
            "params[2].memref.size @ output:176,184,185,189,190,191 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes to REE-visible shared buffer with untrusted size bound"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (shared memory region)",
            "No runtime bounds validation on params[2].memref.size against actual buffer capacity",
            "snprintf uses attacker-controlled size as the buffer length parameter"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_OUTPUT with crafted TEE_Param[2].memref.size set to a large value (e.g., 0xFFFFFFFF). The TA calls snprintf with this untrusted size, causing snprintf to write beyond the actual buffer boundary in shared memory, corrupting adjacent TA memory or REE memory.",
          "impact": "Buffer overflow in shared memory region; potential TA memory corruption, information disclosure of TA secrets (key, vi), denial of service, or privilege escalation if overflow reaches critical TA data structures."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "output:168-169",
          "recommendation": "Add explicit validation: if (params[2].memref.size > MAX_SAFE_SIZE || params[2].memref.size == 0) return TEE_ERROR_BAD_PARAMETERS; before any snprintf call."
        },
        {
          "type": "range_check",
          "location": "output:176,184,185,189,190,191",
          "recommendation": "Use safe snprintf wrapper that enforces maximum buffer size independent of REE-provided size parameter."
        },
        {
          "type": "mem_access_check",
          "location": "output:175",
          "recommendation": "Validate params[1].memref.size and params[2].memref.size before any memory operation; enforce upper bounds tied to TA-internal buffer sizes."
        }
      ],
      "decision_rationales": [
        "All six snprintf calls at lines 176, 184, 185, 189, 190, 191 are vulnerable because: (1) params[2].memref.size originates from REE (untrusted source), (2) it is used directly as the size bound in snprintf without any validation or sanitization, (3) the destination params[2].memref.buffer is a REE-visible shared buffer, (4) there is no effective bounds check on the same execution path (the type_validation at line 168 only validates param_types, not the memref.size values), and (5) snprintf will write up to the specified size, allowing an attacker to overflow the buffer. This is a classic shared-memory buffer overflow vulnerability (CWE-120/122)."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0021",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 191,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "snprintf"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "REE-tainted params[2].memref.size used as snprintf bound; no validation; buffer overflow on shared memory."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "output",
          "snprintf"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param.memref.size field (untrusted, attacker-controlled)",
          "propagation_path": [
            "params[2].memref.size @ TA_InvokeCommandEntryPoint:502 (REE-visible)",
            "params[2].memref.size @ output:159 (passed to output function)",
            "params[2].memref.size @ output:176,184,185,189,190,191 (used as snprintf bound)"
          ],
          "sink": "snprintf(params[2].memref.buffer, params[2].memref.size, ...) writes to REE-visible shared buffer with untrusted size bound"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param[2].memref.size via REE",
            "Attacker controls TEE_Param[2].memref.buffer pointer (shared memory region)",
            "No runtime bounds validation on params[2].memref.size against actual buffer capacity",
            "snprintf uses attacker-controlled size as the buffer length parameter"
          ],
          "attack_scenario": "Attacker invokes TA_HELLO_WORLD_CMD_OUTPUT with crafted TEE_Param[2].memref.size set to a large value (e.g., 0xFFFFFFFF). The TA calls snprintf with this untrusted size, causing snprintf to write beyond the actual buffer boundary in shared memory, corrupting adjacent TA memory or REE memory.",
          "impact": "Buffer overflow in shared memory region; potential TA memory corruption, information disclosure of TA secrets (key, vi), denial of service, or privilege escalation if overflow reaches critical TA data structures."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "output:168-169",
          "recommendation": "Add explicit validation: if (params[2].memref.size > MAX_SAFE_SIZE || params[2].memref.size == 0) return TEE_ERROR_BAD_PARAMETERS; before any snprintf call."
        },
        {
          "type": "range_check",
          "location": "output:176,184,185,189,190,191",
          "recommendation": "Use safe snprintf wrapper that enforces maximum buffer size independent of REE-provided size parameter."
        },
        {
          "type": "mem_access_check",
          "location": "output:175",
          "recommendation": "Validate params[1].memref.size and params[2].memref.size before any memory operation; enforce upper bounds tied to TA-internal buffer sizes."
        }
      ],
      "decision_rationales": [
        "All six snprintf calls at lines 176, 184, 185, 189, 190, 191 are vulnerable because: (1) params[2].memref.size originates from REE (untrusted source), (2) it is used directly as the size bound in snprintf without any validation or sanitization, (3) the destination params[2].memref.buffer is a REE-visible shared buffer, (4) there is no effective bounds check on the same execution path (the type_validation at line 168 only validates param_types, not the memref.size values), and (5) snprintf will write up to the specified size, allowing an attacker to overflow the buffer. This is a classic shared-memory buffer overflow vulnerability (CWE-120/122)."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0022",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 208,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-125 (Out-of-bounds Read)",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-125 (Out-of-bounds Read)"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Tainted copy length params[3].memref.size used without bounds check; destination str is 1000 bytes; overflow possible."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "produce_i2",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields (params[3].memref.size at line 208; params[2].memref.size at line 212)",
          "propagation_path": [
            "params[3].memref.size (REE-visible) -> size3 parameter @ produce_i2:196",
            "params[2].memref.size (REE-visible) -> size2 parameter @ produce_i2:196",
            "size3/size2 used as copy length in TEE_MemMove @ produce_i2:208,212"
          ],
          "sink": "TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size) and TEE_MemMove(str, params[2].memref.buffer, params[2].memref.size)"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[3].memref.size or params[2].memref.size via REE-originated TEE_Param",
            "No runtime bounds check validates that copy length  destination buffer size (1000 bytes)",
            "Destination buffer str is allocated on TEE-private heap (TEE_Malloc)"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing memref parameters with size fields set to values > 1000. The input() function calls produce_i0(), which calls produce_i2(). At lines 208 and 212, TEE_MemMove copies untrusted-sized data into a fixed 1000-byte buffer without validation, causing heap buffer overflow.",
          "impact": "Heap buffer overflow in TEE-private memory; potential code execution, information disclosure, or denial of service within the TA context."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i2:208,212",
          "recommendation": "Add explicit bounds check before TEE_MemMove: if (params[3].memref.size > 1000) return TEE_ERROR_BAD_PARAMETERS; (and similarly for params[2].memref.size at line 212)"
        },
        {
          "type": "range_check",
          "location": "input:277",
          "recommendation": "Extend param_types validation to also check memref sizes; currently only validates type mismatch, not size bounds"
        },
        {
          "type": "mem_access_check",
          "location": "produce_i0:283,284,303 and produce_i2:201,202",
          "recommendation": "Validate TEE_Malloc size arguments (a, b, params[1].memref.size) before allocation to prevent unbounded allocations"
        }
      ],
      "decision_rationales": [
        "Both lines 208 and 212 exhibit classic buffer overflow vulnerability: untrusted-sized copy into fixed-size destination without bounds validation. The taint originates from REE (params[3].memref.size and params[2].memref.size), propagates through function parameters (a, b, size2, size3) without sanitization, and reaches TEE_MemMove with no effective bounds check on the same path. The destination buffer (str, 1000 bytes) is TEE-private, but the overflow itself is a memory-safety violation (CWE-120) that takes priority over information-disclosure concerns."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0023",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 212,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-125 (Out-of-bounds Read)",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-125 (Out-of-bounds Read)"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Tainted copy length params[2].memref.size used without bounds check; destination str is 1000 bytes; overflow possible."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "produce_i2",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields (params[3].memref.size at line 208; params[2].memref.size at line 212)",
          "propagation_path": [
            "params[3].memref.size (REE-visible) -> size3 parameter @ produce_i2:196",
            "params[2].memref.size (REE-visible) -> size2 parameter @ produce_i2:196",
            "size3/size2 used as copy length in TEE_MemMove @ produce_i2:208,212"
          ],
          "sink": "TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size) and TEE_MemMove(str, params[2].memref.buffer, params[2].memref.size)"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[3].memref.size or params[2].memref.size via REE-originated TEE_Param",
            "No runtime bounds check validates that copy length  destination buffer size (1000 bytes)",
            "Destination buffer str is allocated on TEE-private heap (TEE_Malloc)"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing memref parameters with size fields set to values > 1000. The input() function calls produce_i0(), which calls produce_i2(). At lines 208 and 212, TEE_MemMove copies untrusted-sized data into a fixed 1000-byte buffer without validation, causing heap buffer overflow.",
          "impact": "Heap buffer overflow in TEE-private memory; potential code execution, information disclosure, or denial of service within the TA context."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i2:208,212",
          "recommendation": "Add explicit bounds check before TEE_MemMove: if (params[3].memref.size > 1000) return TEE_ERROR_BAD_PARAMETERS; (and similarly for params[2].memref.size at line 212)"
        },
        {
          "type": "range_check",
          "location": "input:277",
          "recommendation": "Extend param_types validation to also check memref sizes; currently only validates type mismatch, not size bounds"
        },
        {
          "type": "mem_access_check",
          "location": "produce_i0:283,284,303 and produce_i2:201,202",
          "recommendation": "Validate TEE_Malloc size arguments (a, b, params[1].memref.size) before allocation to prevent unbounded allocations"
        }
      ],
      "decision_rationales": [
        "Both lines 208 and 212 exhibit classic buffer overflow vulnerability: untrusted-sized copy into fixed-size destination without bounds validation. The taint originates from REE (params[3].memref.size and params[2].memref.size), propagates through function parameters (a, b, size2, size3) without sanitization, and reaches TEE_MemMove with no effective bounds check on the same path. The destination buffer (str, 1000 bytes) is TEE-private, but the overflow itself is a memory-safety violation (CWE-120) that takes priority over information-disclosure concerns."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0024",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 227,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow) / CWE-125 (Out-of-bounds Read)",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow) / CWE-125 (Out-of-bounds Read)"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Tainted copy length (size3 from REE) used without bounds check; destination str is 1000 bytes, overflow possible"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields (params[0].value.a, params[1].memref.size, params[2].memref.size, params[3].memref.size) passed from TA_InvokeCommandEntryPoint  input()  produce_i0()",
          "propagation_path": [
            "params[0].value.a (REE-visible)  a @ entry.c:215",
            "params[1].memref.size (REE-visible)  b @ entry.c:215",
            "params[2].memref.size (REE-visible)  size2 @ entry.c:215",
            "params[3].memref.size (REE-visible)  size3 @ entry.c:215",
            "params[2].memref.buffer (REE-visible)  buf2 @ entry.c:215",
            "params[3].memref.buffer (REE-visible)  buf3 @ entry.c:215",
            "size3  TEE_MemMove(str, buf3, size3) @ entry.c:227",
            "size2  TEE_MemMove(str, buf2, size2) @ entry.c:238",
            "size3  TEE_MemMove(str, buf3, size3) @ entry.c:239",
            "buf2 (REE-visible)  TEE_MemMove(buf2, str, 1000) @ entry.c:246"
          ],
          "sink": "TEE_MemMove() calls at lines 227, 238, 239, 246 with tainted copy lengths or REE-visible destination buffers"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param values from Normal World (REE)",
            "No effective bounds validation on param_types or individual param field sizes before use",
            "Fixed-size buffers (str[1000]) are used without runtime size checks against tainted input"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing large values for params[2].memref.size or params[3].memref.size (e.g., > 1000). These tainted sizes are passed to produce_i0() and used directly in TEE_MemMove() calls without validation, causing heap buffer overflow in TEE-private memory (lines 227, 238, 239) or overflow into REE-shared memory (line 246). Attacker can corrupt TEE heap structures, leak sensitive data, or achieve code execution.",
          "impact": "Memory corruption in TEE, potential information disclosure of TA-private data, denial of service, or privilege escalation within the TEE"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i0:227,238,239",
          "recommendation": "Add explicit bounds check: if (size2 > 1000 || size3 > 1000) return TEE_ERROR_BAD_PARAMETERS; before TEE_MemMove calls"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:246",
          "recommendation": "Validate destination buffer size: if (size2 < 1000) return TEE_ERROR_BAD_PARAMETERS; before writing 1000 bytes to buf2"
        },
        {
          "type": "type_validation",
          "location": "input:277",
          "recommendation": "Enhance param_types validation to also check individual memref sizes are within acceptable ranges (e.g., max 10000 bytes)"
        },
        {
          "type": "access_control",
          "location": "input:283,284,303",
          "recommendation": "Validate allocation sizes before TEE_Malloc: if (a > MAX_ALLOC || b > MAX_ALLOC) return TEE_ERROR_BAD_PARAMETERS;"
        }
      ],
      "decision_rationales": [
        "All four target sink lines are vulnerable. Lines 227, 238, 239 exhibit classic heap buffer overflow: tainted copy lengths (size2, size3) from REE are used without bounds checks to copy into fixed-size TEE-private buffer (str[1000]). Line 246 exhibits shared-memory overwrite: fixed-size copy (1000 bytes) into REE-visible buffer (buf2) whose actual size is tainted (size2) and may be smaller, allowing overflow into REE-shared memory. The sanitizers at lines 233 and 241 are placed AFTER the vulnerable operations, providing no protection. The type validation at line 277 is insufficient because it only checks param_types structure, not the actual field values. No effective bounds checks exist on the same execution path before the TEE_MemMove calls."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0025",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 238,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow) / CWE-125 (Out-of-bounds Read)",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow) / CWE-125 (Out-of-bounds Read)"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Tainted copy length (size2 from REE) used without bounds check; destination str is 1000 bytes, overflow possible"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields (params[0].value.a, params[1].memref.size, params[2].memref.size, params[3].memref.size) passed from TA_InvokeCommandEntryPoint  input()  produce_i0()",
          "propagation_path": [
            "params[0].value.a (REE-visible)  a @ entry.c:215",
            "params[1].memref.size (REE-visible)  b @ entry.c:215",
            "params[2].memref.size (REE-visible)  size2 @ entry.c:215",
            "params[3].memref.size (REE-visible)  size3 @ entry.c:215",
            "params[2].memref.buffer (REE-visible)  buf2 @ entry.c:215",
            "params[3].memref.buffer (REE-visible)  buf3 @ entry.c:215",
            "size3  TEE_MemMove(str, buf3, size3) @ entry.c:227",
            "size2  TEE_MemMove(str, buf2, size2) @ entry.c:238",
            "size3  TEE_MemMove(str, buf3, size3) @ entry.c:239",
            "buf2 (REE-visible)  TEE_MemMove(buf2, str, 1000) @ entry.c:246"
          ],
          "sink": "TEE_MemMove() calls at lines 227, 238, 239, 246 with tainted copy lengths or REE-visible destination buffers"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param values from Normal World (REE)",
            "No effective bounds validation on param_types or individual param field sizes before use",
            "Fixed-size buffers (str[1000]) are used without runtime size checks against tainted input"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing large values for params[2].memref.size or params[3].memref.size (e.g., > 1000). These tainted sizes are passed to produce_i0() and used directly in TEE_MemMove() calls without validation, causing heap buffer overflow in TEE-private memory (lines 227, 238, 239) or overflow into REE-shared memory (line 246). Attacker can corrupt TEE heap structures, leak sensitive data, or achieve code execution.",
          "impact": "Memory corruption in TEE, potential information disclosure of TA-private data, denial of service, or privilege escalation within the TEE"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i0:227,238,239",
          "recommendation": "Add explicit bounds check: if (size2 > 1000 || size3 > 1000) return TEE_ERROR_BAD_PARAMETERS; before TEE_MemMove calls"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:246",
          "recommendation": "Validate destination buffer size: if (size2 < 1000) return TEE_ERROR_BAD_PARAMETERS; before writing 1000 bytes to buf2"
        },
        {
          "type": "type_validation",
          "location": "input:277",
          "recommendation": "Enhance param_types validation to also check individual memref sizes are within acceptable ranges (e.g., max 10000 bytes)"
        },
        {
          "type": "access_control",
          "location": "input:283,284,303",
          "recommendation": "Validate allocation sizes before TEE_Malloc: if (a > MAX_ALLOC || b > MAX_ALLOC) return TEE_ERROR_BAD_PARAMETERS;"
        }
      ],
      "decision_rationales": [
        "All four target sink lines are vulnerable. Lines 227, 238, 239 exhibit classic heap buffer overflow: tainted copy lengths (size2, size3) from REE are used without bounds checks to copy into fixed-size TEE-private buffer (str[1000]). Line 246 exhibits shared-memory overwrite: fixed-size copy (1000 bytes) into REE-visible buffer (buf2) whose actual size is tainted (size2) and may be smaller, allowing overflow into REE-shared memory. The sanitizers at lines 233 and 241 are placed AFTER the vulnerable operations, providing no protection. The type validation at line 277 is insufficient because it only checks param_types structure, not the actual field values. No effective bounds checks exist on the same execution path before the TEE_MemMove calls."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0026",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 239,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow) / CWE-125 (Out-of-bounds Read)",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow) / CWE-125 (Out-of-bounds Read)"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Tainted copy length (size3 from REE) used without bounds check; destination str is 1000 bytes, overflow possible"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields (params[0].value.a, params[1].memref.size, params[2].memref.size, params[3].memref.size) passed from TA_InvokeCommandEntryPoint  input()  produce_i0()",
          "propagation_path": [
            "params[0].value.a (REE-visible)  a @ entry.c:215",
            "params[1].memref.size (REE-visible)  b @ entry.c:215",
            "params[2].memref.size (REE-visible)  size2 @ entry.c:215",
            "params[3].memref.size (REE-visible)  size3 @ entry.c:215",
            "params[2].memref.buffer (REE-visible)  buf2 @ entry.c:215",
            "params[3].memref.buffer (REE-visible)  buf3 @ entry.c:215",
            "size3  TEE_MemMove(str, buf3, size3) @ entry.c:227",
            "size2  TEE_MemMove(str, buf2, size2) @ entry.c:238",
            "size3  TEE_MemMove(str, buf3, size3) @ entry.c:239",
            "buf2 (REE-visible)  TEE_MemMove(buf2, str, 1000) @ entry.c:246"
          ],
          "sink": "TEE_MemMove() calls at lines 227, 238, 239, 246 with tainted copy lengths or REE-visible destination buffers"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param values from Normal World (REE)",
            "No effective bounds validation on param_types or individual param field sizes before use",
            "Fixed-size buffers (str[1000]) are used without runtime size checks against tainted input"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing large values for params[2].memref.size or params[3].memref.size (e.g., > 1000). These tainted sizes are passed to produce_i0() and used directly in TEE_MemMove() calls without validation, causing heap buffer overflow in TEE-private memory (lines 227, 238, 239) or overflow into REE-shared memory (line 246). Attacker can corrupt TEE heap structures, leak sensitive data, or achieve code execution.",
          "impact": "Memory corruption in TEE, potential information disclosure of TA-private data, denial of service, or privilege escalation within the TEE"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i0:227,238,239",
          "recommendation": "Add explicit bounds check: if (size2 > 1000 || size3 > 1000) return TEE_ERROR_BAD_PARAMETERS; before TEE_MemMove calls"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:246",
          "recommendation": "Validate destination buffer size: if (size2 < 1000) return TEE_ERROR_BAD_PARAMETERS; before writing 1000 bytes to buf2"
        },
        {
          "type": "type_validation",
          "location": "input:277",
          "recommendation": "Enhance param_types validation to also check individual memref sizes are within acceptable ranges (e.g., max 10000 bytes)"
        },
        {
          "type": "access_control",
          "location": "input:283,284,303",
          "recommendation": "Validate allocation sizes before TEE_Malloc: if (a > MAX_ALLOC || b > MAX_ALLOC) return TEE_ERROR_BAD_PARAMETERS;"
        }
      ],
      "decision_rationales": [
        "All four target sink lines are vulnerable. Lines 227, 238, 239 exhibit classic heap buffer overflow: tainted copy lengths (size2, size3) from REE are used without bounds checks to copy into fixed-size TEE-private buffer (str[1000]). Line 246 exhibits shared-memory overwrite: fixed-size copy (1000 bytes) into REE-visible buffer (buf2) whose actual size is tainted (size2) and may be smaller, allowing overflow into REE-shared memory. The sanitizers at lines 233 and 241 are placed AFTER the vulnerable operations, providing no protection. The type validation at line 277 is insufficient because it only checks param_types structure, not the actual field values. No effective bounds checks exist on the same execution path before the TEE_MemMove calls."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0027",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 246,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow) / CWE-125 (Out-of-bounds Read)",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow) / CWE-125 (Out-of-bounds Read)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "Fixed-size copy (1000 bytes) into REE-visible buf2 with tainted destination size (size2); buffer overflow into REE-shared memory possible"
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "produce_i0",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields (params[0].value.a, params[1].memref.size, params[2].memref.size, params[3].memref.size) passed from TA_InvokeCommandEntryPoint  input()  produce_i0()",
          "propagation_path": [
            "params[0].value.a (REE-visible)  a @ entry.c:215",
            "params[1].memref.size (REE-visible)  b @ entry.c:215",
            "params[2].memref.size (REE-visible)  size2 @ entry.c:215",
            "params[3].memref.size (REE-visible)  size3 @ entry.c:215",
            "params[2].memref.buffer (REE-visible)  buf2 @ entry.c:215",
            "params[3].memref.buffer (REE-visible)  buf3 @ entry.c:215",
            "size3  TEE_MemMove(str, buf3, size3) @ entry.c:227",
            "size2  TEE_MemMove(str, buf2, size2) @ entry.c:238",
            "size3  TEE_MemMove(str, buf3, size3) @ entry.c:239",
            "buf2 (REE-visible)  TEE_MemMove(buf2, str, 1000) @ entry.c:246"
          ],
          "sink": "TEE_MemMove() calls at lines 227, 238, 239, 246 with tainted copy lengths or REE-visible destination buffers"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls TEE_Param values from Normal World (REE)",
            "No effective bounds validation on param_types or individual param field sizes before use",
            "Fixed-size buffers (str[1000]) are used without runtime size checks against tainted input"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing large values for params[2].memref.size or params[3].memref.size (e.g., > 1000). These tainted sizes are passed to produce_i0() and used directly in TEE_MemMove() calls without validation, causing heap buffer overflow in TEE-private memory (lines 227, 238, 239) or overflow into REE-shared memory (line 246). Attacker can corrupt TEE heap structures, leak sensitive data, or achieve code execution.",
          "impact": "Memory corruption in TEE, potential information disclosure of TA-private data, denial of service, or privilege escalation within the TEE"
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_i0:227,238,239",
          "recommendation": "Add explicit bounds check: if (size2 > 1000 || size3 > 1000) return TEE_ERROR_BAD_PARAMETERS; before TEE_MemMove calls"
        },
        {
          "type": "bounds_check",
          "location": "produce_i0:246",
          "recommendation": "Validate destination buffer size: if (size2 < 1000) return TEE_ERROR_BAD_PARAMETERS; before writing 1000 bytes to buf2"
        },
        {
          "type": "type_validation",
          "location": "input:277",
          "recommendation": "Enhance param_types validation to also check individual memref sizes are within acceptable ranges (e.g., max 10000 bytes)"
        },
        {
          "type": "access_control",
          "location": "input:283,284,303",
          "recommendation": "Validate allocation sizes before TEE_Malloc: if (a > MAX_ALLOC || b > MAX_ALLOC) return TEE_ERROR_BAD_PARAMETERS;"
        }
      ],
      "decision_rationales": [
        "All four target sink lines are vulnerable. Lines 227, 238, 239 exhibit classic heap buffer overflow: tainted copy lengths (size2, size3) from REE are used without bounds checks to copy into fixed-size TEE-private buffer (str[1000]). Line 246 exhibits shared-memory overwrite: fixed-size copy (1000 bytes) into REE-visible buffer (buf2) whose actual size is tainted (size2) and may be smaller, allowing overflow into REE-shared memory. The sanitizers at lines 233 and 241 are placed AFTER the vulnerable operations, providing no protection. The type validation at line 277 is insufficient because it only checks param_types structure, not the actual field values. No effective bounds checks exist on the same execution path before the TEE_MemMove calls."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0028",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 290,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Tainted copy length (params[3].memref.size) from REE copied into fixed-size TEE-private buffer (str, 1000 bytes) without bounds check; buffer overflow risk."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields: params[0].value.a, params[1].memref.size, params[2].memref.buffer, params[2].memref.size, params[3].memref.buffer, params[3].memref.size",
          "propagation_path": [
            "params[i].memref.size (tainted from REE)  TEE_MemMove copy_len argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[i].memref.buffer (REE-visible)  TEE_MemMove source argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "str (TEE-private, 1000 bytes)  unbounded copy from REE @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[2].memref.buffer (REE-visible, tainted size)  fixed 1000-byte copy from str @ /workspace/benchmark/bad-partitioning/ta/entry.c:291,309"
          ],
          "sink": "TEE_MemMove at lines 290, 291, 306, 307, 309 with insufficient bounds validation"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE-originated TEE_Param values (cmd_id, param_types, params array)",
            "No effective bounds check on params[i].memref.size before use as copy length",
            "Destination buffers (str, params[2].memref.buffer) have fixed or tainted sizes without validation"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing large memref.size values (e.g., > 1000) in params[2] or params[3]. The input() function copies this untrusted size into TEE_MemMove without validation, causing stack/heap buffer overflow in TEE-private memory (str) or overflow into REE-shared memory (params[2].memref.buffer). This can corrupt TA state, leak secrets, or achieve code execution.",
          "impact": "Memory corruption in TEE-private memory (str buffer), overflow into REE-shared memory (params[2].memref.buffer), potential information disclosure of TA secrets, denial of service, or code execution within the TA context."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:283-284",
          "recommendation": "Validate params[0].value.a and params[1].memref.size before use in TEE_Malloc; enforce maximum allocation size (e.g., < 10000)."
        },
        {
          "type": "bounds_check",
          "location": "input:286-287",
          "recommendation": "Check params[2].memref.size <= 1000 before loop; enforce upper bound on copy length."
        },
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bound on copy length to prevent str overflow."
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "bounds_check",
          "location": "input:306-307",
          "recommendation": "Validate params[2].memref.size and params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bounds on copy lengths."
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "mem_access_check",
          "location": "input:293,295,296",
          "recommendation": "Validate array indices (params[3].memref.size - 3, params[0].value.a - 3, 30 - params[0].value.a) before use; enforce bounds on str and params[3].memref.buffer access."
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit direct taint propagation from REE-originated TEE_Param fields to TEE_MemMove copy_len arguments without effective bounds validation. Lines 290, 306, 307 copy from REE-visible buffers with tainted sizes into fixed-size TEE-private destination (str, 1000 bytes), risking stack/heap overflow. Lines 291, 309 copy fixed 1000 bytes into REE-visible destination with tainted size, risking shared-memory overflow. The type_validation sanitizer at line 277 is insufficient (only checks param_types, not memref sizes). The bounds_check at line 298 is insufficient (only checks params[1].memref.size > 10000, does not protect params[2] or params[3], and allows allocation up to 10000 bytes). No other sanitizers block the taint flow. This is a classic CWE-120/121/122 buffer overflow vulnerability with critical severity."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0029",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 291,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "Fixed 1000-byte copy into REE-visible destination (params[2].memref.buffer) with tainted size (params[2].memref.size); destination may be smaller, causing shared-memory overflow."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields: params[0].value.a, params[1].memref.size, params[2].memref.buffer, params[2].memref.size, params[3].memref.buffer, params[3].memref.size",
          "propagation_path": [
            "params[i].memref.size (tainted from REE)  TEE_MemMove copy_len argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[i].memref.buffer (REE-visible)  TEE_MemMove source argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "str (TEE-private, 1000 bytes)  unbounded copy from REE @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[2].memref.buffer (REE-visible, tainted size)  fixed 1000-byte copy from str @ /workspace/benchmark/bad-partitioning/ta/entry.c:291,309"
          ],
          "sink": "TEE_MemMove at lines 290, 291, 306, 307, 309 with insufficient bounds validation"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE-originated TEE_Param values (cmd_id, param_types, params array)",
            "No effective bounds check on params[i].memref.size before use as copy length",
            "Destination buffers (str, params[2].memref.buffer) have fixed or tainted sizes without validation"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing large memref.size values (e.g., > 1000) in params[2] or params[3]. The input() function copies this untrusted size into TEE_MemMove without validation, causing stack/heap buffer overflow in TEE-private memory (str) or overflow into REE-shared memory (params[2].memref.buffer). This can corrupt TA state, leak secrets, or achieve code execution.",
          "impact": "Memory corruption in TEE-private memory (str buffer), overflow into REE-shared memory (params[2].memref.buffer), potential information disclosure of TA secrets, denial of service, or code execution within the TA context."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:283-284",
          "recommendation": "Validate params[0].value.a and params[1].memref.size before use in TEE_Malloc; enforce maximum allocation size (e.g., < 10000)."
        },
        {
          "type": "bounds_check",
          "location": "input:286-287",
          "recommendation": "Check params[2].memref.size <= 1000 before loop; enforce upper bound on copy length."
        },
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bound on copy length to prevent str overflow."
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "bounds_check",
          "location": "input:306-307",
          "recommendation": "Validate params[2].memref.size and params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bounds on copy lengths."
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "mem_access_check",
          "location": "input:293,295,296",
          "recommendation": "Validate array indices (params[3].memref.size - 3, params[0].value.a - 3, 30 - params[0].value.a) before use; enforce bounds on str and params[3].memref.buffer access."
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit direct taint propagation from REE-originated TEE_Param fields to TEE_MemMove copy_len arguments without effective bounds validation. Lines 290, 306, 307 copy from REE-visible buffers with tainted sizes into fixed-size TEE-private destination (str, 1000 bytes), risking stack/heap overflow. Lines 291, 309 copy fixed 1000 bytes into REE-visible destination with tainted size, risking shared-memory overflow. The type_validation sanitizer at line 277 is insufficient (only checks param_types, not memref sizes). The bounds_check at line 298 is insufficient (only checks params[1].memref.size > 10000, does not protect params[2] or params[3], and allows allocation up to 10000 bytes). No other sanitizers block the taint flow. This is a classic CWE-120/121/122 buffer overflow vulnerability with critical severity."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0030",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 306,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Tainted copy length (params[2].memref.size) from REE copied into fixed-size TEE-private buffer (str, 1000 bytes) without bounds check; buffer overflow risk."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields: params[0].value.a, params[1].memref.size, params[2].memref.buffer, params[2].memref.size, params[3].memref.buffer, params[3].memref.size",
          "propagation_path": [
            "params[i].memref.size (tainted from REE)  TEE_MemMove copy_len argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[i].memref.buffer (REE-visible)  TEE_MemMove source argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "str (TEE-private, 1000 bytes)  unbounded copy from REE @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[2].memref.buffer (REE-visible, tainted size)  fixed 1000-byte copy from str @ /workspace/benchmark/bad-partitioning/ta/entry.c:291,309"
          ],
          "sink": "TEE_MemMove at lines 290, 291, 306, 307, 309 with insufficient bounds validation"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE-originated TEE_Param values (cmd_id, param_types, params array)",
            "No effective bounds check on params[i].memref.size before use as copy length",
            "Destination buffers (str, params[2].memref.buffer) have fixed or tainted sizes without validation"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing large memref.size values (e.g., > 1000) in params[2] or params[3]. The input() function copies this untrusted size into TEE_MemMove without validation, causing stack/heap buffer overflow in TEE-private memory (str) or overflow into REE-shared memory (params[2].memref.buffer). This can corrupt TA state, leak secrets, or achieve code execution.",
          "impact": "Memory corruption in TEE-private memory (str buffer), overflow into REE-shared memory (params[2].memref.buffer), potential information disclosure of TA secrets, denial of service, or code execution within the TA context."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:283-284",
          "recommendation": "Validate params[0].value.a and params[1].memref.size before use in TEE_Malloc; enforce maximum allocation size (e.g., < 10000)."
        },
        {
          "type": "bounds_check",
          "location": "input:286-287",
          "recommendation": "Check params[2].memref.size <= 1000 before loop; enforce upper bound on copy length."
        },
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bound on copy length to prevent str overflow."
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "bounds_check",
          "location": "input:306-307",
          "recommendation": "Validate params[2].memref.size and params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bounds on copy lengths."
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "mem_access_check",
          "location": "input:293,295,296",
          "recommendation": "Validate array indices (params[3].memref.size - 3, params[0].value.a - 3, 30 - params[0].value.a) before use; enforce bounds on str and params[3].memref.buffer access."
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit direct taint propagation from REE-originated TEE_Param fields to TEE_MemMove copy_len arguments without effective bounds validation. Lines 290, 306, 307 copy from REE-visible buffers with tainted sizes into fixed-size TEE-private destination (str, 1000 bytes), risking stack/heap overflow. Lines 291, 309 copy fixed 1000 bytes into REE-visible destination with tainted size, risking shared-memory overflow. The type_validation sanitizer at line 277 is insufficient (only checks param_types, not memref sizes). The bounds_check at line 298 is insufficient (only checks params[1].memref.size > 10000, does not protect params[2] or params[3], and allows allocation up to 10000 bytes). No other sanitizers block the taint flow. This is a classic CWE-120/121/122 buffer overflow vulnerability with critical severity."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0031",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 307,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Tainted copy length (params[3].memref.size) from REE copied into fixed-size TEE-private buffer (str, 1000 bytes) without bounds check; buffer overflow risk."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields: params[0].value.a, params[1].memref.size, params[2].memref.buffer, params[2].memref.size, params[3].memref.buffer, params[3].memref.size",
          "propagation_path": [
            "params[i].memref.size (tainted from REE)  TEE_MemMove copy_len argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[i].memref.buffer (REE-visible)  TEE_MemMove source argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "str (TEE-private, 1000 bytes)  unbounded copy from REE @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[2].memref.buffer (REE-visible, tainted size)  fixed 1000-byte copy from str @ /workspace/benchmark/bad-partitioning/ta/entry.c:291,309"
          ],
          "sink": "TEE_MemMove at lines 290, 291, 306, 307, 309 with insufficient bounds validation"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE-originated TEE_Param values (cmd_id, param_types, params array)",
            "No effective bounds check on params[i].memref.size before use as copy length",
            "Destination buffers (str, params[2].memref.buffer) have fixed or tainted sizes without validation"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing large memref.size values (e.g., > 1000) in params[2] or params[3]. The input() function copies this untrusted size into TEE_MemMove without validation, causing stack/heap buffer overflow in TEE-private memory (str) or overflow into REE-shared memory (params[2].memref.buffer). This can corrupt TA state, leak secrets, or achieve code execution.",
          "impact": "Memory corruption in TEE-private memory (str buffer), overflow into REE-shared memory (params[2].memref.buffer), potential information disclosure of TA secrets, denial of service, or code execution within the TA context."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:283-284",
          "recommendation": "Validate params[0].value.a and params[1].memref.size before use in TEE_Malloc; enforce maximum allocation size (e.g., < 10000)."
        },
        {
          "type": "bounds_check",
          "location": "input:286-287",
          "recommendation": "Check params[2].memref.size <= 1000 before loop; enforce upper bound on copy length."
        },
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bound on copy length to prevent str overflow."
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "bounds_check",
          "location": "input:306-307",
          "recommendation": "Validate params[2].memref.size and params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bounds on copy lengths."
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "mem_access_check",
          "location": "input:293,295,296",
          "recommendation": "Validate array indices (params[3].memref.size - 3, params[0].value.a - 3, 30 - params[0].value.a) before use; enforce bounds on str and params[3].memref.buffer access."
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit direct taint propagation from REE-originated TEE_Param fields to TEE_MemMove copy_len arguments without effective bounds validation. Lines 290, 306, 307 copy from REE-visible buffers with tainted sizes into fixed-size TEE-private destination (str, 1000 bytes), risking stack/heap overflow. Lines 291, 309 copy fixed 1000 bytes into REE-visible destination with tainted size, risking shared-memory overflow. The type_validation sanitizer at line 277 is insufficient (only checks param_types, not memref sizes). The bounds_check at line 298 is insufficient (only checks params[1].memref.size > 10000, does not protect params[2] or params[3], and allows allocation up to 10000 bytes). No other sanitizers block the taint flow. This is a classic CWE-120/121/122 buffer overflow vulnerability with critical severity."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    },
    {
      "vulnerability_id": "VULN-0032",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 309,
      "consolidated": true,
      "detection_count": 1,
      "severity": "critical",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Copy without Checking Size of Input) / CWE-121 (Stack-based Buffer Overflow) / CWE-122 (Heap-based Buffer Overflow)"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "Fixed 1000-byte copy into REE-visible destination (params[2].memref.buffer) with tainted size (params[2].memref.size); destination may be smaller, causing shared-memory overflow."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "input",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated TEE_Param fields: params[0].value.a, params[1].memref.size, params[2].memref.buffer, params[2].memref.size, params[3].memref.buffer, params[3].memref.size",
          "propagation_path": [
            "params[i].memref.size (tainted from REE)  TEE_MemMove copy_len argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[i].memref.buffer (REE-visible)  TEE_MemMove source argument @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "str (TEE-private, 1000 bytes)  unbounded copy from REE @ /workspace/benchmark/bad-partitioning/ta/entry.c:290,306,307",
            "params[2].memref.buffer (REE-visible, tainted size)  fixed 1000-byte copy from str @ /workspace/benchmark/bad-partitioning/ta/entry.c:291,309"
          ],
          "sink": "TEE_MemMove at lines 290, 291, 306, 307, 309 with insufficient bounds validation"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls REE-originated TEE_Param values (cmd_id, param_types, params array)",
            "No effective bounds check on params[i].memref.size before use as copy length",
            "Destination buffers (str, params[2].memref.buffer) have fixed or tainted sizes without validation"
          ],
          "attack_scenario": "Attacker invokes TA_InvokeCommandEntryPoint with TA_HELLO_WORLD_CMD_INPUT, providing large memref.size values (e.g., > 1000) in params[2] or params[3]. The input() function copies this untrusted size into TEE_MemMove without validation, causing stack/heap buffer overflow in TEE-private memory (str) or overflow into REE-shared memory (params[2].memref.buffer). This can corrupt TA state, leak secrets, or achieve code execution.",
          "impact": "Memory corruption in TEE-private memory (str buffer), overflow into REE-shared memory (params[2].memref.buffer), potential information disclosure of TA secrets, denial of service, or code execution within the TA context."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "input:283-284",
          "recommendation": "Validate params[0].value.a and params[1].memref.size before use in TEE_Malloc; enforce maximum allocation size (e.g., < 10000)."
        },
        {
          "type": "bounds_check",
          "location": "input:286-287",
          "recommendation": "Check params[2].memref.size <= 1000 before loop; enforce upper bound on copy length."
        },
        {
          "type": "bounds_check",
          "location": "input:290",
          "recommendation": "Validate params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bound on copy length to prevent str overflow."
        },
        {
          "type": "bounds_check",
          "location": "input:291",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "bounds_check",
          "location": "input:306-307",
          "recommendation": "Validate params[2].memref.size and params[3].memref.size <= 1000 before TEE_MemMove; enforce upper bounds on copy lengths."
        },
        {
          "type": "bounds_check",
          "location": "input:309",
          "recommendation": "Check params[2].memref.size >= 1000 before TEE_MemMove; ensure destination is large enough for 1000-byte copy."
        },
        {
          "type": "mem_access_check",
          "location": "input:293,295,296",
          "recommendation": "Validate array indices (params[3].memref.size - 3, params[0].value.a - 3, 30 - params[0].value.a) before use; enforce bounds on str and params[3].memref.buffer access."
        }
      ],
      "decision_rationales": [
        "All five target sink lines exhibit direct taint propagation from REE-originated TEE_Param fields to TEE_MemMove copy_len arguments without effective bounds validation. Lines 290, 306, 307 copy from REE-visible buffers with tainted sizes into fixed-size TEE-private destination (str, 1000 bytes), risking stack/heap overflow. Lines 291, 309 copy fixed 1000 bytes into REE-visible destination with tainted size, risking shared-memory overflow. The type_validation sanitizer at line 277 is insufficient (only checks param_types, not memref sizes). The bounds_check at line 298 is insufficient (only checks params[1].memref.size > 10000, does not protect params[2] or params[3], and allows allocation up to 10000 bytes). No other sanitizers block the taint flow. This is a classic CWE-120/121/122 buffer overflow vulnerability with critical severity."
      ],
      "severity_distribution": {
        "critical": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0033",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 350,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120",
      "functions": [
        "produce_s"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "TOCTOU race: REE-tainted size checked at line 346 but may change before TEE_MemMove at line 350, enabling overflow of 1000-byte buffer."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "shared_memory",
          "produce_s",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated params[0].memref.size (untrusted shared memory size field)",
          "propagation_path": [
            "params[0].memref.size (REE-visible) -> sz @ shared_memory:423",
            "sz -> size @ produce_s:332",
            "size -> TEE_MemMove length argument @ produce_s:350"
          ],
          "sink": "TEE_MemMove(str, buf, size) where str is fixed 1000-byte stack buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "REE can invoke TA_HELLO_WORLD_CMD_SHM command",
            "REE can provide MEMREF_INOUT parameter with arbitrary size field",
            "REE can modify size field between bounds check (line 346) and TEE_MemMove call (line 350)"
          ],
          "attack_scenario": "REE sets params[0].memref.size to 1000 (passes check at line 346), then modifies it to a larger value (e.g., 2000) before TEE_MemMove executes. TEE_MemMove copies 2000 bytes into 1000-byte buffer, causing stack overflow.",
          "impact": "Stack buffer overflow enabling arbitrary code execution, privilege escalation, or denial of service within the TA context."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "produce_s:350",
          "recommendation": "Re-validate size immediately before TEE_MemMove call, or copy size to a local TEE-private variable at function entry and use that copy throughout."
        },
        {
          "type": "mem_access_check",
          "location": "produce_s:350",
          "recommendation": "Use a safer copy function that enforces destination size limit (e.g., TEE_MemMove with explicit min(size, 1000)) or validate size is exactly 1000 before copy."
        }
      ],
      "decision_rationales": [
        "The vulnerability is a classic TOCTOU (Time-of-Check-Time-of-Use) race condition combined with buffer overflow. The bounds check at line 346 validates size <= 1000, but because size is a REE-tainted field in shared memory, the REE can modify it after the check but before the TEE_MemMove call at line 350. This allows an attacker to bypass the bounds check and overflow the 1000-byte stack buffer str. The taint flow is direct (REE  params  sz  size  TEE_MemMove), the destination is fixed-size and TEE-private, and there is no effective re-validation or atomic read of the size value."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0034",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 401,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120"
      ],
      "rule_ids": [
        "shared_memory_overwrite"
      ],
      "descriptions": [
        "TOCTOU buffer overflow: REE-tainted size used to copy into fixed-size TEE-private buffer without atomic validation."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "shared_memory",
          "produce_s3",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated params[0].memref.size from TA_InvokeCommandEntryPoint",
          "propagation_path": [
            "params[0].memref.size (REE-tainted) @ TA_InvokeCommandEntryPoint:502",
            "sz = params[0].memref.size @ produce_s3:358",
            "params[0].memref.size @ produce_s3:401 (TEE_MemMove call)"
          ],
          "sink": "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size) @ produce_s3:401"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "Attacker controls params[0].memref.size from Normal World",
            "Attacker can modify params[0].memref.size between bounds check (line 397) and TEE_MemMove call (line 401)",
            "TEE_MemMove copies from REE-visible buffer into fixed-size TEE-private buffer str[1000]"
          ],
          "attack_scenario": "REE attacker passes params[0].memref.size = 500 (passes check at line 397), then modifies it to 2000 before TEE_MemMove executes, causing 1000-byte overflow into str and adjacent TEE-private memory.",
          "impact": "Buffer overflow in TEE-private memory; potential code execution, privilege escalation, or disclosure of TA secrets."
        }
      ],
      "missing_mitigations": [
        {
          "type": "mem_access_check",
          "location": "produce_s3:401",
          "recommendation": "Copy params[0].memref.size to a local TEE-private variable before bounds check, then use that local variable in TEE_MemMove to prevent TOCTOU."
        },
        {
          "type": "bounds_check",
          "location": "produce_s3:397",
          "recommendation": "Validate size immediately before TEE_MemMove, or use min(sz, 1000) as copy length to enforce hard limit."
        }
      ],
      "decision_rationales": [
        "The vulnerability is a classic TOCTOU (Time-of-Check-Time-of-Use) buffer overflow. Although a bounds check exists at line 397 (sz > 1000), it operates on a REE-tainted value that can be modified by the attacker between the check and the actual TEE_MemMove call at line 401. The copy length is not cached in a TEE-private variable, allowing the REE to change params[0].memref.size after validation. This violates memory safety (CWE-120: Buffer Copy without Checking Size of Input) and is exploitable for heap corruption or information disclosure."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      }
    },
    {
      "vulnerability_id": "VULN-0035",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 485,
      "consolidated": true,
      "detection_count": 1,
      "severity": "high",
      "confidence_level": "high",
      "primary_vulnerability_type": "CWE-120 (Buffer Overflow) / CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "TEE_MemMove"
      ],
      "vulnerability_types": [
        "CWE-120 (Buffer Overflow) / CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)"
      ],
      "rule_ids": [
        "weak_input_validation"
      ],
      "descriptions": [
        "Tainted REE-originated size (params[0].memref.size) used as copy length without re-validation at call site; bounds check at line 481 uses local sz, creating TOCTOU vulnerability."
      ],
      "chains": [
        [
          "TA_InvokeCommandEntryPoint",
          "shared_memory",
          "TEE_MemMove"
        ]
      ],
      "taint_flow_summaries": [
        {
          "source": "REE-originated params[0].memref.size (untrusted length from Normal World)",
          "propagation_path": [
            "params[0].memref.size (REE-visible) @ /workspace/benchmark/bad-partitioning/ta/entry.c:423",
            "sz = params[0].memref.size @ /workspace/benchmark/bad-partitioning/ta/entry.c:423",
            "bounds check: if (sz > 1000) @ /workspace/benchmark/bad-partitioning/ta/entry.c:481",
            "TEE_MemMove(..., params[0].memref.size) @ /workspace/benchmark/bad-partitioning/ta/entry.c:485"
          ],
          "sink": "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size) copying into fixed 1000-byte stack buffer"
        }
      ],
      "exploitation_analyses": [
        {
          "preconditions": [
            "REE can invoke TA_HELLO_WORLD_CMD_SHM command",
            "REE provides MEMREF_INOUT parameter with crafted size value",
            "REE modifies params[0].memref.size between bounds check (line 481) and TEE_MemMove call (line 485), or the bounds check uses a stale local copy"
          ],
          "attack_scenario": "Attacker in Normal World calls shared_memory() with params[0].memref.size = 2000. Local variable sz is set to 2000, bounds check passes (sz > 1000 is false if sz was capped), but then REE modifies params[0].memref.size back to 2000 before line 485 executes. TEE_MemMove copies 2000 bytes into str[1000], overflowing the stack buffer.",
          "impact": "Stack buffer overflow leading to TA crash, information disclosure of TA memory, or potential code execution within the TA context."
        }
      ],
      "missing_mitigations": [
        {
          "type": "bounds_check",
          "location": "shared_memory:485",
          "recommendation": "Re-validate params[0].memref.size immediately before TEE_MemMove, or use the local variable sz (which was already bounds-checked) instead of re-reading params[0].memref.size."
        },
        {
          "type": "mem_access_check",
          "location": "shared_memory:485",
          "recommendation": "Use a safe wrapper that enforces min(copy_len, dst_sz) to prevent overflow regardless of input."
        }
      ],
      "decision_rationales": [
        "The vulnerability is a classic TOCTOU (Time-of-Check-Time-of-Use) buffer overflow. The bounds check at line 481 validates the local variable sz against 1000, but the actual TEE_MemMove call at line 485 uses params[0].memref.size directly. Since params[0].memref.size is REE-visible shared memory, the REE can modify it between the check and the use. Additionally, even if TOCTOU is not exploited, the code pattern shows that the bounds check result (sz) is not used at the sink; instead, the unchecked params[0].memref.size is passed directly to TEE_MemMove. This is a clear weak_input_validation vulnerability."
      ],
      "severity_distribution": {
        "high": 1
      },
      "rule_distribution": {
        "weak_input_validation": 1
      }
    }
  ],
  "total_finding_lines": 61,
  "structural_risks": [
    {
      "finding_id": "RISK-0001",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 116,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce_2",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[1].memref.buffer written with TA-private key2; no bounds check on strlen(key2) against params[1].memref.size",
        "REE-visible destination params[1].memref.buffer receives TA-private source key2; copy length strlen(key2) not validated against params[1].memref.size"
      ],
      "code_excerpts": [
        "TEE_MemMove(params[1].memref.buffer, key2, strlen(key2));"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=strlen(key2),src_sz=1000,dst_sz=params[1].memref.size"
        ]
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0002",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 117,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce_2",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2; REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key2; REE-tainted size parameter used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key2);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0003",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 121,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce_2",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2 and vi; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2 and vi; REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key2 and vi; REE-tainted size parameter used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key2, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0004",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 122,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce_2",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2, vi, and v; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2, vi, and v; REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key2, vi, and v; REE-tainted size parameter used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s-%d\", key2, vi, v);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0005",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 125,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce_2",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2 (post-encryption); REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2 (post-encryption); REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key2 (post-encryption); REE-tainted size parameter used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key2);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0006",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 126,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce_2",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2 and vi (post-encryption); REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key2 and vi (post-encryption); REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key2 and vi (post-encryption); REE-tainted size parameter used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key2, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0007",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 136,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[1].memref.buffer written with TA-private key1; no bounds check on strlen(key1) against params[1].memref.size",
        "REE-visible destination params[1].memref.buffer receives TA-private source key1; copy length strlen(key1) not validated against params[1].memref.size",
        "REE-visible destination params[1].memref.buffer written with TA-private source key1; copy length strlen(key1) not validated against destination size"
      ],
      "code_excerpts": [
        "TEE_MemMove(params[1].memref.buffer, key1, strlen(key1));"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=strlen(key1),src_sz=1000,dst_sz=params[1].memref.size"
        ]
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0008",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 137,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key1; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key1; REE-tainted size parameter used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key1; REE-tainted size n (params[2].memref.size) used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key1);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=n"
        ]
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0009",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 143,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key1 and vi; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key1 and vi; REE-tainted size parameter used as bound without validation",
        "REE-visible buffer written via snprintf with TA-private data; REE-tainted size used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key1 and vi; REE-tainted size n (params[2].memref.size) used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key1, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=n"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0010",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 144,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key1, vi, and v; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key1, vi, and v; REE-tainted size parameter used as bound without validation",
        "REE-visible buffer written via snprintf with TA-private data; REE-tainted size used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key1, vi, and v; REE-tainted size n (params[2].memref.size) used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s-%d\", key1, vi, v);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=n"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0011",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 147,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key1 (post-encryption); REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key1 (post-encryption); REE-tainted size parameter used as bound without validation",
        "REE-visible buffer written via snprintf with TA-private key (post-encryption); REE-tainted size used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key1 (post-encryption); REE-tainted size n (params[2].memref.size) used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key1);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=n"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0012",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 148,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key1 and vi (post-encryption); REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key1 and vi (post-encryption); REE-tainted size parameter used as bound without validation",
        "REE-visible buffer written via snprintf with TA-private data (post-encryption); REE-tainted size used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key1 and vi (post-encryption); REE-tainted size n (params[2].memref.size) used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key1, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=n"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0013",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 154,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "TEE_MemMove",
        "produce_3"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination buf (REE-visible shared buffer) receives TA-private source key; copy length strlen(key) not validated against size parameter",
        "REE-visible buffer buf written with TA-private key; no bounds check on strlen(key) against REE-tainted size parameter",
        "alias of REE-visible buffer dest (params[1].memref.buffer from produce_3 caller) written with TA-private src (key); size strlen(key) not validated against REE-tainted buffer size"
      ],
      "code_excerpts": [
        "TEE_MemMove(buf, key, strlen(key));"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=size",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0014",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 155,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "snprintf",
        "produce_3"
      ],
      "sink_functions": [
        "=",
        "snprintf"
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer str (buf parameter) written with TA-private key; REE-tainted size parameter used as bound without validation",
        "REE-visible buffer s (buf from caller produce_3) written with TA-private key; REE-tainted size n (size from caller) used as bound without validation",
        "REE-visible buffer buf written with TA-private key; REE-tainted size n used as bound without validation",
        "REE-visible buffer buf written via snprintf with TA-private key; REE-tainted size parameter used as bound without validation",
        "REE-visible buffer buf written via snprintf; REE-tainted size parameter used as bound without validation"
      ],
      "code_excerpts": [
        "snprintf(buf, size, \"%s\", key);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=size",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=n"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0015",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 175,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "output",
        "TEE_MemMove"
      ],
      "sink_functions": [
        "TEE_MemMove",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[1].memref.buffer written with TA-private key; no bounds check on strlen(key) against params[1].memref.size",
        "REE-visible destination params[1].memref.buffer receives TA-private source key; copy length strlen(key) not validated against params[1].memref.size",
        "REE-visible buffer dest (params[1].memref.buffer) written with TA-private src (key); size strlen(key) not validated against REE-tainted params[1].memref.size",
        "Buffer overflow: strlen(key)=6 copied into REE-visible params[1].memref.buffer with untrusted size; no bounds check",
        "REE-visible destination params[1].memref.buffer written with TA-private key; copy length strlen(key) not validated against destination size",
        "REE-visible buffer params[1].memref.buffer written with TA-private key; no bounds check on strlen(key) against params[1].memref.size; potential buffer overflow."
      ],
      "code_excerpts": [
        "TEE_MemMove(params[1].memref.buffer, key, strlen(key));"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=params[1].memref.size",
          "size_triplet:copy_len=strlen(key),src_sz=1000,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0016",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 176,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "output",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key; REE-tainted size parameter used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key; REE-tainted size n (params[2].memref.size) used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-tainted size params[2].memref.size used as snprintf bound without validation; TA-private key written to REE-visible buffer",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key; REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer params[2].memref.buffer is destination; REE-tainted size params[2].memref.size used as bound without validation; no effective bounds check against actual buffer capacity"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=n",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0017",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 179,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "output"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted value params[0].value.b assigned to params[0].value.a without validation; downstream use at line 186 may propagate untrusted value",
        "REE-tainted value params[0].value.b assigned to params[0].value.a without validation; downstream use may propagate untrusted value",
        "REE-tainted value params[0].value.b assigned to params[0].value.a without validation; downstream use at line 186 may propagate untrusted value."
      ],
      "code_excerpts": [
        "params[0].value.a = params[0].value.b;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=4,src_sz=4,dst_sz=4"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0018",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 184,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "output",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key and vi; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key and vi; REE-tainted size parameter used as bound without validation",
        "REE-visible buffer written via snprintf with TA-private data; REE-tainted size used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key and vi; REE-tainted size n (params[2].memref.size) used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-tainted size params[2].memref.size used as snprintf bound without validation; TA-private key and vi written to REE-visible buffer",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key and vi; REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer params[2].memref.buffer is destination; REE-tainted size params[2].memref.size used as bound without validation; no effective bounds check against actual buffer capacity"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=n",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0019",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 185,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "output",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key, vi, and v; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key, vi, and v; REE-tainted size parameter used as bound without validation",
        "REE-visible buffer written via snprintf with TA-private data; REE-tainted size used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key, vi, and v; REE-tainted size n (params[2].memref.size) used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-tainted size params[2].memref.size used as snprintf bound without validation; TA-private key, vi, and v written to REE-visible buffer",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key, vi, and v; REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer params[2].memref.buffer is destination; REE-tainted size params[2].memref.size used as bound without validation; no effective bounds check against actual buffer capacity"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s-%d\", key, vi, v);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=n",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0020",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 189,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "output",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key (post-encryption); REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key (post-encryption); REE-tainted size parameter used as bound without validation",
        "REE-visible buffer written via snprintf with TA-private key (post-encryption); REE-tainted size used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key (post-encryption); REE-tainted size n (params[2].memref.size) used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-tainted size params[2].memref.size used as snprintf bound without validation; encrypted key written to REE-visible buffer",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key (post-encryption); REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer params[2].memref.buffer is destination; REE-tainted size params[2].memref.size used as bound without validation; no effective bounds check against actual buffer capacity"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s\", key);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=1000,dst_sz=n",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0021",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 190,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "output",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key and vi (post-encryption); REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key and vi (post-encryption); REE-tainted size parameter used as bound without validation",
        "REE-visible buffer written via snprintf with TA-private data (post-encryption); REE-tainted size used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key and vi (post-encryption); REE-tainted size n (params[2].memref.size) used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-tainted size params[2].memref.size used as snprintf bound without validation; encrypted key and vi written to REE-visible buffer",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key and vi (post-encryption); REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer params[2].memref.buffer is destination; REE-tainted size params[2].memref.size used as bound without validation; no effective bounds check against actual buffer capacity"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s\", key, vi);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=n",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0022",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 191,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "output",
        "snprintf"
      ],
      "sink_functions": [
        "snprintf",
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key, vi, and v (post-encryption); REE-tainted size params[2].memref.size used as bound without validation",
        "REE-visible buffer str (params[2].memref.buffer) written with TA-private key, vi, and v (post-encryption); REE-tainted size parameter used as bound without validation",
        "REE-visible buffer written via snprintf with TA-private data (post-encryption); REE-tainted size used as bound without validation",
        "REE-visible buffer s (params[2].memref.buffer) written with TA-private key, vi, and v (post-encryption); REE-tainted size n (params[2].memref.size) used as bound without validation",
        "REE-visible buffer params[2].memref.buffer written via snprintf; REE-tainted size params[2].memref.size used as bound without validation",
        "REE-tainted size params[2].memref.size used as snprintf bound without validation; encrypted key, vi, and v written to REE-visible buffer",
        "REE-visible buffer params[2].memref.buffer written via snprintf with TA-private key, vi, and v (post-encryption); REE-tainted size params[2].memref.size used as bound without validation.",
        "REE-visible buffer params[2].memref.buffer is destination; REE-tainted size params[2].memref.size used as bound without validation; no effective bounds check against actual buffer capacity"
      ],
      "code_excerpts": [
        "snprintf(params[2].memref.buffer, params[2].memref.size, \"%s-%s-%d\", key, vi, v);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=params[2].memref.size",
          "size_triplet:copy_len=unknown,src_sz=2000,dst_sz=n",
          "src_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=params[2].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0023",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 201,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size argument is tainted REE value (a) without bounds check; unbounded allocation from untrusted input"
      ],
      "code_excerpts": [
        "int *arr_a = TEE_Malloc(a, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=a,src_sz=unknown,dst_sz=a"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0024",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 202,
      "consolidated": true,
      "detection_count": 1,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size argument is tainted REE value (b) without bounds check; unbounded allocation from untrusted input"
      ],
      "code_excerpts": [
        "int *arr_ref = TEE_Malloc(b, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=b,src_sz=unknown,dst_sz=b"
        ]
      },
      "rule_distribution": {
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0025",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 203,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "array index is tainted REE value (a) without bounds check; tmp_arr has fixed size 20, index may be out-of-bounds",
        "Array index is tainted REE value (a) without bounds check; tmp_arr has fixed size 20, index may be out-of-bounds."
      ],
      "code_excerpts": [
        "tmp_arr[a] = 43;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=20,dst_sz=20"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0026",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 204,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "loop bound is tainted REE value (size2) without prior bounds check; unbounded iteration over REE-visible buffer",
        "Loop bound is tainted REE value (size2) without prior bounds check; unbounded iteration over REE-visible buffer."
      ],
      "code_excerpts": [
        "for (int i = 0; i < size2; i++)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size2,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0027",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 205,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce_i2"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "per-byte copy from REE-visible buf2 into TEE-private str; loop bound is tainted (size2) without bounds check; str is 1000 bytes, copy may overflow",
        "Per-byte copy from REE-visible buf2 into TEE-private str; loop bound is tainted (size2) without bounds check; str is 1000 bytes, copy may overflow."
      ],
      "code_excerpts": [
        "str[i] = ((char *)buf2)[i];"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size2,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0028",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 208,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "input",
        "output",
        "produce_i2"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives REE-visible source params[3].memref.buffer; copy length params[3].memref.size is REE-tainted and not validated",
        "REE-visible source params[3].memref.buffer and REE-tainted size params[3].memref.size copied into TA-private str without validation",
        "REE-visible source and REE-tainted size copied into TA-private buffer without validation",
        "alias of REE-visible buffer src (params[3].memref.buffer) and REE-tainted size (params[3].memref.size) copied into TA-private dest (str) without validation",
        "Buffer overflow: REE-tainted params[3].memref.size copied into fixed TA-private buffer str[1000] without bounds check; potential over-read from REE or over-write into TA memory",
        "REE-visible source params[3].memref.buffer and REE-tainted length params[3].memref.size copied into TA-private str without bounds validation",
        "REE-visible source params[3].memref.buffer and REE-tainted length params[3].memref.size copied into TA-private str without bounds validation.",
        "TEE_MemMove copy length is tainted REE value (params[3].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "copy length is tainted REE value (params[3].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[3].memref.size,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0029",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 210,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "input",
        "produce_i2"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted index params[0].value.a - 3 used to access str without bounds check after copying REE data",
        "REE-tainted index used to access array without bounds check",
        "array index is tainted REE value (params[0].value.a - 3) without bounds check; read from TEE-private str (1000 bytes) may be out-of-bounds",
        "Array index is tainted REE value (params[0].value.a - 3) without bounds check; read from TEE-private str (1000 bytes) may be out-of-bounds."
      ],
      "code_excerpts": [
        "char c = str[params[0].value.a - 3];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=1000,dst_sz=1000",
          "size_triplet:copy_len=1,src_sz=1000,dst_sz=1"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0030",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 212,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "input",
        "output",
        "produce_i2"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives REE-visible source params[2].memref.buffer; copy length params[2].memref.size is REE-tainted and not validated",
        "REE-visible source params[2].memref.buffer and REE-tainted size params[2].memref.size copied into TA-private str without validation",
        "REE-visible source and REE-tainted size copied into TA-private buffer without validation",
        "alias of REE-visible buffer src (params[2].memref.buffer) and REE-tainted size (params[2].memref.size) copied into TA-private dest (str) without validation",
        "Buffer overflow: REE-tainted params[2].memref.size copied into fixed TA-private buffer str[1000] without bounds check; potential over-read from REE or over-write into TA memory",
        "REE-visible source params[2].memref.buffer and REE-tainted length params[2].memref.size copied into TA-private str without bounds validation",
        "REE-visible source params[2].memref.buffer and REE-tainted length params[2].memref.size copied into TA-private str without bounds validation.",
        "TEE_MemMove copy length is tainted REE value (params[2].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "copy length is tainted REE value (params[2].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[2].memref.buffer, params[2].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[2].memref.size,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0031",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 220,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size argument is tainted REE value (a) without bounds check; unbounded allocation from untrusted input",
        "Unbounded allocation from tainted REE value (a) without size validation; potential DoS or heap exhaustion"
      ],
      "code_excerpts": [
        "int *arr_a = TEE_Malloc(a, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=a,src_sz=unknown,dst_sz=a"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0032",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 221,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size argument is tainted REE value (b) without bounds check; unbounded allocation from untrusted input",
        "Unbounded allocation from tainted REE value (b) without size validation; potential DoS or heap exhaustion"
      ],
      "code_excerpts": [
        "int *arr_ref = TEE_Malloc(b, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=b,src_sz=unknown,dst_sz=b"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0033",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 222,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "array index is tainted REE value (a) without bounds check; tmp_arr has fixed size 20, index may be out-of-bounds",
        "Array index is tainted REE value (a) without bounds check; tmp_arr has fixed size 20, out-of-bounds write possible"
      ],
      "code_excerpts": [
        "tmp_arr[a] = 43;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=20,dst_sz=20"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0034",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 223,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "loop bound is tainted REE value (size2) without prior bounds check; unbounded iteration over REE-visible buffer",
        "Loop bound is tainted REE value (size2) without prior bounds check; unbounded iteration over REE-visible buffer"
      ],
      "code_excerpts": [
        "for (int i = 0; i < size2; i++)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size2,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0035",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 224,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "per-byte copy from REE-visible buf2 into TEE-private str; loop bound is tainted (size2) without bounds check; str is 1000 bytes, copy may overflow",
        "Per-byte copy from REE-visible buf2 into TEE-private str; loop bound is tainted (size2) without bounds check; str is 1000 bytes, copy may overflow"
      ],
      "code_excerpts": [
        "str[i] = ((char *)buf2)[i];"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size2,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0036",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 227,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_i",
        "produce_i0"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives source buf3; copy length size3 is REE-tainted parameter and not validated",
        "alias of REE-visible buffer src (buf3) and REE-tainted size (size3) copied into TA-private dest (str) without validation; buf3 and size3 originate from REE-visible params",
        "Buffer overflow: REE-tainted size3 copied into fixed TA-private buffer str[1000] without bounds check; size3 originates from REE-visible params",
        "REE-tainted length size3 (propagated from params) used to copy buf3 into TA-private str without bounds validation",
        "TEE_MemMove copy length is tainted REE value (size3) without bounds check; destination str is 1000 bytes, copy may overflow",
        "copy length is tainted REE value (size3) without bounds check; destination str is 1000 bytes, copy may overflow"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, buf3, size3);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size3,src_sz=unknown,dst_sz=1000",
          "src_region:REE-visible"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0037",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 231,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_i0"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "array index is tainted REE value (a - 3) without bounds check; read from TEE-private str (1000 bytes) may be out-of-bounds",
        "Array index is tainted REE value (a - 3) without bounds check; read from TEE-private str (1000 bytes) may be out-of-bounds"
      ],
      "code_excerpts": [
        "char c = str[a - 3];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=1000,dst_sz=1"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0038",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 238,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_i",
        "produce_i0"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives source buf2; copy length size2 is REE-tainted parameter and not validated",
        "alias of REE-visible buffer src (buf2) and REE-tainted size (size2) copied into TA-private dest (str) without validation; buf2 and size2 originate from REE-visible params",
        "Buffer overflow: REE-tainted size2 copied into fixed TA-private buffer str[1000] without bounds check; size2 originates from REE-visible params",
        "REE-tainted length size2 (propagated from params) used to copy buf2 into TA-private str without bounds validation",
        "TEE_MemMove copy length is tainted REE value (size2) without bounds check; destination str is 1000 bytes, copy may overflow",
        "copy length is tainted REE value (size2) without bounds check; destination str is 1000 bytes, copy may overflow"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, buf2, size2);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size2,src_sz=unknown,dst_sz=1000",
          "src_region:REE-visible"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0039",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 239,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_i",
        "produce_i0"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives source buf3; copy length size3 is REE-tainted parameter and not validated",
        "alias of REE-visible buffer src (buf3) and REE-tainted size (size3) copied into TA-private dest (str) without validation; buf3 and size3 originate from REE-visible params",
        "Buffer overflow: REE-tainted size3 copied into fixed TA-private buffer str[1000] without bounds check; size3 originates from REE-visible params",
        "REE-tainted length size3 (propagated from params) used to copy buf3 into TA-private str without bounds validation",
        "TEE_MemMove copy length is tainted REE value (size3) without bounds check; destination str is 1000 bytes, copy may overflow",
        "copy length is tainted REE value (size3) without bounds check; destination str is 1000 bytes, copy may overflow"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, buf3, size3);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:unknown",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size3,src_sz=unknown,dst_sz=1000",
          "src_region:REE-visible"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0040",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 246,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "TEE_MemMove",
        "produce_i",
        "produce_i0"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible destination buf2 receives TEE-private source str; fixed copy length 1000 may exceed buf2 capacity if size2 < 1000",
        "REE-visible buffer dest (buf2) written with TA-private src (str); size 1000 fixed but buf2 size unknown and REE-tainted",
        "Buffer overflow: fixed 1000-byte copy into REE-visible buf2 with unknown/untrusted size; no bounds check",
        "TEE_MemMove writes into REE-visible buf2 with fixed size 1000; destination size is tainted (size2) and may be smaller than 1000 due to insufficient bounds check at line 241 (only checks < 1000, allowing 0-999), causing buffer overflow into REE-shared memory",
        "writes into REE-visible buf2 with fixed size 1000; destination size is tainted (size2) and may be smaller than 1000, causing buffer overflow into REE-shared memory"
      ],
      "code_excerpts": [
        "TEE_MemMove(buf2, str, 1000);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=1000,src_sz=1000,dst_sz=size2",
          "size_triplet:copy_len=1000,src_sz=1000,dst_sz=unknown",
          "sensitivity_label:unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0041",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 283,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size argument is tainted REE value (params[0].value.a) without bounds check; unbounded allocation from untrusted input",
        "TEE_Malloc size argument is tainted REE value (params[0].value.a) without bounds check; unbounded allocation from untrusted input."
      ],
      "code_excerpts": [
        "int *arr_a = TEE_Malloc(params[0].value.a, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[0].value.a,src_sz=unknown,dst_sz=params[0].value.a"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0042",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 284,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size argument is tainted REE value (params[1].memref.size) without bounds check before line 298; unbounded allocation from untrusted input",
        "TEE_Malloc size argument is tainted REE value (params[1].memref.size) without bounds check before line 298; unbounded allocation from untrusted input."
      ],
      "code_excerpts": [
        "int *arr_ref = TEE_Malloc(params[1].memref.size, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[1].memref.size,src_sz=unknown,dst_sz=params[1].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0043",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 285,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "array index is tainted REE value (params[0].value.a) without bounds check; tmp_arr has fixed size 20, index may be out-of-bounds",
        "Array index is tainted REE value (params[0].value.a) without bounds check; tmp_arr has fixed size 20, index may be out-of-bounds."
      ],
      "code_excerpts": [
        "tmp_arr[params[0].value.a] = 43;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=20,dst_sz=20"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0044",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 286,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "unknown"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "loop bound is tainted REE value (params[2].memref.size) without prior bounds check; unbounded iteration over REE-visible buffer",
        "Loop bound is tainted REE value (params[2].memref.size) without prior bounds check; unbounded iteration over REE-visible buffer."
      ],
      "code_excerpts": [
        "for (int i = 0; i < params[2].memref.size; i++)"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[2].memref.size,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0045",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 287,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "per-byte copy from REE-visible params[2].memref.buffer into TEE-private str; loop bound is tainted (params[2].memref.size) without bounds check; str is 1000 bytes, copy may overflow",
        "Per-byte copy from REE-visible params[2].memref.buffer into TEE-private str; loop bound is tainted (params[2].memref.size) without bounds check; str is 1000 bytes, copy may overflow."
      ],
      "code_excerpts": [
        "str[i] = ((char *)params[2].memref.buffer)[i];"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[2].memref.size,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0046",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 290,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_i1",
        "produce_i0",
        "input"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives REE-visible source params[3].memref.buffer; copy length params[3].memref.size is REE-tainted and not validated",
        "REE-visible source params[3].memref.buffer and REE-tainted size params[3].memref.size copied into TA-private str without validation",
        "REE-visible source and REE-tainted size copied into TA-private buffer without validation",
        "alias of REE-visible buffer src (params[3].memref.buffer) and REE-tainted size (params[3].memref.size) copied into TA-private dest (str) without validation",
        "Buffer overflow: REE-tainted params[3].memref.size copied into fixed TA-private buffer str[1000] without bounds check",
        "REE-visible source params[3].memref.buffer and REE-tainted length params[3].memref.size copied into TA-private str without bounds validation",
        "TEE_MemMove copy length is tainted REE value (params[3].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "copy length is tainted REE value (params[3].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "source pointer params[3].memref.buffer is REE-visible (untrusted); copy length params[3].memref.size is tainted without bounds check; destination str is 1000 bytes, copy may overflow"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[3].memref.size,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0047",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 291,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "TEE_MemMove",
        "produce_i1",
        "produce_i0",
        "input"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible destination params[2].memref.buffer receives TEE-private source str; fixed copy length 1000 may exceed params[2].memref.size",
        "REE-visible destination params[2].memref.buffer written with TA-private source str (containing REE data); fixed copy length 1000 not validated against destination size",
        "REE-visible destination written with fixed 1000 bytes; destination size not validated",
        "REE-visible buffer dest (params[2].memref.buffer) written with TA-private src (str); size 1000 fixed but params[2].memref.size is REE-tainted and unknown",
        "Buffer overflow: fixed 1000-byte copy into REE-visible params[2].memref.buffer with untrusted size; no bounds check",
        "REE-visible destination params[2].memref.buffer written with TA-private str; fixed copy length 1000 may exceed destination size",
        "TEE_MemMove writes into REE-visible params[2].memref.buffer (MEMREF_INOUT) from TEE-private str with fixed size 1000; destination size is tainted (params[2].memref.size) and may be smaller than 1000, causing buffer overflow into REE-shared memory",
        "writes into REE-visible params[2].memref.buffer with fixed size 1000; destination size is tainted (params[2].memref.size) and may be smaller than 1000, causing buffer overflow into REE-shared memory",
        "writes into REE-visible params[2].memref.buffer (MEMREF_INOUT) with fixed size 1000; destination size is tainted (params[2].memref.size) and may be smaller than 1000, causing buffer overflow into REE-shared memory",
        "destination params[2].memref.buffer is REE-visible (MEMREF_INOUT); copy length is fixed 1000 bytes but destination size params[2].memref.size is tainted and may be smaller, causing buffer overflow into shared memory"
      ],
      "code_excerpts": [
        "TEE_MemMove(params[2].memref.buffer, str, 1000);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=1000,src_sz=1000,dst_sz=params[2].memref.size",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1000,src_sz=1000,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0048",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 293,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_i1",
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-tainted index params[3].memref.size - 3 used to access REE-visible buffer without bounds check",
        "REE-tainted index used to access REE-visible buffer without bounds check",
        "array index is tainted REE value (params[3].memref.size - 3) without bounds check; read from REE-visible params[3].memref.buffer may be out-of-bounds",
        "Array index is tainted REE value (params[3].memref.size - 3) without bounds check; read from REE-visible params[3].memref.buffer may be out-of-bounds."
      ],
      "code_excerpts": [
        "char c = ((char *)params[3].memref.buffer)[params[3].memref.size - 3];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:unknown",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=unknown,dst_sz=1"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0049",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 295,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "array index is tainted REE value (params[0].value.a - 3) without bounds check; read from TEE-private str (1000 bytes) may be out-of-bounds",
        "Array index is tainted REE value (params[0].value.a - 3) without bounds check; read from TEE-private str (1000 bytes) may be out-of-bounds."
      ],
      "code_excerpts": [
        "c = str[params[0].value.a - 3];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=1000,dst_sz=1"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0050",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 296,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "array_write"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "array index is tainted REE value (30 - params[0].value.a) without bounds check; read from TEE-private str (1000 bytes) may be out-of-bounds if params[0].value.a is large",
        "Array index is tainted REE value (30 - params[0].value.a) without bounds check; read from TEE-private str (1000 bytes) may be out-of-bounds if params[0].value.a is large."
      ],
      "code_excerpts": [
        "c = str[30 - params[0].value.a];"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1,src_sz=1000,dst_sz=1"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0051",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 303,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "input"
      ],
      "sink_functions": [
        "TEE_Malloc"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "TEE_Malloc size argument is tainted REE value (params[1].memref.size); bounds check at line 298 is insufficient (only checks > 10000), allowing allocation up to 10000 bytes from untrusted input",
        "TEE_Malloc size argument is tainted REE value (params[1].memref.size); bounds check at line 298 is insufficient (only checks > 10000), allowing allocation up to 10000 bytes from untrusted input."
      ],
      "code_excerpts": [
        "int *arr_path = TEE_Malloc(params[1].memref.size, 0);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[1].memref.size,src_sz=unknown,dst_sz=params[1].memref.size"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0052",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 306,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_i0",
        "input"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives REE-visible source params[2].memref.buffer; copy length params[2].memref.size is REE-tainted and not validated",
        "REE-visible source params[2].memref.buffer and REE-tainted size params[2].memref.size copied into TA-private str without validation",
        "REE-visible source and REE-tainted size copied into TA-private buffer without validation",
        "alias of REE-visible buffer src (params[2].memref.buffer) and REE-tainted size (params[2].memref.size) copied into TA-private dest (str) without validation",
        "Buffer overflow: REE-tainted params[2].memref.size copied into fixed TA-private buffer str[1000] without bounds check",
        "REE-visible source params[2].memref.buffer and REE-tainted length params[2].memref.size copied into TA-private str without bounds validation",
        "TEE_MemMove copy length is tainted REE value (params[2].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "copy length is tainted REE value (params[2].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "source pointer params[2].memref.buffer is REE-visible (untrusted); copy length params[2].memref.size is tainted without bounds check; destination str is 1000 bytes, copy may overflow"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[2].memref.buffer, params[2].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[2].memref.size,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0053",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 307,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_i0",
        "input"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives REE-visible source params[3].memref.buffer; copy length params[3].memref.size is REE-tainted and not validated",
        "REE-visible source params[3].memref.buffer and REE-tainted size params[3].memref.size copied into TA-private str without validation",
        "REE-visible source and REE-tainted size copied into TA-private buffer without validation",
        "alias of REE-visible buffer src (params[3].memref.buffer) and REE-tainted size (params[3].memref.size) copied into TA-private dest (str) without validation",
        "Buffer overflow: REE-tainted params[3].memref.size copied into fixed TA-private buffer str[1000] without bounds check",
        "REE-visible source params[3].memref.buffer and REE-tainted length params[3].memref.size copied into TA-private str without bounds validation",
        "TEE_MemMove copy length is tainted REE value (params[3].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "copy length is tainted REE value (params[3].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "source pointer params[3].memref.buffer is REE-visible (untrusted); copy length params[3].memref.size is tainted without bounds check; destination str is 1000 bytes, copy may overflow"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[3].memref.buffer, params[3].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[3].memref.size,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0054",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 309,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "TEE_MemMove",
        "produce_i0",
        "input"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "REE-visible destination params[2].memref.buffer receives TEE-private source str; fixed copy length 1000 may exceed params[2].memref.size",
        "REE-visible destination params[2].memref.buffer written with TA-private source str (containing REE data); fixed copy length 1000 not validated against destination size",
        "REE-visible destination written with fixed 1000 bytes; destination size not validated",
        "REE-visible buffer dest (params[2].memref.buffer) written with TA-private src (str); size 1000 fixed but params[2].memref.size is REE-tainted and unknown",
        "Buffer overflow: fixed 1000-byte copy into REE-visible params[2].memref.buffer with untrusted size; no bounds check",
        "REE-visible destination params[2].memref.buffer written with TA-private str; fixed copy length 1000 may exceed destination size",
        "TEE_MemMove writes into REE-visible params[2].memref.buffer (MEMREF_INOUT) from TEE-private str with fixed size 1000; destination size is tainted (params[2].memref.size) and may be smaller than 1000, causing buffer overflow into REE-shared memory",
        "writes into REE-visible params[2].memref.buffer with fixed size 1000; destination size is tainted (params[2].memref.size) and may be smaller than 1000, causing buffer overflow into REE-shared memory",
        "writes into REE-visible params[2].memref.buffer (MEMREF_INOUT) with fixed size 1000; destination size is tainted (params[2].memref.size) and may be smaller than 1000, causing buffer overflow into REE-shared memory",
        "destination params[2].memref.buffer is REE-visible (MEMREF_INOUT); copy length is fixed 1000 bytes but destination size params[2].memref.size is tainted and may be smaller, causing buffer overflow into shared memory"
      ],
      "code_excerpts": [
        "TEE_MemMove(params[2].memref.buffer, str, 1000);"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:TA->REE",
          "src_region:TEE-private",
          "dst_region:REE-visible",
          "sensitivity_label:private",
          "size_triplet:copy_len=1000,src_sz=1000,dst_sz=params[2].memref.size",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=1000,src_sz=1000,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0055",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 350,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_s"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other",
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives source buf; copy length size is REE-tainted parameter and not validated",
        "alias of REE-visible buffer src (buf) and REE-tainted size (size) copied into TA-private dest (str) without validation; buf and size originate from REE-visible params",
        "Buffer overflow: REE-tainted size copied into fixed TA-private buffer str[1000] without bounds check; size originates from REE-visible params",
        "copy length is tainted REE value (size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "source pointer buf is REE-visible (untrusted); copy length size is tainted without bounds check; destination str is 1000 bytes, copy may overflow",
        "tainted size (REE-originated) used as copy length into TEE-private buffer str[1000]; bounds check at line 346 validates size <= 1000 but size is REE-tainted and may change between check and use (TOCTOU)",
        "REE-tainted size parameter used as copy length; bounds check at line 346 validates size <= 1000 but size is REE-tainted and may change between check and use (TOCTOU race)"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, buf, size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=size,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0056",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 357,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of REE-visible shared buffer (params[0].memref.buffer) extracted and used in subsequent operations without persistent bounds validation",
        "Alias of REE-visible shared buffer extracted without persistent bounds validation; used in multiple downstream operations."
      ],
      "code_excerpts": [
        "void *buf = params[0].memref.buffer;"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0057",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 358,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "produce_s3"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "tainted size from REE (params[0].memref.size) extracted without persistent validation; used later in copy operations",
        "REE-tainted size extracted without persistent validation; later used as copy length in TEE_MemMove."
      ],
      "code_excerpts": [
        "uint32_t sz = params[0].memref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0058",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 401,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_s1",
        "produce_s3"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other",
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives REE-visible source params[0].memref.buffer; copy length params[0].memref.size is REE-tainted and not validated",
        "REE-visible source params[0].memref.buffer and REE-tainted size params[0].memref.size copied into TA-private str without validation",
        "REE-visible source and REE-tainted size copied into TA-private buffer without validation",
        "alias of REE-visible buffer src (params[0].memref.buffer) and REE-tainted size (params[0].memref.size) copied into TA-private dest (str) without validation",
        "Buffer overflow: REE-tainted params[0].memref.size copied into fixed TA-private buffer str[1000] without bounds check",
        "REE-visible source params[0].memref.buffer and REE-tainted length params[0].memref.size copied into TA-private str without bounds validation",
        "copy length is tainted REE value (params[0].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "source pointer params[0].memref.buffer is REE-visible (untrusted); copy length params[0].memref.size is tainted without bounds check; destination str is 1000 bytes, copy may overflow",
        "REE-tainted size (params[0].memref.size) used as copy length; no bounds check visible on this path before the call",
        "REE-tainted size (params[0].memref.size) used as copy length; no bounds check visible on this path before the call, enabling potential overflow of 1000-byte buffer.",
        "tainted size (params[0].memref.size) used as copy length into TEE-private buffer str[1000]; bounds check at line 397 validates sz <= 1000 but sz is REE-tainted and may change between check and use (TOCTOU)",
        "REE-tainted size parameter (params[0].memref.size) used to copy from REE-visible buffer into TEE-private destination; bounds check at line 397 is vulnerable to TOCTOU as size may change between validation and use"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[0].memref.size,src_sz=unknown,dst_sz=1000"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0059",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 422,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "shared_memory_overwrite",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "shared_memory_overwrite",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "alias of REE-visible shared buffer (params[0].memref.buffer) extracted and used in subsequent operations without persistent bounds validation",
        "Alias of REE-visible shared buffer (params[0].memref.buffer) extracted into local pointer buf; subsequent operations use this alias without persistent bounds validation."
      ],
      "code_excerpts": [
        "void *buf = params[0].memref.buffer;"
      ],
      "rule_matches": {
        "rule_id": [
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:REE-visible",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0060",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 423,
      "consolidated": true,
      "detection_count": 2,
      "primary_rule": "weak_input_validation",
      "functions": [
        "shared_memory"
      ],
      "sink_functions": [
        "="
      ],
      "rules": [
        "weak_input_validation",
        "other"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "tainted size from REE (params[0].memref.size) extracted without persistent validation; used later in copy operations",
        "Tainted size from REE (params[0].memref.size) extracted without persistent validation; used later in copy operations and passed to callees.",
        "Tainted size from REE (params[0].memref.size) extracted into local variable sz; local bounds check at line 481 validates sz but sink at line 485 re-reads params[0].memref.size directly."
      ],
      "code_excerpts": [
        "uint32_t sz = params[0].memref.size;"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=unknown,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    },
    {
      "finding_id": "RISK-0061",
      "file": "/workspace/benchmark/bad-partitioning/ta/entry.c",
      "line": 485,
      "consolidated": true,
      "detection_count": 3,
      "primary_rule": "weak_input_validation",
      "functions": [
        "TEE_MemMove",
        "produce_s0",
        "produce_s2",
        "shared_memory"
      ],
      "sink_functions": [
        "=",
        "TEE_MemMove"
      ],
      "rules": [
        "weak_input_validation",
        "other",
        "shared_memory_overwrite"
      ],
      "phases": [
        "unknown"
      ],
      "descriptions": [
        "destination str (TEE-private) receives REE-visible source params[0].memref.buffer; copy length params[0].memref.size is REE-tainted and not validated",
        "REE-visible source params[0].memref.buffer and REE-tainted size params[0].memref.size copied into TA-private str without validation",
        "REE-visible source and REE-tainted size copied into TA-private buffer without validation",
        "alias of REE-visible buffer src (params[0].memref.buffer) and REE-tainted size (params[0].memref.size) copied into TA-private dest (str) without validation",
        "Buffer overflow: REE-tainted params[0].memref.size copied into fixed TA-private buffer str[1000] without bounds check",
        "REE-visible source params[0].memref.buffer and REE-tainted length params[0].memref.size copied into TA-private str without bounds validation",
        "copy length is tainted REE value (params[0].memref.size) without bounds check; destination str is 1000 bytes, copy may overflow",
        "source pointer params[0].memref.buffer is REE-visible (untrusted); copy length params[0].memref.size is tainted without bounds check; destination str is 1000 bytes, copy may overflow",
        "tainted size (params[0].memref.size) used as copy length into TEE-private buffer str[1000]; bounds check at line 481 validates sz <= 1000 but sz is REE-tainted and may change between check and use (TOCTOU)",
        "REE-tainted size (params[0].memref.size) used as copy length; bounds check at line 481 validates size <= 1000 but size is REE-tainted and may change between check and use (TOCTOU race)",
        "TOCTOU race: REE-tainted size (params[0].memref.size) checked at line 481 but may change before TEE_MemMove at line 485, enabling overflow of 1000-byte buffer.",
        "REE-tainted size parameter (params[0].memref.size) used to copy from REE-visible buffer into TEE-private destination; bounds check at line 481 is vulnerable to TOCTOU as size may change between validation and use",
        "Identical TOCTOU vulnerability in shared_memory() at line 485; REE-tainted size used to copy into fixed-size buffer str[1000] with insufficient protection.",
        "REE-visible source buffer (params[0].memref.buffer) aliased as first argument; tainted size (params[0].memref.size) used as copy length without re-validation at call site (TOCTOU: bounds check at line 481 used local sz, not params[0].memref.size)",
        "tainted size parameter (params[0].memref.size) passed directly to TEE_MemMove without re-validation; REE may have modified memref.size between bounds check and this call"
      ],
      "code_excerpts": [
        "TEE_MemMove(str, params[0].memref.buffer, params[0].memref.size);"
      ],
      "rule_matches": {
        "rule_id": [
          "weak_input_validation",
          "shared_memory_overwrite"
        ],
        "others": [
          "flow_dir:REE->TA",
          "src_region:REE-visible",
          "dst_region:TEE-private",
          "sensitivity_label:unknown",
          "size_triplet:copy_len=params[0].memref.size,src_sz=unknown,dst_sz=1000",
          "dst_region:unknown",
          "size_triplet:copy_len=params[0].memref.size,src_sz=unknown,dst_sz=unknown"
        ]
      },
      "rule_distribution": {
        "other": 1,
        "shared_memory_overwrite": 1,
        "weak_input_validation": 1
      },
      "phase_distribution": {
        "unknown": 1
      }
    }
  ]
}