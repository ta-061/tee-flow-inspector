# External Function: EMSG
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "EMSG", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "EMSG",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "EMSG",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "It's a log macro; excluded as non-sink."
}

# External Function: TEE_AllocateOperation
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AllocateOperation", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AllocateOperation",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AllocateOperation",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "allocation/init function; not a write sink"
}

# External Function: TEE_AllocateTransientObject
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AllocateTransientObject", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AllocateTransientObject",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AllocateTransientObject",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "allocation/handle management; no documented write to buffers"
}

# External Function: TEE_AsymmetricEncrypt
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_AsymmetricEncrypt", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_AsymmetricEncrypt",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_AsymmetricEncrypt",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Asymmetric crypto primitive; not a plaintext sink."
}

# External Function: TEE_FreeOperation
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_FreeOperation", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_FreeOperation",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_FreeOperation",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Deallocation/handle management; no documented write signature"
}

# External Function: TEE_FreeTransientObject
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_FreeTransientObject", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_FreeTransientObject",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_FreeTransientObject",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "No documented write to buffers; deallocation API"
}

# External Function: TEE_GenerateKey
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_GenerateKey", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_GenerateKey",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_GenerateKey",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Key generation operates on cryptographic objects, not a direct user buffer write."
}

# External Function: TEE_GetObjectInfo1
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_GetObjectInfo1", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_GetObjectInfo1",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_GetObjectInfo1",
  "is_sink_candidate": true,
  "dangerous_params": [
    {"param_index": 0, "role": "dest", "reason": "Writes into user-provided output buffer (objectInfo)"}
  ],
  "reason": "Writes to a user-provided output buffer (objectInfo)"
}

# External Function: TEE_PARAM_TYPES
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_PARAM_TYPES", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_PARAM_TYPES",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_PARAM_TYPES",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "descriptor/helper; not a byte-writing sink"
}

# External Function: TEE_SetOperationKey
## Prompt:
You are a documentation‑informed screener for potential vulnerability sinks in OP‑TEE Trusted Applications (TAs).

TASK
Given ONLY a function name "TEE_SetOperationKey", return a binary decision:
- true  = sink candidate by semantics derived from the name AND your knowledge of GP TEE v1.3.1 / common C APIs
- false = not a sink candidate at this stage

THREAT CLASSES (consider any that apply)
1) Information leakage: writes attacker‑influenced bytes into REE‑visible or external buffers/channels.
2) Memory corruption: writes into a buffer where the write extent can be attacker‑controlled (len/size/loop bound).
3) Integrity impact: writes attacker‑influenced bytes to persistent/object/IO sinks affecting behavior on reload.

INCLUSION — DOCUMENTED WRITE FAMILIES (no project‑specific whitelists; use API family knowledge)
Return true if you can map the name to ONE of these families AND identify at least the destination/target parameter.
- A) memcpy‑like copy to destination buffer  
  Canonical roles: dest → idx 0; len/size → idx 2 when such param exists.
- B) printf/format‑like buffered output  
  Canonical roles: dest → idx 0; len/size → idx 1 when size is explicit.
- C) fill / random‑to‑buffer (memset/random‑like; writes pattern/generated bytes)  
  Canonical roles: dest → idx 0; len/size → idx 1 or 2 (use the documented position).
- D) persistent/object/IO write (handle, buf, len)  
  Canonical roles: buf → idx 1; len/size → idx 2.

NON‑EMPTY GUARD (avoid zero‑finds without over‑inclusion)
- If the name clearly belongs to A/B/C/D by documentation or widely known C/TEE conventions but ONLY the destination index is canonical for you, still return true with that single dangerous_param.  
- If you cannot confidently assign even the destination/target index, return false.

EXCLUSIONS (always return false at this stage)
- Allocation/Deallocation/Init/Reset/Populate/Key‑setup families (state/handle management; no byte writes).
- Crypto primitives (Cipher/AE/Asymmetric; incl. Init/Update/Final) — internal transforms, not plaintext sinks.
- Debug/trace/log macros (TRACE_*, DMSG/IMSG/EMSG) — exclude to reduce noise.
- Type/descriptor/access‑check helpers (e.g., PARAM_TYPES, Check*).
- Ambiguous verbs (process/handle/update/prepare/compute/convert) lacking a clear, documented write signature.

DANGEROUS PARAMS (emit only canonical, cross‑platform‑stable roles)
- Prefer dest/buf and len/size. Never mark memcpy‑like source (idx 1) as dangerous.
- If a family typically has no explicit length (e.g., some sprintf variants), emit just dest.

STRICT OUTPUT — ONE JSON (no prose, no code fences)
{
  "function": "TEE_SetOperationKey",
  "is_sink_candidate": true|false,
  "dangerous_params": [
    {"param_index": INT, "role": "dest|len|buf", "reason": "<= 16 words>"}
    // zero or more
  ],
  "reason": "<overall <= 16 words>"
}

DECISION HINTS (conceptual, not a whitelist)
- copy/move/concatenate → memcpy‑like (dest [+ len if present])
- print/format → printf‑like (dest [+ len if present])
- set/fill/generate/random → fill/random‑to‑buffer (dest [+ len if present])
- write/send/output with handle → persistent/object write (buf [+ len])
- alloc/free/init/reset/key/cipher/param/log/check → excluded

## Response:
{
  "function": "TEE_SetOperationKey",
  "is_sink_candidate": false,
  "dangerous_params": [],
  "reason": "Key-setup function; not a byte-write sink."
}

