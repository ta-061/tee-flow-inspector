#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
脆弱性解析結果のパース
"""

import re
import json
from typing import Dict, List, Tuple, Optional
from pathlib import Path

class VulnerabilityParser:
    """
    LLMの応答から脆弱性情報を抽出・パースするクラス
    """
    
    def __init__(self):
        self.stats = {
            "total_parses": 0,
            "parse_failures": 0,
            "vulnerabilities_found": 0,
            "inline_findings_found": 0
        }
    
    def parse_vuln_response(self, resp: str) -> Tuple[bool, dict]:
        """
        脆弱性判定レスポンスをパース
        
        Returns:
            (is_vulnerable, metadata)
        """
        self.stats["total_parses"] += 1
        
        # 複数の形式に対応
        # 1. マークダウンコードブロック内のJSON
        json_match = re.search(r'```(?:json)?\s*({.*?})\s*```', resp, re.DOTALL)
        if json_match:
            try:
                data = json.loads(json_match.group(1))
                flag = str(data.get("vulnerability_found", "")).lower()
                if flag == "yes":
                    self.stats["vulnerabilities_found"] += 1
                return flag == "yes", data
            except json.JSONDecodeError:
                pass
        
        # 2. 最初の行に直接JSON
        lines = resp.strip().splitlines()
        if lines:
            first_line = lines[0].strip()
            try:
                data = json.loads(first_line)
                flag = str(data.get("vulnerability_found", "")).lower()
                if flag == "yes":
                    self.stats["vulnerabilities_found"] += 1
                return flag == "yes", data
            except json.JSONDecodeError:
                pass
        
        # 3. テキスト内のどこかにJSON風の文字列
        json_pattern = re.search(r'{\s*"vulnerability_found"\s*:\s*"(yes|no)"\s*}', resp)
        if json_pattern:
            try:
                data = json.loads(json_pattern.group(0))
                flag = str(data.get("vulnerability_found", "")).lower()
                if flag == "yes":
                    self.stats["vulnerabilities_found"] += 1
                return flag == "yes", data
            except json.JSONDecodeError:
                pass
        
        # パースに失敗
        self.stats["parse_failures"] += 1
        return False, {}
    
    def parse_first_json_line(self, resp: str) -> Optional[dict]:
        """応答の最初のJSON行をパース"""
        lines = [l.strip() for l in (resp or "").splitlines() if l.strip()]
        if not lines:
            return None
        
        try:
            return json.loads(lines[0])
        except json.JSONDecodeError:
            # ```json ブロック内にも対応
            m = re.search(r'```(?:json)?\s*({.*?})\s*```', resp, re.DOTALL)
            if m:
                try:
                    return json.loads(m.group(1))
                except json.JSONDecodeError:
                    return None
        return None
    

    def extract_inline_findings(
        self, 
        resp: str, 
        func_name: str, 
        chain: List[str], 
        vd: dict, 
        project_root: Optional[Path] = None
    ) -> List[dict]:
        """
        応答からインライン脆弱性情報を抽出（改良版）
        """
        findings = []
        
        # 1) 新形式: FINDINGS=<json>
        # 行全体をマッチして、FINDINGS=以降を取得
        mjson = re.search(r'^\s*FINDINGS\s*=\s*(.+?)$', resp or "", re.MULTILINE)
        if mjson:
            try:
                json_str = mjson.group(1).strip()
                
                # JSONの終端を正しく検出
                # ブレースのバランスをチェックして正しいJSON部分を抽出
                brace_count = 0
                in_string = False
                escape_next = False
                json_end = 0
                
                for i, char in enumerate(json_str):
                    if escape_next:
                        escape_next = False
                        continue
                    
                    if char == '\\':
                        escape_next = True
                        continue
                    
                    if char == '"' and not in_string:
                        in_string = True
                    elif char == '"' and in_string:
                        in_string = False
                    elif not in_string:
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                            if brace_count == 0:
                                json_end = i + 1
                                break
                
                if json_end > 0:
                    # 正しいJSON部分のみを抽出
                    clean_json = json_str[:json_end]
                    
                    # 末尾に余分な文字がある場合の警告
                    if json_end < len(json_str):
                        extra_chars = json_str[json_end:].strip()
                        if extra_chars and extra_chars not in ['"', '}"', '}"}']:
                            print(f"[DEBUG] Extra characters after JSON: {repr(extra_chars)}")
                    
                    obj = json.loads(clean_json)
                    
                    for item in obj.get("items", []):
                        line_num = int(item.get("line", 0))
                        file_path = item.get("file") or vd.get("file")
                        
                        if line_num == 0:
                            print(f"[WARN] No line number provided for {func_name}")
                            continue
                        
                        if not self._validate_line_number(file_path, line_num, project_root):
                            print(f"[WARN] Invalid line number {line_num} for {file_path}")
                            continue
                        
                        findings.append({
                            "chain": chain,
                            "function": func_name,
                            "category": item.get("rule"),
                            "file": file_path,
                            "line": line_num,
                            "message": item.get("why") or "",
                            "source": "FINDINGS_JSON"
                        })
                else:
                    # ブレースが正しく閉じていない場合
                    print(f"[WARN] Invalid JSON structure in FINDINGS: braces not balanced")
                    print(f"[DEBUG] Raw JSON string: {repr(json_str[:100])}...")
                    
            except json.JSONDecodeError as e:
                # JSONパースエラーの詳細を表示
                print(f"[WARN] Failed to parse FINDINGS JSON: {e}")
                if mjson:
                    print(f"[DEBUG] Raw JSON string: {repr(mjson.group(1)[:100])}...")
            except Exception as e:
                print(f"[WARN] Unexpected error parsing FINDINGS: {e}")
            
            if findings:
                self.stats["inline_findings_found"] += len(findings)
                return findings
        
        # 2) 旧形式: FINDINGS: 箇条書き（既存のコード）
        m = re.search(r'^\s*FINDINGS:\s*(.*?)$', resp or "", re.IGNORECASE | re.MULTILINE | re.DOTALL)
        if m:
            block = m.group(1).strip()
            for line in block.splitlines():
                line = line.strip()
                mm = re.match(
                    r'-\s*\[(?P<cat>unencrypted_output|weak_input_validation|shared_memory_overwrite)\]\s*<(?P<file>[^:>]+):(?P<line>\d+)>\s*:\s*(?P<msg>.+)$',
                    line
                )
                if mm:
                    d = mm.groupdict()
                    line_num = int(d["line"])
                    file_path = d["file"]
                    
                    if not self._validate_line_number(file_path, line_num, project_root):
                        print(f"[WARN] Invalid line number {line_num} for {file_path}")
                        continue
                    
                    findings.append({
                        "chain": chain,
                        "function": func_name,
                        "category": d["cat"],
                        "file": file_path,
                        "line": line_num,
                        "message": d["msg"],
                        "source": "FINDINGS_BULLETS"
                    })
            
            if findings:
                self.stats["inline_findings_found"] += len(findings)
                return findings
        
        # 3) 互換形式: 1行JSONのrule_matchesから疑似生成（既存のコード）
        j = self.parse_first_json_line(resp)
        if j:
            rule_matches = j.get("rule_matches", []) or []
            sinks = j.get("sinks", []) or []
            ev = j.get("evidence", []) or []
            default_file = vd.get("file")
            default_line = vd.get("line")
            
            evidence_lines = []
            for e in ev:
                m2 = re.match(r'(?P<line>\d+)\s*:\s*(?P<what>.+)', str(e))
                if m2:
                    evidence_lines.append(int(m2.group("line")))
            
            line_hint = evidence_lines[0] if evidence_lines else default_line
            
            for cat in rule_matches:
                if line_hint and not self._validate_line_number(default_file, line_hint, project_root):
                    print(f"[WARN] Invalid line number {line_hint} for {default_file}")
                    continue
                
                findings.append({
                    "chain": chain,
                    "function": func_name,
                    "category": cat,
                    "file": default_file,
                    "line": line_hint or 0,
                    "message": "; ".join(map(str, sinks)) if sinks else "",
                    "source": "rule_matches"
                })
            
            if findings:
                self.stats["inline_findings_found"] += len(findings)
        
        return findings

    def extract_taint_state(self, response: str) -> dict:
        """関数解析レスポンスからテイント状態を抽出"""
        try:
            first_line = response.strip().split('\n')[0]
            data = json.loads(first_line)
            return {
                "propagated_values": data.get("propagation", []),
                "applied_sanitizers": data.get("sanitizers", []),
                "reached_sinks": data.get("sinks", [])
            }
        except:
            return {}
    
    def extract_security_observations(self, response: str) -> List[dict]:
        """セキュリティ関連の観察事項を抽出"""
        observations = []
        
        # FINDINGSから抽出
        findings_match = re.search(r'FINDINGS\s*=\s*({.*})', response)
        if findings_match:
            try:
                findings = json.loads(findings_match.group(1))
                for item in findings.get("items", []):
                    observations.append({
                        "type": item.get("rule"),
                        "observation": item.get("why"),
                        "location": f"{item.get('file')}:{item.get('line')}"
                    })
            except:
                pass
        
        return observations
    
    def extract_risk_indicators(self, response: str) -> List[str]:
        """レスポンスからリスク指標を抽出"""
        risk_indicators = []
        
        # JSONからrule_matchesを取得
        try:
            first_line = response.strip().split('\n')[0]
            data = json.loads(first_line)
            rule_matches = data.get("rule_matches", [])
            if rule_matches:
                risk_indicators.extend([f"Matched rule: {rule}" for rule in rule_matches])
        except:
            pass
        
        # テキストから危険なパターンを検出
        dangerous_patterns = [
            (r"no\s+bounds?\s+check", "No bounds checking detected"),
            (r"no\s+validation", "No validation detected"),
            (r"untrusted\s+input", "Untrusted input detected"),
            (r"without\s+sanitization", "Missing sanitization"),
            (r"buffer\s+overflow", "Potential buffer overflow"),
            (r"memory\s+corruption", "Potential memory corruption"),
            (r"injection", "Potential injection vulnerability")
        ]
        
        for pattern, indicator in dangerous_patterns:
            if re.search(pattern, response, re.IGNORECASE):
                risk_indicators.append(indicator)
        
        return list(set(risk_indicators))  # 重複を削除
    
    def parse_detailed_vuln_response(self, resp: str) -> dict:
        """LLMの脆弱性判定レスポンスから詳細情報を抽出"""
        lines = resp.strip().split('\n')
        
        # 1行目の判定結果
        vuln_decision = {}
        if lines:
            try:
                vuln_decision = json.loads(lines[0])
            except:
                pass
        
        # 2行目以降の詳細分析
        details = {}
        if len(lines) > 1:
            try:
                remaining_text = '\n'.join(lines[1:])
                
                # 複数のJSONブロックパターンに対応
                json_patterns = [
                    r'\{[\s\S]*"vulnerability_type"[\s\S]*\}',
                    r'\{[\s\S]*"severity"[\s\S]*\}',
                    r'\{[\s\S]*\}'
                ]
                
                for pattern in json_patterns:
                    json_match = re.search(pattern, remaining_text)
                    if json_match:
                        try:
                            details = json.loads(json_match.group(0))
                            break
                        except:
                            continue
                
                # JSONが見つからない場合は構造化解析
                if not details:
                    details = self._parse_structured_explanation(remaining_text)
                    
            except Exception as e:
                details = {"raw_explanation": '\n'.join(lines[1:]), "parse_error": str(e)}
        
        return {
            "decision": vuln_decision,
            "details": details,
            "full_response": resp
        }
    
    def _parse_structured_explanation(self, text: str) -> dict:
        """構造化されたテキスト説明から情報を抽出"""
        result = {
            "vulnerability_type": "Unknown",
            "severity": "Unknown",
            "description": text
        }
        
        # CWE番号の抽出
        cwe_match = re.search(r'CWE-(\d+)', text)
        if cwe_match:
            result["vulnerability_type"] = f"CWE-{cwe_match.group(1)}"
        
        # 重要度の抽出
        severity_match = re.search(r'(critical|high|medium|low)\s+severity', text, re.IGNORECASE)
        if severity_match:
            result["severity"] = severity_match.group(1).lower()
        
        # 攻撃シナリオの抽出
        if "attack" in text.lower() or "exploit" in text.lower():
            attack_section = re.search(r'(attack|exploit)[^.]*\.([^.]*\.){0,3}', text, re.IGNORECASE)
            if attack_section:
                result["attack_scenario"] = attack_section.group(0)
        
        return result
    
    def _validate_line_number(self, file_path: str, line_num: int, project_root: Optional[Path] = None) -> bool:
        """行番号が有効かチェック"""
        if line_num <= 0:
            return False
        
        try:
            if project_root and not Path(file_path).is_absolute():
                file_path = project_root / file_path
            
            if Path(file_path).exists():
                with open(file_path, 'r') as f:
                    total_lines = sum(1 for _ in f)
                    return 1 <= line_num <= total_lines
        except:
            pass
        
        return True
    
    def get_stats(self) -> dict:
        """統計情報を取得"""
        return self.stats.copy()