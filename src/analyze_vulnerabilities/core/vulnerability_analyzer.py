#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
脆弱性判定モジュール
最終的な脆弱性判定と整合性チェックを担当
"""

from typing import Dict, List
from ..prompts import get_end_prompt


class VulnerabilityAnalyzer:
    """最終的な脆弱性判定を担当するクラス"""
    
    def __init__(
        self,
        code_extractor,
        vuln_parser,
        logger,
        conversation_manager,
        llm_handler,
        consistency_checker
    ):
        """
        Args:
            code_extractor: コード抽出器
            vuln_parser: 脆弱性パーサー
            logger: ロガー
            conversation_manager: 会話管理
            llm_handler: LLMハンドラー
            consistency_checker: 整合性チェッカー
        """
        self.code_extractor = code_extractor
        self.vuln_parser = vuln_parser
        self.logger = logger
        self.conversation_manager = conversation_manager
        self.llm_handler = llm_handler
        self.consistency_checker = consistency_checker
        
        # 統計情報
        self.stats = {
            "vulnerability_analyses": 0,
            "vulnerabilities_found": 0,
            "consistency_reevaluations": 0,
            "consistency_downgrades": 0
        }
    
    def perform_vulnerability_analysis(self, results: dict, chain: List[str], vd: dict) -> dict:
        """
        最終的な脆弱性判定とEND_FINDINGSの収集（整合性チェック強化版）
        
        Args:
            results: これまでの解析結果
            chain: 関数チェイン
            vd: 脆弱性詳細
            
        Returns:
            脆弱性判定結果
        """
        self.stats["vulnerability_analyses"] += 1
        
        # 既存の脆弱性判定処理
        end_prompt = get_end_prompt()
        
        self.conversation_manager.add_message("user", end_prompt)
        self.logger.log_section("Vulnerability Analysis", level=2)
        self.logger.writeln("### Prompt:")
        self.logger.writeln(end_prompt)
        self.logger.writeln("")
        
        context = {
            "phase": "vulnerability_analysis",
            "chain": " -> ".join(chain),
            "sink": vd.get("sink", "unknown")
        }
        
        vuln_response = self.llm_handler.ask_with_handler(context, self.conversation_manager)
        
        self.logger.writeln("### Response:")
        self.logger.writeln(vuln_response)
        self.logger.writeln("")
        
        # 脆弱性判定をパース
        is_vuln, meta = self.vuln_parser.parse_vuln_response(vuln_response)
        vuln_details = self.vuln_parser.parse_detailed_vuln_response(vuln_response)
        
        if is_vuln:
            self.stats["vulnerabilities_found"] += 1
        
        # END_FINDINGSを抽出
        self._extract_end_findings(vuln_response, results, chain, vd)
        
        # 整合性チェック1: テイントフロー
        has_valid_taint_flow = self.consistency_checker.validate_taint_flow(results, chain, vd)
        
        if is_vuln and not has_valid_taint_flow:
            self.logger.writeln("[CONSISTENCY] No valid REE->sink path detected, triggering reevaluation")
            reevaluation = self._reevaluate_with_consistency(results, chain, vd)
            
            if reevaluation["reevaluated"]:
                is_vuln = reevaluation["is_vulnerable"]
                meta["reevaluated"] = True
                meta["reevaluation_reason"] = "no_taint_flow_path"
                vuln_response = reevaluation["reevaluation_response"]
                self.stats["consistency_reevaluations"] += 1
                
                self.logger.writeln(f"[CONSISTENCY] Reevaluation result: {'vulnerable' if is_vuln else 'not vulnerable'}")
        
        # 整合性チェック2: Findings一貫性
        findings_consistency = self.consistency_checker.check_findings_consistency(results, is_vuln)
        
        if not findings_consistency["is_consistent"]:
            meta["consistency_warning"] = findings_consistency["inconsistency_type"]
            
            # 矛盾が深刻な場合はダウングレード
            if findings_consistency["suggested_action"] == "downgrade_to_no_vuln":
                self.logger.writeln("[CONSISTENCY] Downgrading to no vulnerability due to lack of findings")
                is_vuln = False
                meta["downgraded"] = True
                meta["downgrade_reason"] = "no_supporting_findings"
                self.stats["consistency_downgrades"] += 1
        
        # 最終結果の構築
        result = {
            "vulnerability": vuln_response,
            "vulnerability_details": vuln_details,
            "is_vulnerable": is_vuln,
            "meta": meta,
            "consistency_checks": {
                "taint_flow_valid": has_valid_taint_flow,
                "findings_consistent": findings_consistency["is_consistent"]
            }
        }
        
        return result
    
    def _extract_end_findings(self, vuln_response: str, results: dict, chain: List[str], vd: dict) -> None:
        """END_FINDINGSを抽出して結果に追加"""
        try:
            func_name = chain[-1] if chain else "unknown"
            current_func_info = None
            if func_name in self.code_extractor.user_functions:
                current_func_info = self.code_extractor.user_functions[func_name]
            
            extended_vd = vd.copy()
            if current_func_info:
                extended_vd['current_file'] = current_func_info['file']
                extended_vd['current_line'] = current_func_info['line']
            
            end_findings = self.vuln_parser.extract_end_findings(
                vuln_response, func_name, chain, extended_vd,
                self.code_extractor.project_root
            )
            
            if end_findings:
                results["inline_findings"].extend(end_findings)
                self.logger.writeln(f"[INFO] Extracted {len(end_findings)} END_FINDINGS")
        except Exception as e:
            self.logger.writeln(f"[WARN] END_FINDINGS parse failed: {e}")
    
    def _reevaluate_with_consistency(self, results: dict, chain: List[str], vd: dict) -> dict:
        """整合性チェックに基づく再評価"""
        reevaluation_prompt = """Based on the taint analysis, reconsider the vulnerability assessment:

IMPORTANT: A vulnerability exists ONLY if:
1. Data from REE (untrusted source) actually flows to a dangerous sink
2. The data flow is explicit and traceable through the code
3. There are insufficient sanitizers or bounds checks

Review the analysis and provide a corrected assessment.
Was there an ACTUAL data flow from REE inputs to the sink? Answer with the standard two-line format."""

        # 会話に再評価プロンプトを追加
        self.conversation_manager.add_message("user", reevaluation_prompt)
        
        # LLMに問い合わせ
        context = {
            "phase": "consistency_reevaluation",
            "chain": " -> ".join(chain),
            "sink": vd.get("sink", "unknown")
        }
        
        response = self.llm_handler.ask_with_handler(context, self.conversation_manager)
        
        # ログ記録
        self.logger.writeln("\n[REEVALUATION] Consistency check triggered")
        self.logger.writeln(response)
        
        # 再評価結果をパース
        is_vuln, meta = self.vuln_parser.parse_vuln_response(response)
        
        return {
            "reevaluated": True,
            "is_vulnerable": is_vuln,
            "reevaluation_response": response,
            "meta": meta
        }
    
    def get_stats(self) -> Dict:
        """統計情報を取得"""
        return self.stats.copy()