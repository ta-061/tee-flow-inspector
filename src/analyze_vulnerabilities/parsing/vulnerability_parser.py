#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
脆弱性解析結果のパース（改善版）
FINDINGS/END_FINDINGSの両方に対応し、堅牢なJSON解析を実装
プレースホルダー置換とバリデーション緩和を追加
"""

import re
import json
import hashlib
from typing import Dict, List, Tuple, Optional
from pathlib import Path
from .json_repair import JSONRepair


class VulnerabilityParser:
    def __init__(self, debug=False):
        self.debug = debug
        self.json_repair = JSONRepair(debug=debug)
        self.stats = {
            "total_parses": 0,
            "parse_failures": 0,
            "vulnerabilities_found": 0,
            "inline_findings_found": 0,
            "end_findings_found": 0,
            "findings_parse_attempts": 0,
            "findings_parse_successes": 0,
            "findings_parse_failures": 0,
            "placeholder_replacements": 0,
            "line_coercions": 0,
            "fallback_extractions": 0,
            "json_extractions": 0,
            "json_extraction_failures": 0
        }
        # 動的ルールの初期値（既存の3種をデフォルトに）
        self.known_rules = ["unencrypted_output", "weak_input_validation", "shared_memory_overwrite"]

    def extract_json_from_response(self, response: str) -> Optional[Dict]:
        """
        LLMレスポンスからJSON部分を抽出（新規追加メソッド）
        プロンプトの期待する形式に対応
        
        Args:
            response: LLMのレスポンス文字列
            
        Returns:
            抽出されたJSONオブジェクト、または None
        """
        self.stats["json_extractions"] += 1
        
        if not response:
            self.stats["json_extraction_failures"] += 1
            return None
        
        try:
            # 方法1: 最初の行をJSONとして解析（プロンプトの期待する形式）
            lines = response.strip().split('\n')
            if lines:
                first_line = lines[0].strip()
                # コメントや余分な文字を削除
                if first_line.startswith('```'):
                    first_line = first_line[3:]
                if first_line.endswith('```'):
                    first_line = first_line[:-3]
                
                try:
                    result = json.loads(first_line)
                    if isinstance(result, dict):
                        # プロンプトが期待するキーがあるか確認
                        expected_keys = {"function", "propagation", "sanitizers", "sinks", "evidence", "rule_matches"}
                        if any(key in result for key in expected_keys):
                            return result
                        # 脆弱性判定レスポンスの場合
                        if "vulnerability_found" in result or "vulnerability" in result:
                            return result
                        # シンク解析レスポンスの場合
                        if "sink_reached" in result or "receives_tainted" in result:
                            return result
                except:
                    pass
            
            # 方法2: レスポンス全体をJSONとして解析
            try:
                result = json.loads(response.strip())
                if isinstance(result, dict):
                    return result
            except:
                pass
            
            # 方法3: JSONブロックを探す（```json ... ```）
            json_pattern = r'```json\s*(.*?)\s*```'
            matches = re.findall(json_pattern, response, re.DOTALL | re.IGNORECASE)
            if matches:
                for match in matches:
                    try:
                        result = json.loads(match.strip())
                        if isinstance(result, dict):
                            return result
                    except:
                        continue
            
            # 方法4: 中括弧で囲まれた最初の完全なJSONオブジェクトを探す
            json_obj_pattern = r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}'
            matches = re.finditer(json_obj_pattern, response)
            
            for match in matches:
                try:
                    obj_str = match.group(0)
                    result = json.loads(obj_str)
                    if isinstance(result, dict):
                        # 必要なキーが含まれているか確認
                        if any(key in result for key in ["function", "vulnerability_found", "sink_reached", "receives_tainted"]):
                            return result
                except:
                    continue
            
            # 方法5: JSONRepairを使用（フォールバック）
            if hasattr(self, 'json_repair'):
                result = self.json_repair.safe_json_loads(response, None)
                if isinstance(result, dict):
                    return result
            
            self.stats["json_extraction_failures"] += 1
            return None
            
        except Exception as e:
            if self.debug:
                print(f"[DEBUG] JSON extraction error: {e}")
            self.stats["json_extraction_failures"] += 1
            return None

    def validate_taint_response_format(self, response: str) -> Tuple[bool, str]:
        """
        テイント解析応答の形式を検証（厳密版）
        Returns: (is_valid, error_message)
        """
        lines = [l.strip() for l in (response or "").splitlines() if l.strip()]
        if not lines:
            return False, "Empty response"

        # --- 1st line: strict JSON object check ---
        first_line_data = self.extract_json_from_response(lines[0])
        if not isinstance(first_line_data, dict):
            return False, "First line is not a valid JSON object"

        required_keys = {"function", "propagation", "sanitizers", "sinks", "evidence", "rule_matches"}
        missing = required_keys - set(first_line_data.keys())
        if missing:
            return False, f"Missing required keys: {sorted(missing)}"

        # type checks
        for k in ("propagation", "sanitizers", "sinks", "evidence"):
            if not isinstance(first_line_data.get(k), list):
                return False, f"'{k}' must be an array"

        rm = first_line_data.get("rule_matches")
        if not isinstance(rm, dict):
            return False, "'rule_matches' must be an object with 'rule_id' and 'others'"
        if not isinstance(rm.get("rule_id"), list) or not isinstance(rm.get("others"), list):
            return False, "'rule_matches.rule_id' and 'rule_matches.others' must be arrays"

        # --- 2nd line: FINDINGS= {...} must exist ---
        if len(lines) < 2:
            return False, "Missing second line: FINDINGS={...}"

        if not re.match(r'^FINDINGS\s*=', lines[1]):
            return False, "Second line must begin with 'FINDINGS='"

        # Try parsing FINDINGS using JSONRepair patterns
        patterns = [
            r'^FINDINGS\s*=\s*(\{"items"\s*:\s*\[[\s\S]*?\]\})',
            r'^FINDINGS\s*=\s*(\{[\s\S]*"items"[\s\S]*\})'
        ]
        matches = self.json_repair.extract_json_patterns("\n".join(lines[1:]), patterns)
        obj = self.json_repair.parse_best_match(matches, {"items": []})
        if "items" not in obj:
            return False, "FINDINGS does not contain an 'items' array"

        return True, ""

    def set_known_rules(self, rules_json: dict):
        """CodeQLルールから既知のrule_idリストを設定"""
        ids = []
        for k in ("detection_rules", "rules"):
            for rule in (rules_json.get(k) or []):
                rid = rule.get("rule_id")
                if rid:
                    ids.append(rid)
        if ids:
            self.known_rules = sorted(set(ids))
    
    def _coerce_placeholder_file(self, path: Optional[str], default_file: Optional[str]) -> Optional[str]:
        """
        プレースホルダーを既定ファイルに置換する
        """
        if not path:
            return default_file
        
        path_str = str(path).strip()
        path_lower = path_str.lower()
        
        # よく見られるプレースホルダーのパターン
        placeholders = {
            "unknown", "<path>", "<path|'unknown'>", "n/a", "na", 
            "???", "undefined", "null", "none", "<file>", "<unknown>"
        }
        
        # プレースホルダーを検出
        is_placeholder = (
            path_lower in placeholders or
            any(p in path_lower for p in ["unknown", "<path", "<file"]) or
            path_str.startswith("<") and path_str.endswith(">")
        )
        
        if is_placeholder:
            if self.debug:
                print(f"[DEBUG] Replacing placeholder '{path}' with '{default_file}'")
            self.stats["placeholder_replacements"] += 1
            return default_file
        
        return path
    
    def parse_vuln_response(self, resp: str) -> Tuple[bool, dict]:
        """
        脆弱性判定レスポンスをパース
        """
        self.stats["total_parses"] += 1
        
        # extract_json_from_responseを使用
        data = self.extract_json_from_response(resp)
        
        if data:
            flag = str(data.get("vulnerability_found", "")).lower()
            if flag == "yes":
                self.stats["vulnerabilities_found"] += 1
            return flag == "yes", data
        
        # フォールバック: テキスト内のパターンマッチ
        json_pattern = re.search(r'{\s*"vulnerability_found"\s*:\s*"(yes|no)"\s*}', resp)
        if json_pattern:
            flag = json_pattern.group(1).lower()
            if flag == "yes":
                self.stats["vulnerabilities_found"] += 1
            return flag == "yes", {"vulnerability_found": flag}
        
        # パースに失敗
        self.stats["parse_failures"] += 1
        return False, {}
    
    def parse_first_json_line(self, resp: str) -> Optional[dict]:
        """応答の最初のJSON行をパース（extract_json_from_responseを使用）"""
        return self.extract_json_from_response(resp)
    
    def make_finding_id(self, file_path: str, function: str, primary_rule_id: str, line: int, bucket: int = 2) -> str:
        """
        脆弱性発見項目のユニークIDを生成
        """
        key = f"{file_path}:{function}:{primary_rule_id}:{line // max(1, bucket)}"
        return hashlib.sha1(key.encode()).hexdigest()[:12]
    
    def _standardize_finding(
        self, 
        item: dict, 
        func_name: str, 
        phase: str = "middle",
        default_file: Optional[str] = None
    ) -> dict:
        """
        発見項目を標準化し、必須フィールドを補完
        """
        # phaseの補完と正規化
        if "phase" not in item:
            item["phase"] = phase
        else:
            current_phase = item["phase"].lower()
            if current_phase == "start":
                item["phase"] = "middle"
            elif current_phase not in ["middle", "end"]:
                item["phase"] = phase
        
        # functionの補完
        if "function" not in item or not item["function"]:
            item["function"] = func_name
        
        # sink_functionの補完
        if "sink_function" not in item:
            item["sink_function"] = "unknown"
        
        # rule_matchesの補完
        if "rule_matches" not in item:
            if "rule" in item and item["rule"]:
                rule = item["rule"]
                rule_ids = []
                known_rules = self.known_rules
                # パイプ区切りも対応
                if "|" in rule:
                    for pr in (x.strip() for x in rule.split("|")):
                        if pr in known_rules:
                            rule_ids.append(pr)
                elif rule in known_rules:
                    rule_ids.append(rule)

                if rule_ids:
                    item["rule_matches"] = {"rule_id": sorted(set(rule_ids)), "others": []}
                else:
                    item["rule_matches"] = {"rule_id": [], "others": [rule] if rule else []}
            else:
                item["rule_matches"] = {"rule_id": [], "others": []}
        else:
            # 既存のrule_matchesを正規化
            known_rules = self.known_rules
            rm = item["rule_matches"] if isinstance(item["rule_matches"], dict) else {}
            rids = [r for r in (rm.get("rule_id") or []) if r in known_rules]
            others = (rm.get("others") or []) + [r for r in (rm.get("rule_id") or []) if r not in known_rules]
            item["rule_matches"] = {
                "rule_id": sorted(set(rids)),
                "others": sorted(set(others))
            }
        
        if "line" not in item:
            item["line"] = 1
        else:
            line = item.get("line", 1)
            # リストの場合は最初の要素を使用
            if isinstance(line, list):
                line = line[0] if line else 1
            try:
                item["line"] = int(line)
            except Exception:
                item["line"] = 1
            item["line"] = max(1, item["line"])
        
        # primary_rule_idの取得
        primary_rule_id = "none"
        if item["rule_matches"]["rule_id"]:
            primary_rule_id = item["rule_matches"]["rule_id"][0]
        elif item.get("rule"):
            rule = item["rule"]
            if "|" in rule:
                primary_rule_id = rule.split("|")[0].strip()
            else:
                primary_rule_id = rule
        
        # IDの生成
        item["id"] = self.make_finding_id(
            file_path=item.get("file", "unknown"),
            function=item["function"],
            primary_rule_id=primary_rule_id,
            line=item["line"]
        )
        
        return item

    # 以下、既存のメソッドはそのまま（エンコーディングの問題は解決済み）
    def extract_inline_findings(
        self, 
        resp: str, 
        func_name: str, 
        chain: List[str], 
        vd: dict, 
        project_root: Optional[Path] = None
    ) -> List[dict]:
        """
        応答からインライン脆弱性情報を抽出（FINDINGS形式）
        """
        findings = []
        self.stats["findings_parse_attempts"] += 1
        
        default_file = vd.get('current_file', vd.get('file'))
        
        if self.debug:
            print(f"[DEBUG] Attempting to extract FINDINGS from response (len={len(resp)})")
        
        # 厳密→緩いの順でパターンを定義
        patterns = [
            r'FINDINGS\s*=\s*(\{"items"\s*:\s*\[[^\]]*\]\})',
            r'FINDINGS\s*=\s*(\{[^}]*"items"[^}]*\})',
            r'FINDINGS\s*=\s*(\{.*?\})\s*(?:\n|$)',
            r'^\s*FINDINGS\s*=\s*(.+?)$',
            r'FINDINGS\s*=\s*(\{.*?\})',
        ]
        
        matches = self.json_repair.extract_json_patterns(resp or "", patterns)
        
        if not matches and "FINDINGS" in (resp or ""):
            print(f"[WARN] 'FINDINGS' found in response but no patterns matched")
            if self.debug:
                findings_pos = resp.find("FINDINGS")
                snippet = resp[findings_pos:findings_pos+200] if findings_pos >= 0 else ""
                print(f"[DEBUG] Response snippet: {repr(snippet)}")
            self.stats["findings_parse_failures"] += 1
            return findings
        
        obj = self.json_repair.parse_best_match(matches, {"items": []})
        items = obj.get("items", [])
        
        if not items:
            if self.debug:
                print(f"[DEBUG] Successfully parsed FINDINGS with 0 items (no vulnerabilities found)")
            self.stats["findings_parse_successes"] += 1
            return findings
        
        if self.debug:
            print(f"[DEBUG] Successfully parsed FINDINGS with {len(items)} items")
        
        self.stats["findings_parse_successes"] += 1
        
        for item in items:
            standardized = self._standardize_finding(
                item.copy(),
                func_name=func_name,
                phase="middle",
                default_file=default_file
            )
            
            line_num = standardized["line"]
            file_path = standardized["file"]
            
            # 行番号検証（緩和版 - 警告のみ）
            if not self._validate_line_number(file_path, line_num, project_root):
                print(f"[WARN] Line number {line_num} may be invalid for {file_path}")
                # フォールバックとして vd の行番号を使用
                if vd.get("line"):
                    standardized["line"] = vd["line"]
                    standardized.setdefault("meta", {})["line_coerced"] = True
                    self.stats["line_coercions"] += 1
            
            findings.append({
                "id": standardized["id"],
                "chain": chain,
                "function": standardized["function"],
                "sink_function": standardized["sink_function"],
                "category": standardized.get("rule"),
                "file": file_path,
                "line": standardized["line"],
                "message": standardized.get("why") or "",
                "phase": standardized["phase"],
                "rule_matches": standardized["rule_matches"],
                "rag_refs": item.get("rag_refs", []), 
                "code_excerpt": item.get("code_excerpt"),
                "source": "FINDINGS_JSON",
                "meta": standardized.get("meta", {})
            })
            
            if self.debug:
                print(f"[DEBUG] Added finding: {standardized['function']} at {file_path}:{standardized['line']}")
        
        if findings:
            self.stats["inline_findings_found"] += len(findings)
            if self.debug:
                print(f"[DEBUG] Total findings extracted: {len(findings)}")
        
        return findings
    
    def extract_end_findings(
        self, 
        resp: str, 
        func_name: str, 
        chain: List[str], 
        vd: dict,
        project_root: Optional[Path] = None
    ) -> List[dict]:
        """
        END_FINDINGS抽出（改善版）
        """
        findings = []
        default_file = vd.get('current_file', vd.get('file'))
        
        if self.debug:
            print(f"[DEBUG] Attempting to extract END_FINDINGS from response")

        # パターンマッチング
        patterns = [
            r'END_FINDINGS\s*=\s*(\{"items"\s*:\s*\[[^\]]*\]\})',
            r'END_FINDINGS\s*=\s*(\{[^}]*"items"[^}]*\})',
            r'END_FINDINGS\s*=\s*(\{.*?\})\s*(?:\n|$)',
            r'^\s*END_FINDINGS\s*=\s*(\{.*\})\s*$',
            r'^\s*END_FINDINGS\s*:\s*(\{.*\})\s*$',
            r'^\s*END_FINDINGS\s*->\s*(\{.*\})\s*$'
        ]
        
        matches = self.json_repair.extract_json_patterns(resp or "", patterns)
        
        # END_FINDINGSが見つからない場合、FINDINGSにフォールバック
        if not matches:
            if "END_FINDINGS" in (resp or ""):
                print(f"[WARN] 'END_FINDINGS' found but no patterns matched")
            
            # FINDINGSを探す
            if "FINDINGS" in (resp or ""):
                print(f"[INFO] Falling back to FINDINGS extraction")
                self.stats["fallback_extractions"] += 1
                return self.extract_inline_findings(resp, func_name, chain, vd, project_root)
            
            return findings

        obj = self.json_repair.parse_best_match(matches, {"items": []})
        items = obj.get("items", [])
        
        if self.debug:
            print(f"[DEBUG] Successfully parsed END_FINDINGS with {len(items)} items")
        
        for item in items:
            std = self._standardize_finding(
                item.copy(), 
                func_name=func_name, 
                phase="end", 
                default_file=default_file
            )
            
            # 行番号検証を緩和（警告のみ、棄却しない）
            if not self._validate_line_number(std.get("file"), std.get("line"), project_root):
                original_line = std.get("line")
                # vdの行番号をフォールバック
                std["line"] = vd.get("line", 1)
                print(f"[WARN] Invalid line {original_line} for {std.get('file')}, using line {std['line']}")
                std.setdefault("meta", {})["line_coerced"] = True
                self.stats["line_coercions"] += 1

            # findingを追加（棄却しない）
            findings.append({
                "id": std["id"],
                "chain": chain,
                "function": std["function"],
                "sink_function": std["sink_function"],
                "category": std.get("rule"),
                "file": std.get("file"),
                "line": std.get("line"),
                "message": item.get("why") or std.get("why") or "",
                "phase": std["phase"],
                "rule_matches": std["rule_matches"],
                "rag_refs": item.get("rag_refs", []),
                "code_excerpt": item.get("code_excerpt"),
                "source": "END_FINDINGS",
                "meta": std.get("meta", {})
            })

        if findings:
            self.stats["end_findings_found"] += len(findings)
            print(f"[INFO] Extracted {len(findings)} END_FINDINGS")

        return findings

    def extract_all_findings(
        self,
        resp: str,
        func_name: str,
        chain: List[str],
        vd: dict,
        project_root: Optional[Path] = None
    ) -> List[dict]:
        """
        応答からFINDINGSとEND_FINDINGSの両方を抽出
        """
        all_findings = []
        
        if self.debug:
            print(f"\n[DEBUG] === Extracting findings for function: {func_name} ===")
        
        # FINDINGS（中間）を抽出
        inline_findings = self.extract_inline_findings(
            resp, func_name, chain, vd, project_root
        )
        all_findings.extend(inline_findings)
        
        # END_FINDINGS（最終）を抽出
        end_findings = self.extract_end_findings(
            resp, func_name, chain, vd, project_root
        )
        all_findings.extend(end_findings)
        
        if self.debug:
            print(f"[DEBUG] Total findings extracted: {len(all_findings)} "
                  f"(inline: {len(inline_findings)}, end: {len(end_findings)})")
        
        return all_findings
    
    def extract_all_findings_flexible(
        self, 
        resp: str, 
        func_name: str, 
        chain: List[str],
        vd: dict, 
        project_root: Optional[Path] = None
    ) -> List[dict]:
        """
        すべての種類のFINDINGSを柔軟に抽出する
        """
        all_findings = []
        seen_ids = set()
        
        # 1. END_FINDINGSを試す
        end_findings = self.extract_end_findings(resp, func_name, chain, vd, project_root)
        for f in end_findings:
            if f["id"] not in seen_ids:
                all_findings.append(f)
                seen_ids.add(f["id"])
        
        # 2. 通常のFINDINGSを試す（END_FINDINGSと重複しないもののみ）
        inline_findings = self.extract_inline_findings(resp, func_name, chain, vd, project_root)
        for f in inline_findings:
            if f["id"] not in seen_ids:
                all_findings.append(f)
                seen_ids.add(f["id"])
        
        # 3. その他のパターン（VULNERABILITY_FINDINGS等）も探す
        other_patterns = [
            (r'VULNERABILITY_FINDINGS\s*=\s*(\{.*?\})', "VULNERABILITY_FINDINGS"),
            (r'FINAL_FINDINGS\s*=\s*(\{.*?\})', "FINAL_FINDINGS"),
            (r'SINK_FINDINGS\s*=\s*(\{.*?\})', "SINK_FINDINGS")
        ]
        
        for pattern, source_name in other_patterns:
            matches = self.json_repair.extract_json_patterns(resp, [pattern])
            for _, json_str in matches:
                obj = self.json_repair.safe_json_loads(json_str, {"items": []})
                for item in obj.get("items", []):
                    std = self._standardize_finding(
                        item.copy(), func_name, "end", vd.get('file')
                    )
                    if std["id"] not in seen_ids:
                        finding = {
                            "id": std["id"],
                            "chain": chain,
                            "function": std["function"],
                            "sink_function": std["sink_function"],
                            "category": std.get("rule"),
                            "file": std.get("file"),
                            "line": std.get("line"),
                            "message": item.get("why") or "",
                            "phase": std["phase"],
                            "rule_matches": std["rule_matches"],
                            "source": source_name,
                            "meta": std.get("meta", {})
                        }
                        all_findings.append(finding)
                        seen_ids.add(std["id"])
        
        if all_findings:
            unique_inline = len([f for f in all_findings if f["source"] == "FINDINGS_JSON"])
            unique_end = len([f for f in all_findings if f["source"] == "END_FINDINGS"])
            unique_other = len(all_findings) - unique_inline - unique_end
            
            print(f"[INFO] Flexible extraction found {len(all_findings)} findings "
                  f"(FINDINGS: {unique_inline}, END: {unique_end}, OTHER: {unique_other})")
        
        return all_findings
    
    def extract_taint_state(self, response: str) -> dict:
        """関数解析レスポンスからテイント状態を抽出"""
        parsed = self.extract_json_from_response(response)
        if not parsed:
            return {}
        
        return {
            "propagated_values": parsed.get("propagation", []),
            "applied_sanitizers": parsed.get("sanitizers", []),
            "reached_sinks": parsed.get("sinks", [])
        }
    
    def extract_security_observations(self, response: str) -> List[str]:
        """セキュリティ観察事項を抽出"""
        observations = []
        parsed = self.extract_json_from_response(response)
        
        if not parsed:
            return observations
        
        # validationフィールドから抽出
        if "validation" in parsed and parsed["validation"]:
            observations.append(f"Validation: {parsed['validation']}")
        
        # transformationsから抽出
        if "transformations" in parsed:
            for transform in parsed["transformations"]:
                if isinstance(transform, str):
                    if "validation" in transform.lower() or "sanitiz" in transform.lower():
                        observations.append(transform)
        
        return observations
    
    def extract_risk_indicators(self, response: str) -> List[str]:
        """リスク指標を抽出"""
        indicators = []
        parsed = self.extract_json_from_response(response)
        
        if not parsed:
            return indicators
        
        # 脆弱性フラグ
        if parsed.get("vulnerability"):
            indicators.append("VULNERABILITY_DETECTED")
        
        # シンク到達
        if parsed.get("sink_reached"):
            indicators.append("SINK_REACHED")
        
        # リスクレベル
        risk_level = parsed.get("risk_level", "").lower()
        severity = parsed.get("severity", "").lower()
        
        if risk_level == "high" or severity in ["high", "critical"]:
            indicators.append("HIGH_RISK")
        elif risk_level == "medium" or severity == "medium":
            indicators.append("MEDIUM_RISK")
        
        # バリデーション不足
        validation = parsed.get("validation", "")
        if isinstance(validation, str) and ("no validation" in validation.lower() or "no sanitization" in validation.lower()):
            indicators.append("NO_VALIDATION")
        
        return indicators
    
    def parse_detailed_vuln_response(self, resp: str) -> dict:
        """
        脆弱性判定レスポンスから詳細情報を抽出
        
        Args:
            resp: LLMの脆弱性判定レスポンス
            
        Returns:
            詳細情報の辞書
        """
        details = {
            "vulnerability_type": "unknown",
            "severity": "unknown",
            "description": "",
            "affected_parameters": [],
            "attack_vectors": [],
            "details": {}
        }
        
        # JSONとして解析を試みる
        parsed = self.extract_json_from_response(resp)
        
        if parsed:
            # vulnerability_details フィールドがある場合
            if "vulnerability_details" in parsed:
                details.update(parsed["vulnerability_details"])
            
            # 個別フィールドから情報を収集
            if "vulnerability_type" in parsed:
                details["vulnerability_type"] = parsed["vulnerability_type"]
            if "severity" in parsed:
                details["severity"] = parsed["severity"]
            if "description" in parsed:
                details["description"] = parsed["description"]
            if "details" in parsed:
                details["details"] = parsed["details"]
            
            # 追加の詳細情報
            if "affected_params" in parsed:
                details["affected_parameters"] = parsed["affected_params"]
            if "attack_vectors" in parsed:
                details["attack_vectors"] = parsed["attack_vectors"]
        
        # テキストからも情報を抽出（フォールバック）
        if not details["vulnerability_type"] or details["vulnerability_type"] == "unknown":
            # よくある脆弱性タイプを検出
            resp_lower = resp.lower()
            if "buffer overflow" in resp_lower:
                details["vulnerability_type"] = "buffer_overflow"
            elif "memory corruption" in resp_lower:
                details["vulnerability_type"] = "memory_corruption"
            elif "information disclosure" in resp_lower:
                details["vulnerability_type"] = "information_disclosure"
            elif "integer overflow" in resp_lower:
                details["vulnerability_type"] = "integer_overflow"
            elif "injection" in resp_lower:
                details["vulnerability_type"] = "injection"
            elif "unencrypted" in resp_lower:
                details["vulnerability_type"] = "unencrypted_output"
            elif "weak" in resp_lower and "validation" in resp_lower:
                details["vulnerability_type"] = "weak_input_validation"
        
        # 重要度の検出
        if not details["severity"] or details["severity"] == "unknown":
            resp_lower = resp.lower()
            if "critical" in resp_lower:
                details["severity"] = "critical"
            elif "high" in resp_lower:
                details["severity"] = "high"
            elif "medium" in resp_lower:
                details["severity"] = "medium"
            elif "low" in resp_lower:
                details["severity"] = "low"
        
        return details
    
    def _validate_line_number(self, file_path: str, line_num: int, project_root: Optional[Path] = None) -> bool:
        """行番号が有効かチェック（緩和版）"""
        if line_num <= 0:
            return False
        
        # ファイルが存在する場合のみ厳密にチェック
        try:
            if project_root and not Path(file_path).is_absolute():
                file_path = project_root / file_path
            
            if Path(file_path).exists():
                with open(file_path, 'r') as f:
                    total_lines = sum(1 for _ in f)
                    return 1 <= line_num <= total_lines
        except:
            pass
        
        # ファイルが見つからない場合は、妥当な範囲内ならOKとする
        return 1 <= line_num <= 100000
    
    def get_stats(self) -> dict:
        """統計情報を取得"""
        combined_stats = self.stats.copy()
        if hasattr(self, 'json_repair'):
            combined_stats["json_repair"] = self.json_repair.get_stats()
        return combined_stats
    
    def set_debug(self, debug: bool):
        """デバッグモードの設定"""
        self.debug = debug
        if hasattr(self, 'json_repair'):
            self.json_repair.debug = debug